//start//
/*
describe-library{
This are edited versions of Cam's DELETE/CLONE/ALTER_EFFECT (shipped with WEIDU)
that allows for finer control on the savingthrow and special fields, and also to 
check the value of a function ('match_function') and apply one ('function'). Functions can be anonymous.

Technically this library depends on lib_anon (and, via that, on lib_sugar, lib_tools and lib_fn),
but this only applies if you use anonymous functions. Without them, this is self-contained.
}
ignore-dependencies{anon_define}

*/

/*
technical-note{
Changes consist of (i) new INT_VAR variables; (ii) two functions and one macro, at
end; (iii) calls to those functions and macro inserted into the code; (iv) a
small insert into the big AND loop that checks if a match is found; (v) allowing parameter1
and parameter2 to take negative values up to -10
}
*/

DEFINE_PATCH_FUNCTION CLONE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching
  
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-11"
          parameter2          = "-11"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"
          
  // DavidW's additional variables for the new effect
  
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"
          

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          insert              = "above"

  // DavidW's additional functional variables

          match_function      = ""//function
          function            = ""//function
BEGIN

  LPM dw_internal_initialise_bit
  PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.1" = 0) BEGIN // iwd2, are v9.1
    READ_LONG  0x78 ent_off
    READ_LONG  0x7c ent_num
  END ELSE BEGIN
    READ_LONG  0x68 ent_off
    READ_LONG  0x6c ent_num
  END

  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_FAIL "ERROR: CLONE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_FAIL "ERROR: CLONE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        PATCH_IF "%sig%" STR_EQ "SPL " BEGIN
			READ_SHORT  (abil_off +  0x10 + (abil_length * index)) level
		END ELSE BEGIN
			level=1
		END
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET last = 0                              // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < (counter - last) ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0)))
          BEGIN
            // now that we've got a match, read-and-clone it:
            READ_ASCII   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) clone (0x30 + (0xd8 * fx_type))
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "below" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2 + 1) * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "first" = 0) BEGIN
              SET base = (fx_off        + (abil_fx_idx * (0x30 + (0xd8 * fx_type))))
            END ELSE
            PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
              SET base = (fx_off        + ((abil_fx_idx + counter) * (0x30 + (0xd8 * fx_type))))
            END ELSE BEGIN
              SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))
            END
            INSERT_BYTES base (0x30 + (0xd8 * fx_type))
            WRITE_ASCIIE base "%clone%"

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= "-10")    BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= "-10")    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END
            LPF dw_internal_set_bit END
            LPF dw_internal_apply_function END
            // update the tracking vars
            SET new_fx += 1
            SET counter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
              PATCH_IF ("%insert%" STRING_COMPARE_CASE "last" = 0) BEGIN
                SET last += 1
              END ELSE BEGIN
                SET index2 += 1
              END
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx > 0)) BEGIN // fix offsets for cre files if fx inserted
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (new_fx = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects added to %SOURCE_FILE%"
  END ELSE PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) added"
  END

END

DEFINE_PATCH_FUNCTION DELETE_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching
  
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
  
  // DavidW's additional functional variable

          match_function      = ""

BEGIN
  
  LPM dw_internal_initialise_bit
  
  // set variables and offsets based on the file type
  SET new_fx = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      READ_LONG   0x64 abil_off ELSE 0
      READ_SHORT  0x68 abil_num ELSE 0
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: DELETE_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: DELETE_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        PATCH_IF "%sig%" STR_EQ "SPL " BEGIN
			READ_SHORT  (abil_off +  0x10 + (abil_length * index)) level
		END ELSE BEGIN
			level=1
		END
        SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        WRITE_SHORT (abil_off + 0x20 + (abil_length * index)) (THIS + new_fx) // update index with previously added effects
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0)) AND                                  // and only on the right # header, if specified
                ((index < 0) OR (check_headers))) BEGIN                                 // if check headers = 0, only re-index
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // now that we've got a match, read-and-clone it:
            DELETE_BYTES   (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) (0x30 + (0xd8 * fx_type))

            // update the tracking vars
            SET new_fx -= 1
            SET counter -= 1
            SET index2 -= 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
      WRITE_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
    END // end loop through effects on ability
  END // end ability loop

  // now adjust offsets for creature files
  PATCH_IF (("%sig%" STRING_EQUAL "CRE ") AND (new_fx != 0)) BEGIN // fix offsets for cre files if #fx changed
    SET inserted = ((0x30 + (0xd8 * fx_type)) * new_fx)
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
      PATCH_FOR_EACH offset IN 0x294 0x344 0x34c 0x354 0x35c 0x360 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
      PATCH_FOR_EACH offset IN 0x5fa 0x602 0x60a 0x612 0x616 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x3ba ; offset < 0x4b3 ; offset = offset + 0x04) BEGIN // all of the spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
      FOR (offset = 0x5b2 ; offset < 0x5d3 ; offset = offset + 0x04) BEGIN // domain spell offsets
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE
    PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
      PATCH_FOR_EACH offset IN 0x308 0x310 0x318 0x320 0x324 BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END ELSE BEGIN                                               // everything else, cre v1.0
      PATCH_FOR_EACH offset IN 0x2a0 0x2a8 0x2b0 0x2b8 0x2bc BEGIN
        READ_LONG offset off
        PATCH_IF (fx_off < off) BEGIN
          WRITE_LONG offset (off + inserted)
        END
      END
    END
  END

  PATCH_IF (verbose) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %new_fx% effect(s) deleted"
  END

END

DEFINE_PATCH_FUNCTION ALTER_EFFECT

  // defines what we're going to check
  INT_VAR check_globals       = 1
          check_headers       = 1
          header              = "-1"
          header_type         = "-1"
          multi_match         = 999
          verbose             = 0
          silent              = 0

  // variables for finding the effect to match
          match_opcode        = "-1"
          match_target        = "-1"
          match_power         = "-1"
          match_parameter1    = "-1"
          match_parameter2    = "-1"
          match_timing        = "-1"
          match_resist_dispel = "-1"
          match_duration      = "-1"
          match_duration_high = "-1"
          match_probability1  = "-1"
          match_probability2  = "-1"
          match_dicenumber    = "-1"
          match_dicesize      = "-1"
          match_savingthrow   = "-1"
          match_savebonus     = "-11"
          match_special       = "-1"
          
  // DavidW's additional variables for matching
  
          match_save_vs_spell       = "-1"
          match_save_vs_breath      = "-1"
          match_save_vs_poison      = "-1"
          match_save_vs_wand        = "-1"
          match_save_vs_polymorph   = "-1"
          match_ignore_primary      = "-1"
          match_ignore_secondary    = "-1"
          match_bypass_mirror_image = "-1"
          match_ignore_difficulty   = "-1"
          match_drain_hp_to_caster  = "-1"
          match_transfer_hp_to_target = "-1"
          match_fist_damage_only    = "-1"
          match_drain_to_max_hp     = "-1"
          match_suppress_feedback   = "-1"
          match_save_for_half       = "-1"
          match_made_save           = "-1"
          match_does_not_wake       = "-1"

  // variables for the new effect
          opcode              = "-1"
          target              = "-1"
          power               = "-1"
          parameter1          = "-11"
          parameter2          = "-11"
          timing              = "-1"
          resist_dispel       = "-1"
          duration            = "-1"
          duration_high       = "-1"
          probability1        = "-1"
          probability2        = "-1"
          dicenumber          = "-1"
          dicesize            = "-1"
          savingthrow         = "-1"
          savebonus           = "-11"
          special             = "-1"
          
  // DavidW's additional variables for the new effect
  
          save_vs_spell       = "-1"
          save_vs_breath      = "-1"
          save_vs_poison      = "-1"
          save_vs_wand        = "-1"
          save_vs_polymorph   = "-1"
          ignore_primary      = "-1"
          ignore_secondary    = "-1"
          bypass_mirror_image = "-1"
          ignore_difficulty   = "-1"
          drain_hp_to_caster  = "-1"
          transfer_hp_to_target = "-1"
          fist_damage_only    = "-1"
          drain_to_max_hp     = "-1"
          suppress_feedback   = "-1"
          save_for_half       = "-1"
          made_save           = "-1"
          does_not_wake       = "-1"

  // same for match and new STR_VAR
  STR_VAR match_resource      = "SAME"
          resource            = "SAME"
          
  // DavidW's additional functional variables

          match_function      = ""
          function            = ""

BEGIN  
  LPM dw_internal_initialise_bit
  // set variables and offsets based on the file type
  SET alter = 0
  READ_ASCII 0 sig ELSE "fail" (4)
  READ_ASCII 0x04 version (4)
  PATCH_MATCH "%sig%" WITH
    "SPL "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.0" = 0) BEGIN // iwd2, spl 2.0
        SET min_size       = 0x82
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x28
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "ITM "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.1" = 0) BEGIN // pst, itm v1.1
        SET min_size       = 0x9a
      END ELSE BEGIN
        SET min_size       = 0x72
      END
      READ_LONG   0x6a fx_off   ELSE 0
      SET counter_offset = 0x70
      SET abil_length    = 0x38
      SET fx_type        = 0
      PATCH_IF (check_headers = 0) BEGIN
        SET abil_num = 0
      END ELSE BEGIN
        READ_LONG   0x64 abil_off ELSE 0
        READ_SHORT  0x68 abil_num ELSE 0
      END
    END

    "CRE "
    BEGIN
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V1.2" = 0) BEGIN // pst, cre v1.2
        SET min_size       = 0x378
        READ_LONG  0x368 fx_off ELSE 0
        SET counter_offset = 0x36c
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V2.2" = 0) BEGIN // iwd2, cre v2.2
        SET min_size       = 0x62e
        READ_LONG  0x61e fx_off ELSE 0
        SET counter_offset = 0x622
      END ELSE
      PATCH_IF ("%version%" STRING_COMPARE_CASE "V9.0" = 0) BEGIN // iwd, cre v9.0
        SET min_size       = 0x33c
        READ_LONG  0x32c fx_off ELSE 0
        SET counter_offset = 0x330
      END ELSE BEGIN                                               // everything else, cre v1.0
        SET min_size = 0x2d4
        READ_LONG  0x2c4 fx_off ELSE 0
        SET counter_offset = 0x2c8
      END
      SET abil_off = 0 // basically prevents the ability effect loop
      SET abil_num = 0
      SET abil_length = 0
      SET check_globals = 1
      READ_BYTE 0x33 fx_type ELSE 2
    END

    "fail"
    BEGIN
      PATCH_WARN "WARNING: ALTER_EFFECT does not think %SOURCE_FILE% appears to be a valid file"
    END

    DEFAULT
      SET min_size = "-1" // kill macro as the file type is not recognized
      PATCH_WARN "WARNING: ALTER_EFFECT does not support file type %sig%"
  END

  PATCH_IF (BUFFER_LENGTH >= min_size) BEGIN // sanity check
    FOR (index = (0 - check_globals) ; index < abil_num ; ++index) BEGIN // we start at -1 for global effects
      PATCH_IF (index < 0) BEGIN // if loop through globals needed
        SET abil_fx_idx = 0  // start with effect 0 since we're in the global loop
        SET abil_type = "-1" // basically, ignore header type checks for global loop
      END ELSE BEGIN // otherwise normal ability
        READ_SHORT  (abil_off +        (abil_length * index)) abil_type
        PATCH_IF "%sig%" STR_EQ "SPL " BEGIN
			READ_SHORT  (abil_off +  0x10 + (abil_length * index)) level
		END ELSE BEGIN
			level=1
		END
		SET counter_offset = (abil_off + 0x1e + (abil_length * index))
        READ_SHORT  (abil_off + 0x20 + (abil_length * index)) abil_fx_idx
      END
      READ_SHORT counter_offset counter // fx_num on global loop, otherwise abil_fx_num
      PATCH_IF (((abil_type = header_type) OR (abil_type < 0) OR (header_type < 0)) AND // only look on the right header types, if specified...
                ((header = index) OR (header < 0))) BEGIN                               // and only on the right # header, if specified
        SET local_multi = multi_match
        FOR (index2 = 0 ; index2 < counter ; ++index2) BEGIN

          // read the variables from the current effect
          READ_SHORT (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_opcode
          READ_BYTE  (fx_off + 0x02 + (0x0a * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_target
          READ_BYTE  (fx_off + 0x03 + (0x0d * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_power
          READ_LONG  (fx_off + 0x04 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter1
          READ_LONG  (fx_off + 0x08 + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_parameter2
          READ_BYTE  (fx_off + 0x0c + (0x10 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_timing
          READ_BYTE  (fx_off + 0x0d + (0x47 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resist_dispel
          READ_LONG  (fx_off + 0x0e + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_duration
          READ_BYTE  (fx_off + 0x12 + (0x12 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability1
          READ_BYTE  (fx_off + 0x13 + (0x13 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_probability2
          READ_ASCII (fx_off + 0x14 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_resource
          READ_LONG  (fx_off + 0x1c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicenumber
          READ_LONG  (fx_off + 0x20 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_dicesize
          READ_LONG  (fx_off + 0x24 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savingthrow
          READ_LONG  (fx_off + 0x28 + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_savebonus
          READ_LONG  (fx_off + 0x2c + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_special

          LPF dw_internal_check_bit RET bit_test_passed END
          LPF dw_internal_evaluate_function RET function_test_passed END

          // match ALL these variables, if specified
          PATCH_IF ( bit_test_passed                                                       AND
                     function_test_passed                                                  AND
                    ((match_opcode        = o_opcode)        OR (match_opcode < 0))        AND
                    ((match_target        = o_target)        OR (match_target < 0))        AND
                    ((match_power         = o_power)         OR (match_power < 0))         AND
                    ((match_parameter1    = o_parameter1)    OR (match_parameter1 < 0))    AND
                    ((match_parameter2    = o_parameter2)    OR (match_parameter2 < 0))    AND
                    ((match_timing        = o_timing)        OR (match_timing < 0))        AND
                    ((match_resist_dispel = o_resist_dispel) OR (match_resist_dispel < 0)) AND
                    ((match_duration      = o_duration)      OR (match_duration < 0))      AND
                    ((match_probability1  = o_probability1)  OR (match_probability1 < 0))  AND
                    ((match_probability2  = o_probability2)  OR (match_probability2 < 0))  AND
                    ((match_dicenumber    = o_dicenumber)    OR (match_dicenumber < 0))    AND
                    ((match_dicesize      = o_dicesize)      OR (match_dicesize < 0))      AND
                    ((match_savingthrow   = o_savingthrow)   OR (match_savingthrow < 0))   AND
                    ((match_savebonus     = o_savebonus)     OR (match_savebonus < "-10")) AND
                    ((match_special       = o_special)       OR (match_special < 0))       AND
                    (("%match_resource%" STRING_COMPARE_CASE "%o_resource%" = 0) OR ("%match_resource%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN

            // lazily re-use code
            SET base = (fx_off        + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))

            // overwrite the cloned effect with the new variables, if specified
            PATCH_IF (opcode >= 0)        BEGIN WRITE_SHORT (base        + (0x08 * fx_type)) opcode        END
            PATCH_IF (target >= 0)        BEGIN WRITE_BYTE  (base + 0x02 + (0x0a * fx_type)) target        END
            PATCH_IF (power >= 0)         BEGIN WRITE_BYTE  (base + 0x03 + (0x0d * fx_type)) power         END
            PATCH_IF (parameter1 >= "-10") BEGIN WRITE_LONG  (base + 0x04 + (0x10 * fx_type)) parameter1    END
            PATCH_IF (parameter2 >= "-10")    BEGIN WRITE_LONG  (base + 0x08 + (0x10 * fx_type)) parameter2    END
            PATCH_IF (timing >= 0)        BEGIN WRITE_BYTE  (base + 0x0c + (0x10 * fx_type)) timing        END
            PATCH_IF (resist_dispel >= 0) BEGIN WRITE_BYTE  (base + 0x0d + (0x47 * fx_type)) resist_dispel END
            PATCH_IF (duration >= 0)      BEGIN WRITE_LONG  (base + 0x0e + (0x12 * fx_type)) duration      END
            PATCH_IF (probability1 >= 0)  BEGIN WRITE_BYTE  (base + 0x12 + (0x12 * fx_type)) probability1  END
            PATCH_IF (probability2 >= 0)  BEGIN WRITE_BYTE  (base + 0x13 + (0x13 * fx_type)) probability2  END
            PATCH_IF (dicenumber >= 0)    BEGIN WRITE_LONG  (base + 0x1c + (0x14 * fx_type)) dicenumber    END
            PATCH_IF (dicesize >= 0)      BEGIN WRITE_LONG  (base + 0x20 + (0x14 * fx_type)) dicesize      END
            PATCH_IF (savingthrow >= 0)   BEGIN WRITE_LONG  (base + 0x24 + (0x14 * fx_type)) savingthrow   END
            PATCH_IF (savebonus >= "-10") BEGIN WRITE_LONG  (base + 0x28 + (0x14 * fx_type)) savebonus     END
            PATCH_IF (special >= 0)       BEGIN WRITE_LONG  (base + 0x2c + (0x14 * fx_type)) special       END
            PATCH_IF ("%resource%" STRING_COMPARE_CASE "SAME" != 0) BEGIN
              WRITE_ASCIIE (base + 0x14 + (0x14 * fx_type)) "%resource%" #8
            END
            LPF dw_internal_set_bit END
            LPF dw_internal_apply_function END
            // update the tracking vars
            SET alter += 1
            PATCH_IF (local_multi < 2) BEGIN  // kill loop if we only want one match
              SET index2 = counter
            END ELSE BEGIN // otherwise bump vars and keep going
              SET local_multi  -= 1
            END

          END // end patch_if for a matched effect
        END // end of the for loop through effects
      END // end patch_if for matched/specified headers
    END // end loop through effects on ability
  END // end ability loop

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE%"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END

DEFINE_PATCH_MACRO dw_internal_initialise_bit//internal 
BEGIN
   //  DavidW: once and for all set the variables used by bit checks
  CLEAR_ARRAY bit_array_binary
  DEFINE_ASSOCIATIVE_ARRAY bit_array_binary BEGIN
             save_vs_spell         =>   0b11111110
             save_vs_breath        =>   0b11111101
             save_vs_poison        =>   0b11111011
             save_vs_wand          =>   0b11110111
             save_vs_polymorph     =>   0b11101111
             ignore_primary        =>   0b11111011
             ignore_secondary      =>   0b11110111
             bypass_mirror_image   =>   0b11111110
             ignore_difficulty     =>   0b11111101
             drain_hp_to_caster    =>   0b11111110
             transfer_hp_to_target =>   0b11111101
             fist_damage_only      =>   0b11111011
             drain_to_max_hp       =>   0b11110111
             suppress_feedback     =>   0b11011111
             save_for_half         =>   0b11111110
             made_save             =>   0b11111101
             does_not_wake         =>   0b11111011

  END
  CLEAR_ARRAY bit_array
  DEFINE_ASSOCIATIVE_ARRAY bit_array BEGIN
            save_vs_spell            =>   0x24
            save_vs_breath           =>   0x24
            save_vs_poison           =>   0x24
            save_vs_wand             =>   0x24
            save_vs_polymorph        =>   0x24
            ignore_primary           =>   0x25
            ignore_secondary         =>   0x25
            ignore_difficulty        =>   0x27
            bypass_mirror_image      =>   0x27
            drain_hp_to_caster       =>   0x2c   
            transfer_hp_to_target    =>   0x2c
            fist_damage_only         =>   0x2c
            drain_to_max_hp          =>   0x2c
            suppress_feedback        =>   0x2c
            save_for_half            =>   0x2d
            made_save                =>   0x2d
            does_not_wake            =>   0x2d

  END
  // DavidW:  define anonymous functions if we're using them
  PATCH_IF INDEX ("[ <>=\+/*{}]" "%match_function%")>=0 BEGIN
		LPF anon_define INT_VAR has_output=1 STR_VAR function="%match_function%" RET match_function=function SFO_anon_func_count END
  END
  PATCH_IF INDEX ("[ <>=\+/*{}]" "%function%")>=0 BEGIN
		LPF anon_define INT_VAR has_output=0 STR_VAR function RET function SFO_anon_func_count END
  END
END

DEFINE_PATCH_FUNCTION dw_internal_check_bit//internal
    RET bit_test_passed
BEGIN
      SET bit_test_passed=1
      PHP_EACH bit_array AS bit_var=>bit_loc BEGIN
             SET bit_val=EVAL "match_%bit_var%"
             PATCH_IF (bit_val>=0 && bit_test_passed=1) BEGIN // if we've already failed, don't bother
                  SET bit_binary = $bit_array_binary("%bit_var%")
                  READ_BYTE  (fx_off + bit_loc + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) o_bit_value
                  PATCH_IF bit_val=0 BEGIN
                     PATCH_IF ! ( ((BNOT bit_binary) BAND o_bit_value) = 0b00000000) BEGIN
                        SET bit_test_passed=0
                     END
                  END ELSE BEGIN
                     PATCH_IF ! ( (bit_binary BOR o_bit_value) = 0b11111111) BEGIN
                        SET bit_test_passed=0
                     END
                  END
             END
      END
END

DEFINE_PATCH_FUNCTION dw_internal_set_bit//internal
BEGIN
            PHP_EACH bit_array AS bit_var=>bit_loc BEGIN
             SET bit_val=EVAL "%bit_var%"
             PATCH_IF bit_val>=0 BEGIN
                SET bit_binary =$bit_array_binary("%bit_var%")
                  READ_BYTE  (fx_off + bit_loc + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) bit_value
                PATCH_IF bit_val=0 BEGIN
                    SET bit_value = (bit_value BAND bit_binary )
                END ELSE BEGIN
                    SET bit_value = (bit_value BOR (BNOT bit_binary) )
                END
                WRITE_BYTE (fx_off + bit_loc + (0x14 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type))))  bit_value
             END
            END
END

DEFINE_PATCH_FUNCTION dw_internal_evaluate_function//internal
           RET function_test_passed
BEGIN
  // initialise
  SET function_test_passed=1

  // is there a function?
  PATCH_IF "%match_function%" STRING_COMPARE "" BEGIN

   // get the function and arguments
   SPRINT arguments ""
   INNER_PATCH_SAVE match_function "%match_function%" BEGIN
      REPLACE_EVALUATE "\(.*\)(\([^)]*\))$" BEGIN
         SPRINT arguments "%MATCH2%"
      END
      "%MATCH1%"
   END
   // get the data
   READ_ASCII (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) dw_data (0x30)
   // apply the function
   INNER_PATCH "%dw_data%" BEGIN
	PATCH_IF "%arguments%" STR_EQ "" BEGIN
      LPF "%match_function%" RET function_test_passed=value END	
	END ELSE BEGIN
      LPF "%match_function%" STR_VAR arguments RET function_test_passed=value END
	END
   END

  END
END

DEFINE_PATCH_FUNCTION dw_internal_apply_function//internal
BEGIN

  // is there a function?
  PATCH_IF "%function%" STRING_COMPARE "" BEGIN

   // get the function and arguments
   SPRINT arguments ""
   INNER_PATCH_SAVE function "%function%" BEGIN
      REPLACE_EVALUATE "\(.*\)(\([^)]*\))$" BEGIN
         SPRINT arguments "%MATCH2%"
      END
      "%MATCH1%"
   END
   // get the data
   READ_ASCII (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) dw_data (0x30)
   // apply the function
   INNER_PATCH_SAVE dw_data "%dw_data%" BEGIN
	PATCH_IF "%arguments%" STR_EQ "" BEGIN
     LPF "%function%" END	
	END ELSE BEGIN
      LPF "%function%" STR_VAR arguments END
	END
   END
   // write the data
   WRITE_ASCIIE (fx_off        + (0x08 * fx_type) + ((abil_fx_idx + index2) * (0x30 + (0xd8 * fx_type)))) "%dw_data%" (0x30)

  END
END
/* 
describe-library{
A collection of functions to edit blocks of a BCS file. Common structure: we go through the in-game BCS 'script'.bcs block by block. We specify up to 5 regexps (match and match1-match5), and check each against the decompiled block. On a match, we then do something (what, depends on the function). If the Boolean 'only_once' is set, we stop after the first match. If 'recompile' is set to 0, we don't recompile the script afterwards (this is mostly for debugging).</p>

<p>Alternately or additionally, a patch function 'match_function' can be specified, which should return one Boolean, 'value'. match_function is run on each decompiled block, and that block is only matched if the function returns 1. You can use the anonymous-function construct.</p>

<p>This library formally depends on other libraries through the anonymous-function construct and through using SFO path/location/locbase syntax. However, if you eschew both, the library works as a self-contained library. (It should be kept that way.)
}
*/


/*
document{insert_script_block}
{
'insert' should be either a complete path to a BAF file, or the filename of a BAF file with location given in sfo fashion by 'location'/'locbase'/'path'. That file is inserted after (or, if insert_above=1, before) any matched block.
}
*/

DEFINE_ACTION_FUNCTION insert_script_block
INT_VAR insert_above=0//boolean
        only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        insert=""
		location=""
		locbase=""
		path=""
BEGIN
	LAF INSERT_SCRIPT_BLOCK
		INT_VAR insert_above
				only_once
				recompile
		STR_VAR script
				match_function
				match
				match1
				match2
				match3
				match4
				match5
				insert
				location
				locbase
				path	
	END
END
DEFINE_ACTION_FUNCTION INSERT_SCRIPT_BLOCK//internal
INT_VAR insert_above=0//boolean
        only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        insert=""
		location=""
		locbase=""
		path=""
BEGIN
	ACTION_IF "%location%%locbase%%path%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR file="%insert%" location locbase path RET insert=file_path END
	END
   // sanity check
   COPY - "%insert%" override EVALUATE_BUFFER
       READ_ASCII 0x0 internal_insert_data (BUFFER_LENGTH)
       PATCH_TRY COMPILE_BAF_TO_BCS WITH DEFAULT
          PATCH_PRINT ~"%insert%" is not a legal BAF file, INSERT_SCRIPT_BLOCK will fail~
          PATCH_RERAISE
       END
   BUT_ONLY
   OUTER_SPRINT internal_insert_data "%internal_insert_data%"^"%WNL%"
   LAF internal_script_block_master 
     INT_VAR only_once insert_above replace=0 recompile
     STR_VAR internal_insert_data script match_function
           match match1 match2 match3 match4 match5
           type=insert 
   END
END

/*
document{replace_script_block}
{
'insert' should be either a complete path to a BAF file, or the filename of a BAF file with location given in sfo fashion by 'location'/'locbase'/'path'. That file is substituted in to replace any matched block.
}
*/

DEFINE_ACTION_FUNCTION replace_script_block
INT_VAR only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        insert=""
		location=""
		locbase=""
		path=""
BEGIN
	LAF REPLACE_SCRIPT_BLOCK
		INT_VAR only_once
				recompile
		STR_VAR script
				match_function
				match
				match1
				match2
				match3
				match4
				match5
				insert
				location
				locbase
				path
	END	

END

DEFINE_ACTION_FUNCTION REPLACE_SCRIPT_BLOCK//internal
INT_VAR only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        insert=""
		location=""
		locbase=""
		path=""
BEGIN
	ACTION_IF "%location%%locbase%%path%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR file="%insert%" location locbase path RET insert=file_path END
	END
   // sanity check
   COPY - "%insert%" override EVALUATE_BUFFER
       READ_ASCII 0x0 internal_insert_data (BUFFER_LENGTH)
       PATCH_TRY COMPILE_BAF_TO_BCS WITH DEFAULT
          PATCH_PRINT ~"%insert%" is not a legal BAF file, INSERT_SCRIPT_BLOCK will fail~
          PATCH_RERAISE
       END
   BUT_ONLY
   OUTER_SPRINT internal_insert_data "%internal_insert_data%"^"%WNL%"
   LAF internal_script_block_master 
     INT_VAR only_once replace=1 recompile
     STR_VAR internal_insert_data script match_function
           match match1 match2 match3 match4 match5
           type=insert 
   END
END

/*
document{delete_script_block}
{
Any matched block is deleted.
}
*/

DEFINE_ACTION_FUNCTION delete_script_block//internal
INT_VAR only_once=0//boolean
		recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
BEGIN
   LAF internal_script_block_master INT_VAR only_once recompile STR_VAR script match_function match match1 match2 match3 match4 match5 type=delete END
END

DEFINE_ACTION_FUNCTION DELETE_SCRIPT_BLOCK//ointernal
INT_VAR only_once=0//boolean
		recompile=1//boolean
STR_VAR script=""
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
BEGIN
   LAF internal_script_block_master INT_VAR only_once recompile STR_VAR script match_function match match1 match2 match3 match4 match5 type=delete END
END

/*
document{clone_script_block}
{
Any matched block is copied directly below (or, if insert_above=1, directly above) the matched block. Up to 6 regexps ('swap_out', and 'swap_out1'-'swap_out5') are specified. Each is matched against the (decompiled) copied block via REPLACE_TEXTUALLY, and on a match, is swapped for (respectively) 'swap_in' or 'swap_in1'-'swap_in5'. The same happens to the original block, using 'original_swap_out'/'original_swap_out[1-5]' and 'original_swap_in'/'original_swap_in[1-5]'.
}
*/

DEFINE_ACTION_FUNCTION clone_script_block
INT_VAR insert_above=0//boolean
        only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        patch=""//function
		function=""//function
        patch_original=""//function
		function_original=""//function
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        swap_out=""
        swap_out1=""
        swap_out2=""
        swap_out3=""
        swap_out4=""
        swap_out5=""
        swap_in=""
        swap_in1=""
        swap_in2=""
        swap_in3=""
        swap_in4=""
        swap_in5=""
        original_swap_out=""
        original_swap_out1=""
        original_swap_out2=""
        original_swap_out3=""
        original_swap_out4=""
        original_swap_out5=""
        original_swap_in=""
        original_swap_in1=""
        original_swap_in2=""
        original_swap_in3=""
        original_swap_in4=""
        original_swap_in5=""
BEGIN
   LAF internal_script_block_master
     INT_VAR only_once insert_above
     STR_VAR script match_function patch="%patch%%function%" patch_original="%patch_original%%function_original%"
           match match1 match2 match3 match4 match5 
           swap_out swap_out1 swap_out2 swap_out3 swap_out4 swap_out5
           swap_in swap_in1 swap_in2 swap_in3 swap_in4 swap_in5
           original_swap_out original_swap_out1 original_swap_out2 original_swap_out3 original_swap_out4 original_swap_out5
           original_swap_in original_swap_in1 original_swap_in2 original_swap_in3 original_swap_in4 original_swap_in5
           type=clone
   END
END

DEFINE_ACTION_FUNCTION CLONE_SCRIPT_BLOCK
INT_VAR insert_above=0//boolean
        only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        patch=""//function
		function=""//function
        patch_original=""//function
		function_original=""//function
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        swap_out=""
        swap_out1=""
        swap_out2=""
        swap_out3=""
        swap_out4=""
        swap_out5=""
        swap_in=""
        swap_in1=""
        swap_in2=""
        swap_in3=""
        swap_in4=""
        swap_in5=""
        original_swap_out=""
        original_swap_out1=""
        original_swap_out2=""
        original_swap_out3=""
        original_swap_out4=""
        original_swap_out5=""
        original_swap_in=""
        original_swap_in1=""
        original_swap_in2=""
        original_swap_in3=""
        original_swap_in4=""
        original_swap_in5=""
BEGIN
   LAF internal_script_block_master
     INT_VAR only_once insert_above
     STR_VAR script match_function patch="%patch%%function%" patch_original="%patch_original%%function_original%"
           match match1 match2 match3 match4 match5 
           swap_out swap_out1 swap_out2 swap_out3 swap_out4 swap_out5
           swap_in swap_in1 swap_in2 swap_in3 swap_in4 swap_in5
           original_swap_out original_swap_out1 original_swap_out2 original_swap_out3 original_swap_out4 original_swap_out5
           original_swap_in original_swap_in1 original_swap_in2 original_swap_in3 original_swap_in4 original_swap_in5
           type=clone
   END
END

/*
document{alter_script_block}
{
Up to 6 regexps ('swap_out', and 'swap_out1'-'swap_out5') are specified. Each is matched against any matched block via REPLACE_TEXTUALLY, and on a match, is swapped for (respectively) 'swap_in' or 'swap_in1'-'swap_in5'. 
}
*/

DEFINE_ACTION_FUNCTION alter_script_block
INT_VAR only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        patch=""//function
		function=""//function
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        swap_out=""
        swap_out1=""
        swap_out2=""
        swap_out3=""
        swap_out4=""
        swap_out5=""
        swap_in=""
        swap_in1=""
        swap_in2=""
        swap_in3=""
        swap_in4=""
        swap_in5=""
BEGIN
   LAF internal_script_block_master
     INT_VAR only_once recompile
     STR_VAR script match_function patch="%patch%%function%"
           match match1 match2 match3 match4 match5 
           swap_out swap_out1 swap_out2 swap_out3 swap_out4 swap_out5
           swap_in swap_in1 swap_in2 swap_in3 swap_in4 swap_in5
           type=alter
   END
END

DEFINE_ACTION_FUNCTION ALTER_SCRIPT_BLOCK
INT_VAR only_once=0//boolean
        recompile=1//boolean
STR_VAR script=""
        patch=""//function
		function=""//function
        match_function=""//function
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        swap_out=""
        swap_out1=""
        swap_out2=""
        swap_out3=""
        swap_out4=""
        swap_out5=""
        swap_in=""
        swap_in1=""
        swap_in2=""
        swap_in3=""
        swap_in4=""
        swap_in5=""
BEGIN
   LAF internal_script_block_master
     INT_VAR only_once recompile
     STR_VAR script match_function patch="%patch%%function%"
           match match1 match2 match3 match4 match5 
           swap_out swap_out1 swap_out2 swap_out3 swap_out4 swap_out5
           swap_in swap_in1 swap_in2 swap_in3 swap_in4 swap_in5
           type=alter
   END
END

/*
document{internal_script_block_master}
{
This is actually the innards of the various functions in this library, all of which are hooks into it.
}
*/

DEFINE_ACTION_FUNCTION internal_script_block_master//internal
INT_VAR insert_above=0//boolean
        only_once=0//boolean
        recompile=1//boolean
        replace=0//boolean
STR_VAR script=""
        patch=""
        patch_original=""
        match_function=""
        match=""
        match1=""
        match2=""
        match3=""
        match4=""
        match5=""
        internal_insert_data=""
        swap_out=""
        swap_out1=""
        swap_out2=""
        swap_out3=""
        swap_out4=""
        swap_out5=""
        swap_in=""
        swap_in1=""
        swap_in2=""
        swap_in3=""
        swap_in4=""
        swap_in5=""
        original_swap_out=""
        original_swap_out1=""
        original_swap_out2=""
        original_swap_out3=""
        original_swap_out4=""
        original_swap_out5=""
        original_swap_in=""
        original_swap_in1=""
        original_swap_in2=""
        original_swap_in3=""
        original_swap_in4=""
        original_swap_in5=""
		type=""
BEGIN
COPY_EXISTING "%script%.bcs" "override"
     SET found_match=0
     SPRINT new_script ""
     SET start=INDEX_BUFFER("CR")
	 // anonymous function checks (manual so we don't rely on lib_anon)
	 PATCH_IF INDEX ("[ <>=\+/*{}]" "%match_function%")>=0 BEGIN
		LPF anon_define STR_VAR function="%match_function%" RET match_function=function SFO_anon_func_count END
	 END
	 PATCH_IF INDEX ("[ <>=\+/*{}]" "%patch%")>=0 BEGIN
		LPF anon_define STR_VAR function="%patch%" RET patch=function SFO_anon_func_count END
	 END
	 PATCH_IF INDEX ("[ <>=\+/*{}]" "%patch_original%")>=0 BEGIN
		LPF anon_define STR_VAR function="%patch_original%" RET patch_original=function SFO_anon_func_count END
	 END
     WHILE start>0 BEGIN
          SET end=INDEX_BUFFER ("RS%LNL%CR%LNL%")
          SET length=(end - start) + 6
          READ_ASCII start data (length)
          DELETE_BYTES start length
          INNER_PATCH_SAVE data "SC%LNL%%data%SC%LNL%" BEGIN
             DECOMPILE_BCS_TO_BAF
             SET proceed=0
             PATCH_IF (!found_match || !only_once) BEGIN
              PATCH_IF "%match_function%" STRING_COMPARE "" BEGIN
                READ_ASCII 0x0 data_temp (BUFFER_LENGTH)  // we do this to avoid side-effects
			   INNER_PATCH "%data_temp%" BEGIN
                    LPF "%match_function%" RET v_func=value END
                END
              END ELSE BEGIN
                SET v_func=1
              END
              PATCH_IF
             ( INDEX_BUFFER ("%match%")>=0     AND
               INDEX_BUFFER ("%match1%")>=0    AND
               INDEX_BUFFER ("%match2%")>=0    AND
               INDEX_BUFFER ("%match3%")>=0    AND
               INDEX_BUFFER ("%match4%")>=0    AND
               INDEX_BUFFER ("%match5%")>=0    AND
               v_func=1
              )
              BEGIN
                SET proceed=1
              END
             END
             PATCH_IF proceed BEGIN
                 SET found_match=1
                 PATCH_MATCH "%type%" WITH
                 alter BEGIN
                     PATCH_IF "%patch%" STRING_COMPARE "" BEGIN LPF "%patch%" END END
                     PATCH_IF "%swap_out%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out%" "%swap_in%" END
                     PATCH_IF "%swap_out1%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out1%" "%swap_in1%" END
                     PATCH_IF "%swap_out2%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out2%" "%swap_in2%" END
                     PATCH_IF "%swap_out3%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out3%" "%swap_in3%" END
                     PATCH_IF "%swap_out4%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out4%" "%swap_in4%" END
                     PATCH_IF "%swap_out5%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out5%" "%swap_in5%" END
                 END
                 clone BEGIN
                    READ_ASCII 0x0 data2 (BUFFER_LENGTH)
                    INNER_PATCH_SAVE data2 "%data2%" BEGIN
                       PATCH_IF "%patch%" STRING_COMPARE "" BEGIN LPF "%patch%" END END
                       PATCH_IF "%swap_out%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out%" "%swap_in%" END
                       PATCH_IF "%swap_out1%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out1%" "%swap_in1%" END
                       PATCH_IF "%swap_out2%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out2%" "%swap_in2%" END
                       PATCH_IF "%swap_out3%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out3%" "%swap_in3%" END
                       PATCH_IF "%swap_out4%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out4%" "%swap_in4%" END
                       PATCH_IF "%swap_out5%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%swap_out5%" "%swap_in5%" END
                    END
                    PATCH_IF "%patch_original%" STRING_COMPARE "" BEGIN LPF "%patch_original%" END END
                    PATCH_IF "%original_swap_out%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out%" "%original_swap_in%" END
                    PATCH_IF "%original_swap_out1%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out1%" "%original_swap_in1%" END
                    PATCH_IF "%original_swap_out2%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out2%" "%original_swap_in2%" END
                    PATCH_IF "%original_swap_out3%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out3%" "%original_swap_in3%" END
                    PATCH_IF "%original_swap_out4%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out4%" "%original_swap_in4%" END
                    PATCH_IF "%original_swap_out5%" STRING_COMPARE "" BEGIN REPLACE_TEXTUALLY "%original_swap_out5%" "%original_swap_in5%" END
                    PATCH_IF insert_above BEGIN
                       SET insert_point=0
                    END ELSE BEGIN
                       SET insert_point=BUFFER_LENGTH
                    END
                    INSERT_BYTES insert_point (STRING_LENGTH "%data2%")
                    WRITE_ASCIIE insert_point "%data2%"
                 END
                 delete BEGIN
                    DELETE_BYTES 0x0 BUFFER_LENGTH
                 END
                 insert BEGIN
                    PATCH_IF replace BEGIN
                       DELETE_BYTES 0x0 BUFFER_LENGTH
                    END
                    PATCH_IF insert_above BEGIN
                       SET insert_point=0
                    END ELSE BEGIN
                       SET insert_point=BUFFER_LENGTH
                    END
                    INSERT_BYTES insert_point (STRING_LENGTH "%internal_insert_data%")
                    WRITE_ASCIIE insert_point "%internal_insert_data%"
                 END
                 DEFAULT
                    PATCH_FAIL "internal error in ALTER_SCRIPT suite"
                 END
             END
          END
          SPRINT new_script "%new_script%%data%"
          SET start=INDEX_BUFFER("CR")
     END
     DELETE_BYTES 0x0 BUFFER_LENGTH
     INNER_PATCH_SAVE new_script "%new_script%" BEGIN
        PATCH_IF recompile BEGIN
			PATCH_TRY
				COMPILE_BAF_TO_BCS
		    WITH DEFAULT
				PATCH_PRINT "alter_script: failure to recompile. Copying script to alter_script_failure.baf in workspace"
				READ_ASCII 0x0 arguments (BUFFER_LENGTH)
				LPF new_file INT_VAR no_log=1 STR_VAR arguments file=alter_script_error.baf path="%workspace%" END
				PATCH_RERAISE
		    END
        END
        SET new_length=BUFFER_LENGTH
     END
     INSERT_BYTES 0x0 new_length
     WRITE_ASCIIE 0x0 "%new_script%"
BUT_ONLY
END

//////////////////////////////////////////////////////////////////////////////////////
/*
describe-library
{
Files for manipulating 2d arrays via their (assumed uppercase) rows and columns. The
main use case is reading these 2d arrays out of .2da game files and extracting data from
them, and/or manipulating them and writing them back in. This is (hopefully) a much simpler
and more transparent way to manipulate 2das than by READ_2DA_ENTRY and friends.</p>

<p>Functions here should engage with the general 2da format and shouldn't refer to specific
features of particular game's 2das. They should start with "2da_".</p>

<p>This library can handle these file formats:
<ol>
<li>Standard, legally-formatted 2da files.</li>
<li>IDS files, which are read in with an added set of row headers which are integers labelled
from 0, and with columns 'int' and 'symbol'.</li>
<li>Tables with column headers, which are read in with an added set of row headers as for IDS files.</li>
</ol>
}
*/
//////////////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_read}
{
Read a 2da file (or, in patch context, the current 2da file) into a 2d array. Also return an array of uppercased row headers and
column headers, in the format row_label=>row_number. ('case' controls the case of the
row and column headers; it's uppercase by default on genuine 2das, mixed by default otherwise)

If you don't specify a path for the 2da file, it's assumed to be a game file.

In action context, if the file doesn't exist return 0; otherwise, return 1. Also
whine if it doesn't exist, unless silent=1.

If the file is a 2da, and 'reflect' is set, reverse rows and columns. If it's a 2da, and 'allow_incomplete_lines'
is set, don't require that all lines are complete. If it's a 2da, and "rowname_column" is set, use that column
(if it's present) for the row names instead of the usual entries. In the latter case, we add a new 'ROWNUMBER' column
containing column zero. (This is not compatible with 'reflect'.)

If 'rowmap' and/or 'colmap' are set, they get applied to the row and column entries before the array is constructed.
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION "2da_read"
	INT_VAR silent=0//boolean
			reflect=0//boolean
			allow_incomplete_lines=0//boolean
	STR_VAR type=""//[2da|ids|table_header|table_no_header]
			rowmap=""//function
			colmap=""//function
			rowname_column=""
			case=""//[upper|lower|mixed]
	RET_ARRAY columns rows array
BEGIN
	PATCH_IF "%rowname_column%" STR_CMP "" && reflect BEGIN
		PATCH_WARN "You are calling 2da_read with both reflect=1 and a nonempty rowname_column, which is not reliably supported"
	END
	LPF anon_check INT_VAR has_output=1 STR_VAR function="%rowmap%" RET rowmap=function END
	LPF anon_check INT_VAR has_output=1 STR_VAR function="%colmap%" RET colmap=function END
	// initialize
	CLEAR_ARRAY columns
	CLEAR_ARRAY rows
	CLEAR_ARRAY array
	// try to infer type
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_IF "%rowmap%" STR_CMP "" || "%colmap%" STR_CMP "" BEGIN
			SPRINT type "2da"
		END ELSE BEGIN
			READ_ASCII 0x0 sig (3)
			PATCH_MATCH "%sig%" WITH 
			"2da" "ids" BEGIN
				SPRINT type "%sig%"
			END
			DEFAULT
				PATCH_MATCH "%SOURCE_EXT%" WITH 
				"2da" "ids" BEGIN
					SPRINT type "%SOURCE_EXT%"
				END
				DEFAULT
					SPRINT type "table_header"
				END
			END
		END
	END
	// get column width & length
	COUNT_2DA_COLS colcount
	COUNT_2DA_ROWS colcount rowcount
	PATCH_MATCH "%type%" WITH
	"2da" BEGIN
		// get the default
		READ_2DA_ENTRY 1 0 1 default
		// check if it's empty
		COUNT_2DA_ROWS 1 empty_check
		is_empty=(empty_check=3)
		// get the col headers (& also the lookup column if appropriate)
		lookup_col_num=0
		COUNT_2DA_COLS colcount
		COUNT_2DA_ROWS colcount rowcount
		PATCH_MATCH "%colcount%" WITH
		2 BEGIN
			col_row=2
			main_row=1
		END
		3 BEGIN
			col_row=1
			main_row=0
		END
		DEFAULT
			col_row=0
			main_row=0
		END
		READ_2DA_ENTRIES_NOW 2da_coldata (colcount - 1)
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY_FORMER 2da_coldata col_row (col - 1) value
			PATCH_MATCH "%value%" WITH 
			"%rowname_column%" BEGIN
				lookup_col_num=col
			END
			DEFAULT
			END
			PATCH_MATCH "%case%" WITH
			lower BEGIN
				TO_LOWER value 
			END
			upper BEGIN
				TO_UPPER value
			END	
			mixed BEGIN
			END
			DEFAULT
				TO_UPPER value
			END
			PATCH_IF !reflect BEGIN
				SET $columns("%value%")=col
			END ELSE BEGIN
				SET $rows("%value%")=col			
			END
		END
		PATCH_IF is_empty BEGIN
			LPF array_map STR_VAR array=columns keymap="%colmap%" RET_ARRAY columns=array END
			SPRINT $rows("null") discard
			SPRINT $array("null") discard
		END ELSE BEGIN
			// get the rows
			READ_2DA_ENTRIES_NOW 2da_data colcount
			FOR (rownum=main_row;rownum<2da_data;++rownum) BEGIN
				READ_2DA_ENTRY_FORMER 2da_data rownum lookup_col_num value
				PATCH_MATCH "%case%" WITH
				lower BEGIN
					TO_LOWER value 
				END
				upper BEGIN
					TO_UPPER value
				END	
				mixed BEGIN
				END
				DEFAULT
					TO_UPPER value
				END		
				PATCH_IF !reflect BEGIN	
					SET $rows("%value%")=rownum
				END ELSE BEGIN
					SET $columns("%value%")=rownum
				END
			END
			// if we're using rowname_column, store the actual row labels
			// map rows and columns if needed
			LPF array_map STR_VAR array=columns keymap="%colmap%" RET_ARRAY columns=array END
			LPF array_map STR_VAR array=rows keymap="%rowmap%" RET_ARRAY rows=array END
			
			PATCH_IF allow_incomplete_lines BEGIN
				// get the data into a working array
				READ_ASCII 0x0 data (BUFFER_LENGTH)		
				LPF data_lines STR_VAR data RET_ARRAY lines END
				PHP_EACH lines AS ind=>line BEGIN
					PATCH_IF ind>=3 BEGIN

						// main read
						LPF array_values_from_string INT_VAR quick=1 STR_VAR string="%line%" RET_ARRAY temparray=array END
						LPF array_length STR_VAR array=temparray RET length END
						SPRINT row $temparray(0)
						row_int=ind - 3 +main_row
						PATCH_IF !reflect BEGIN
							SPRINT columns_or_rows columns
						END ELSE BEGIN
							SPRINT columns_or_rows rows
						END
						PHP_EACH "%columns_or_rows%" AS col=>int BEGIN
							PATCH_IF int<=length BEGIN
								SPRINT $working_array("%row_int%" "%int%") $temparray("%int%")
							END ELSE BEGIN
								SPRINT $working_array("%row_int%" "%int%") "%default%"
							END
						END
					END			
				END
				// get it into the final array
				PHP_EACH rows AS row=>row_int BEGIN
					// get rownumbers if we're using rowname_column
					PATCH_IF lookup_col_num>0 BEGIN
						READ_2DA_ENTRY_FORMER 2da_data row_int 0 rownumber
						SPRINT $array("%row%" "ROWNUMBER") "%rownumber%"	
					END	
					// main data				
					PHP_EACH columns AS col=>col_int BEGIN
						PATCH_IF !reflect BEGIN
							SPRINT $array("%row%" "%col%") $working_array("%row_int%" "%col_int%")
						END ELSE BEGIN
							SPRINT $array("%row%" "%col%") $working_array("%col_int%" "%row_int%")				
						END
					END		
				END
			END ELSE BEGIN
				PHP_EACH rows AS row=>row_int BEGIN
					// get rownumbers if we're using rowname_column
					PATCH_IF lookup_col_num>0 BEGIN
						READ_2DA_ENTRY_FORMER 2da_data row_int 0 rownumber
						PATCH_IF !reflect BEGIN
							SPRINT $array("%row%" "ROWNUMBER") "%rownumber%"
						END ELSE BEGIN
							SPRINT $array("ROWNUMBER" "%row%") "%rownumber%"				
						END
					END	
					// main data					
					PHP_EACH columns AS col=>col_int BEGIN		
						PATCH_IF !reflect BEGIN
							READ_2DA_ENTRY_FORMER 2da_data row_int col_int entry
						END ELSE BEGIN
							READ_2DA_ENTRY_FORMER 2da_data col_int row_int entry
						END
						SPRINT $array("%row%" "%col%") "%entry%"
					END
				END	
			END
		END
	END
	"ids" BEGIN
		READ_2DA_ENTRIES_NOW 2da_data 2
		// set cols
			SET $columns("int")=0
			SET $columns("sym")=1
		// get main data
		count=0
		FOR (row=0;row<2da_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER 2da_data row 0 int
			READ_2DA_ENTRY_FORMER 2da_data row 1 sym
			PATCH_IF IS_AN_INT int BEGIN
				SET $array("%count%" "int")=int
				SPRINT $array("%count%" "sym") "%sym%"
				++count
			END
		END
		// set rows
		FOR (row=0;row<count;++row) BEGIN
			SET $rows("%row%")=row
		END

	END	
	"table_header" BEGIN
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW 2da_data colcount
		// get columns
		FOR (col=0;col<colcount;++col) BEGIN
			READ_2DA_ENTRY_FORMER 2da_data 0 col value
			PATCH_MATCH "%case%" WITH
			lower BEGIN
				TO_LOWER value 
			END
			upper BEGIN
				TO_UPPER value
			END	
			DEFAULT
			END
			SET $columns("%value%")=col
		END
		// get data; set rows
		FOR (ind=1;ind<2da_data;++ind) BEGIN
			row=ind - 1
			SET $rows("%row%")=row
			PHP_EACH columns AS col=>colnum BEGIN
				READ_2DA_ENTRY_FORMER 2da_data ind colnum value
				SPRINT $array("%row%" "%col%") "%value%"
			END
		END
	END
	"table_noheader" BEGIN
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW 2da_data colcount
		// set columns
		FOR (col=0;col<colcount;++col) BEGIN
			SET $columns("%col%")=col
		END
		// get data; set rows
		FOR (ind=1;ind<2da_data;++ind) BEGIN
			row=ind - 1
			SET $rows("%row%")=row
			PHP_EACH columns AS col=>colnum BEGIN
				READ_2DA_ENTRY_FORMER 2da_data ind colnum value
				SPRINT $array("%row%" "%col%") "%value%"
			END
		END
	
	END
	DEFAULT
		PATCH_FAIL "2da_read: unidentified read type %type%"
	END

END

DEFINE_ACTION_FUNCTION "2da_read"
	INT_VAR silent=0//boolean
			inline=0//boolean
			reflect=0//boolean
			allow_incomplete_lines=0//boolean
	STR_VAR file="" 
			case=""//[upper|lower|mixed]
			path=""
			type=""
			location=""
			locbase=""
			rowmap=""//function
			colmap=""//function
			rowname_column=""
	RET value
	RET_ARRAY columns rows array
BEGIN
	ACTION_IF inline && INDEX ("[/\]" "%file%")<0 BEGIN
		OUTER_SPRINT file ".../stratagems-inline/%file%" 
	END
	LAF sfo_path STR_VAR file path location locbase RET file_path path END
	ACTION_IF "%path%" STR_EQ "" &&!inline BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME "%file%" BEGIN
			COPY_EXISTING - "%file%" nowhere
				LPF 2da_read INT_VAR silent reflect allow_incomplete_lines STR_VAR rowname_column case rowmap colmap type RET_ARRAY columns rows array END
			BUT_ONLY
			OUTER_SET value=1
		END ELSE BEGIN
			OUTER_SET value=0
			ACTION_IF !silent BEGIN
				WARN "2da_read: supposed game file %file% does not exist"
			END
		END
	END ELSE BEGIN
		ACTION_IF FILE_EXISTS "%file_path%" || inline BEGIN
			COPY - "%file_path%" nowhere
				LPF 2da_read INT_VAR silent reflect allow_incomplete_lines STR_VAR rowname_column case rowmap colmap type RET_ARRAY columns rows array END
			BUT_ONLY
			OUTER_SET value=1
		END ELSE BEGIN
			OUTER_SET value=0
			ACTION_IF !silent BEGIN
				WARN "2da_read: supposed file %file_path% does not exist"
			END		
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_write}
{
Write a 2d array into a 2da file (or, in patch context, the current 2da file). 

If you don't specify a path for the 2da file, it's assumed to be a game file.

If 'number_rows' is set to 1, the row names are replaced by integers, counting upwards from 0.
If 'reflect' is set to 1, rows and columns are swapped.
}
*/
//////////////////////////////////////////////////////////////////////////////////////
DEFINE_PATCH_FUNCTION 2da_write
	INT_VAR reflect=0//boolean
			number_rows=0//boolean
	STR_VAR array=""//array
			type=""//[2da|ids|table_header|table_noheader]
			default=""
BEGIN
	// get cols, rows
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// try to infer type
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_IF "%default%" STR_CMP "" BEGIN
			SPRINT type "2da"
		END ELSE BEGIN
			PATCH_IF BUFFER_LENGTH>=3 BEGIN
				READ_ASCII 0x0 sig
				PATCH_MATCH "%sig%" WITH
				"2da" "ids" BEGIN
					SPRINT type "%sig%"
				END	
				DEFAULT
				END
			END
		END
	END
	PATCH_IF "%type%" STR_EQ "" BEGIN
		PATCH_MATCH "%DEST_EXT%" WITH
		"2da" "ids" BEGIN
			SPRINT type "%DEST_EXT%"
		END 
		DEFAULT
		END
	END
	PATCH_IF "%type%" STR_EQ "" BEGIN
		found_first_col=0
		found_first_row=0
		found_second_col=0
		PHP_EACH rows AS row=>discard BEGIN
			PATCH_IF !found_first_row BEGIN
				SPRINT first_row "%row%"
				found_first_row=1
			END
		END
		PHP_EACH columns AS col=>discard BEGIN
			PATCH_IF !found_first_col BEGIN
				SPRINT first_col "%col%"
				found_first_col=1
			END ELSE
			PATCH_IF !found_second_col BEGIN
				SPRINT second_col "%col%"
				found_second_col=1
			END	
		END	
		PATCH_IF "%first_col%" STR_EQ int && "%second_col%" STR_EQ "sym" BEGIN
			SPRINT type ids
		END ELSE
		PATCH_IF IS_AN_INT "%first_col%" BEGIN
			SPRINT type table_noheader
		END ELSE
		PATCH_IF IS_AN_INT "%first_row%" BEGIN
			SPRINT type table_header
		END ELSE BEGIN
			SPRINT type 2da
		END
	END

	PATCH_MATCH "%type%" WITH
	"2da" BEGIN
		// initialise
		PATCH_IF "%default%" STR_EQ "" BEGIN
			SPRINT default "*"
		END
		SPRINT data "2DA V1.0%WNL%%default%%WNL%"
		// extract col data
		PATCH_IF !reflect BEGIN
			LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		END ELSE BEGIN
			LPF array_keys STR_VAR array RET_ARRAY rows=keys2 columns=keys1 END		
		END
		// write column headers
		PHP_EACH columns AS col=>discard BEGIN
			SPRINT data "%data%%col%%TAB%"
		END
		SPRINT data "%data%"
		// write rows
		rowcount=0
		PHP_EACH rows AS row=>discard BEGIN
			PATCH_IF !number_rows BEGIN
				SPRINT rowname "%row%"
			END ELSE BEGIN
				SPRINT rowname "%rowcount%"
			END
			SPRINT data "%data%%WNL%%rowname%%TAB%"
			++rowcount
			PHP_EACH columns AS col=>discard2 BEGIN
				PATCH_IF !reflect BEGIN
					SPRINT k1 "%row%"
					SPRINT k2 "%col%"
				END ELSE BEGIN
					SPRINT k1 "%col%"
					SPRINT k2 "%row%"
				END
				PATCH_IF VARIABLE_IS_SET $"%array%"("%k1%" "%k2%") BEGIN
					SPRINT val $"%array%"("%k1%" "%k2%")
				END ELSE BEGIN
					SPRINT val "%default%"
				END
				SPRINT data "%data%%val%%TAB%"
			END
		END
		// write to file and justify
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"
		COUNT_2DA_ROWS 0 rowcount
		PATCH_IF rowcount>2 BEGIN
			PRETTY_PRINT_2DA
			REPLACE_TEXTUALLY "^2DA[ %TAB%]+V1.0" "2DA V1.0"
		END
	END
	"ids" BEGIN
		SPRINT data "IDS V1.0%WNL%"// extract col data
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF "%k_1%" STR_EQ "sym" BEGIN
				SPRINT data "%data%%TAB%%v%%WNL%"
			END ELSE BEGIN
				SPRINT data "%data%%v%"
			END
		END
		// write to file
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"
	END
	"table_header" "table_noheader" BEGIN
		SPRINT data ""
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF "%type%" STR_EQ "table_header" BEGIN
			PHP_EACH columns AS col=>ind BEGIN
				SPRINT data "%data%%col%%TAB%"
			END
			SPRINT data "%data%%WNL%"
		END
		PHP_EACH rows AS row=>discard1 BEGIN
			PHP_EACH columns AS col=>discard2 BEGIN
				SPRINT val $"%array%"("%row%" "%col%")
				SPRINT data "%data%%val%%TAB%"
			END
			SPRINT data "%data%%WNL%"
		END
		// write to file
		DELETE_BYTES 0x0 BUFFER_LENGTH
		INSERT_BYTES 0x0 STRING_LENGTH "%data%"
		WRITE_ASCII 0x0 "%data%"	
	END
	DEFAULT
		PATCH_FAIL "2da_write: unknown type %type%"
	END

END

DEFINE_ACTION_FUNCTION "2da_write"
	INT_VAR number_rows=0//boolean
			reflect=0//boolean
	STR_VAR file="" path="" location="" locbase="" 
		type=""//[2da|ids|table_header|table_noheader]
		array=""//array
BEGIN
	LAF sfo_path STR_VAR path location locbase RET path END
	ACTION_IF "%path%" STR_EQ "" BEGIN
		COPY_EXISTING "%file%" override
			LPF 2da_write STR_VAR array type END
		BUT_ONLY
	END ELSE BEGIN
		COPY ".../stratagems-inline/blank" "%path%/%file%"
			LPF 2da_write STR_VAR array type END
		BUT_ONLY	
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_inject_array}
{
Given a 2d array, a column header of that array, and a k=>v array whose keys are row headers in the 2d array, 
inject the array elements into the 2d array, as (k=>v) goes to (k,col,v).

If force_uppercase=1 (default), array_in's keys are uppercased.
}
*/
/////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_inject_array 
	INT_VAR silent=0//boolean
			force_uppercase=1//boolean
	STR_VAR array=""//array
			array_in=""//array
			column=""
			row=""
	RET_ARRAY array
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	PATCH_IF "%row%" STR_CMP "" && "%column%" STR_CMP "" BEGIN
		PATCH_WARN "2da_inject_array: both 'row' and 'column' were specified. Using 'row'."
		SPRINT column ""
	END
	PATCH_IF "%column%" STR_CMP "" BEGIN
		TO_UPPER column
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF force_uppercase BEGIN
			LPF array_map STR_VAR array=array_in keymap=toupper RET_ARRAY array_in=array END
		END
		LPF array_contains STR_VAR array=columns key="%column%" RET value END
		PATCH_IF !value BEGIN
			PATCH_IF !silent BEGIN
				PATCH_WARN "2da_inject_array: column %column% is absent from 2d array %array%"
			END
		END ELSE BEGIN
			PHP_EACH rows AS this_row=>discard BEGIN
				PHP_EACH columns AS col=>discard BEGIN
					PATCH_IF VARIABLE_IS_SET $"%array_in%"("%this_row%") && "%col%" STR_EQ "%column%" BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array_in%"("%this_row%")
					END ELSE BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array%"("%this_row%" "%col%")
					END
				END 
			END
		END
	END ELSE
	PATCH_IF "%row%" STR_CMP "" BEGIN
		TO_UPPER row
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PATCH_IF force_uppercase BEGIN
			LPF array_map STR_VAR array=array_in keymap=toupper RET_ARRAY array_in=array END
		END
		LPF array_contains STR_VAR array=rows key="%row%" RET value END
		PATCH_IF !value BEGIN
			PATCH_IF !silent BEGIN
				PATCH_WARN "2da_inject_array: row %row% is absent from 2d array %array%"
			END
		END ELSE BEGIN
			PHP_EACH columns AS col=>discard BEGIN
				PHP_EACH rows AS this_row=>discard BEGIN
					PATCH_IF VARIABLE_IS_SET $"%array_in%"("%col%") && "%this_row%" STR_EQ "%row%" BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array_in%"("%col%")
					END ELSE BEGIN
						SPRINT $array("%this_row%" "%col%") $"%array%"("%this_row%" "%col%")
					END
				END 
			END
		END	
	END ELSE BEGIN
		PATCH_WARN "2da_inject_array: neither 'row' nor 'column' was specified"
	END
  END
END



//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_extract_array}
{Given a 2d array, and column labels 'domain' and 'range' for that array, return a 1d
array whose keys are the elements of the 'domain' column and whose values are the elements
of the 'range' column.

If you leave either 'domain' or 'range' empty, the row headers are used instead. If we can't
find domain or range, we return an empty array (and whine unless silent=1).

Optionally, you can specify functions 'keymap' and/or 'map', which are applied to the keys
and values respectively before being put into the output array. You can use the anonymous
function construct.
}
*/
/////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_extract_array
	INT_VAR silent=0//boolean
	STR_VAR domain=""
			range=""
			array=""//array
			keymap=""//function
			map=""//function
			case=""//[upper|lower|mixed]
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
		// anonymous function construct
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%map%" RET map=function END
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%keymap%" RET keymap=function END
		
		CLEAR_ARRAY lookup_array
		PATCH_IF ("%domain%" STR_EQ "%range%") && !silent BEGIN
			PATCH_WARN "warning: domain and range coincide in 2da_extract_array"
		END
		CLEAR_ARRAY rows
		CLEAR_ARRAY columns
		PATCH_MATCH "%case%" WITH
		lower BEGIN
			TO_LOWER domain
			TO_LOWER range
		END
		upper BEGIN
			TO_UPPER domain
			TO_UPPER range
		END	
		DEFAULT
		END
		LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		LPF array_contains STR_VAR array=columns key="%domain%" RET found_domain=value END
		LPF array_contains STR_VAR array=columns key="%range%" RET found_range=value END
		PATCH_IF "%domain%" STR_EQ "" && found_range BEGIN // we're using the column entries as lookup
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT v $"%array%"("%row%" "%range%")
				PATCH_IF !("%v%" STR_EQ "*") BEGIN
					PATCH_IF !"%map%" STR_EQ "" BEGIN
						LPF "%map%" STR_VAR arguments="%v%" RET v=value END
					END
					SPRINT $lookup_array("%row%") "%v%"
					found_range=1
				END			
			END	
		END ELSE 
		PATCH_IF "%range%" STR_EQ "" && found_domain BEGIN
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT k $"%array%"("%row%" "%domain%")
				PATCH_IF !("%k%" STR_EQ "*") BEGIN
					PATCH_IF !"%keymap%" STR_EQ "" BEGIN
						LPF "%keymap%" STR_VAR arguments="%k%" RET k=value END
					END
					SPRINT $lookup_array("%k%") "%row%"
					found_domain=1
				END			
			END	
		END ELSE
		PATCH_IF found_domain && found_range BEGIN
			SPRINT row_label ""
			SPRINT d "*"
			SPRINT r "*"
			PHP_EACH rows AS row=>discard BEGIN
				SPRINT d $"%array%"("%row%" "%domain%")
				SPRINT r $"%array%"("%row%" "%range%")
				PATCH_IF "%d%" STR_CMP "*" && "%r%" STR_CMP "*" BEGIN
					PATCH_IF !"%map%" STR_EQ "" BEGIN
							LPF "%map%" STR_VAR arguments="%r%" RET r=value END
					END
					PATCH_IF !"%keymap%" STR_EQ "" BEGIN
						LPF "%keymap%" STR_VAR arguments="%d%" RET d=value END
					END
					SPRINT $lookup_array("%d%") "%r%"
				END
			END		
		END ELSE BEGIN
			PATCH_IF !found_domain && !silent BEGIN
				PATCH_WARN "warning: domain %domain% in 2da_lookup apparently does not exist. Returning empty array."
			END
			PATCH_IF !found_range && !silent BEGIN
				PATCH_WARN "warning: range %range% in 2da_lookup apparently does not exist. Returning empty array."
			END
		END
		CLEAR_ARRAY array
		PHP_EACH lookup_array AS k=>v BEGIN
			SPRINT $array("%k%") "%v%"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_delete_column}
{Given a 2d array, and column label 'column', delete that column.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_delete_column
	STR_VAR array=""//array
			column=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_delete_column_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_delete_column (trying to delete column %column%)"
	END
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF !("%k_1%" STR_EQ "%column%") BEGIN
			SPRINT $SFO_2da_delete_column_working_array("%k_0%" "%k_1%") "%v%"
		END
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_delete_column_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END
			
//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_delete_row}
{Given a 2d array, and row label 'row', delete that row.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_delete_row
	STR_VAR array=""//array
			row=""
			lookup_column=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_delete_row_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_delete_row (trying to delete row %row%)"
	END
	CLEAR_ARRAY rows
	CLEAR_ARRAY columns
	PATCH_IF "%lookup_column%" STR_EQ "" BEGIN
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF !("%k_0%" STR_EQ "%row%") BEGIN
				SPRINT $SFO_2da_delete_row_working_array("%k_0%" "%k_1%") "%v%"
			END
		END
	END ELSE BEGIN	
		SPRINT row_header ""
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF !("%k_0%" STR_EQ "%row_header%") BEGIN // new row
				SPRINT row_header "%k_0%"
				delete_this_row="%row%" STR_EQ $"%array%"("%k_0%" "%lookup_column%")
			END
			PATCH_IF !delete_this_row BEGIN
				SPRINT $SFO_2da_delete_row_working_array("%k_0%" "%k_1%") "%v%"
			END
		END	
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_delete_row_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END
		
//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_renumber}
{
Given a 2d array, replace its row labels with sequential integers starting at 'start_at' (i.e. 0 by default)
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_renumber
	INT_VAR start_at=0
	STR_VAR array=""//array
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_renumber_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_renumber"
	END
	row=start_at - 1
	SPRINT row_header ""
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF !("%k_0%" STR_EQ "%row_header%") BEGIN // new row
			++row
			SPRINT row_header "%k_0%"
		END
		SPRINT $SFO_2da_renumber_working_array("%row%" "%k_1%") "%v%"
	END
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_renumber_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_insert_row}
{
Given a 2d array, and a row label, insert a new row with that row label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).

The new rows are filled with 'entry'.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_insert_row
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			row=""
			location=""
			entry="-1"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_insert_row"
	END
	// add it to the 'rows' array
	LPF array_keys STR_VAR array RET_ARRAY rows_in=keys1 columns=keys2 END
	CLEAR_ARRAY rows
	PATCH_MATCH "%location%" WITH
	last end BEGIN
		warn=0
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
		SPRINT $rows("%row%") ""
	END
	first start BEGIN
		warn=0
		SPRINT $rows("%row%") ""	
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
	END
	"before .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_row "%location%" BEGIN
			REPLACE_TEXTUALLY "before " ""
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			PATCH_IF "%k%" STR_EQ "%match_row%" BEGIN
				SPRINT $rows("%row%") ""
				warn=0
			END
			SPRINT $rows("%k%") ""
		END
	END
	"after .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_row "%location%" BEGIN
			REPLACE_TEXTUALLY "after " ""
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
			PATCH_IF "%k%" STR_EQ "%match_row%" BEGIN
				SPRINT $rows("%row%") ""
				warn=0
			END
		END
	END
	DEFAULT
		PATCH_WARN "'%location%' is not a legal location for 2da_insert_row. Legal locations are 'before ROW', 'after ROW', 'first' (or 'start'), and 'last' (or 'end')"
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
	END
	// put it at the end if you can't find a match
	PATCH_IF warn BEGIN
		PATCH_IF !silent BEGIN 
			PATCH_WARN "Failed to find row '%match_row%' in 2da_insert_row; putting it at the end instead"
		END
		PHP_EACH rows_in AS k=>discard BEGIN
			SPRINT $rows("%k%") ""
		END
		SPRINT $rows("%row%") ""
	END
	// write the main array
	PHP_EACH rows AS this_row=>discard BEGIN
		PHP_EACH columns AS this_col=>discard2 BEGIN
			PATCH_IF "%this_row%" STR_EQ "%row%" BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") "%entry%" 
			END ELSE BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") $"%array%"("%this_row%" "%this_col%")
			END		
		END	
	END
	// flush it into output
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
	
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_insert_column}
{
Given a 2d array, and a column label, insert a new column with that column label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).

The new rows are filled with 'entry'.
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_insert_column
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			column=""
			location=""
			entry="-1"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	CLEAR_ARRAY SFO_2da_working_array // we need a guaranteed unique array
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_insert_column"
	END
	// add it to the 'columns' array
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns_in=keys2 END
	CLEAR_ARRAY columns
	PATCH_MATCH "%location%" WITH
	last end BEGIN
		warn=0
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
		SPRINT $columns("%column%") ""
	END
	first start BEGIN
		warn=0
		SPRINT $columns("%column%") ""	
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
	END
	"before .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_col "%location%" BEGIN
			REPLACE_TEXTUALLY "before " ""
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			PATCH_IF "%k%" STR_EQ "%match_col%" BEGIN
				SPRINT $columns("%column%") ""
				warn=0
			END
			SPRINT $columns("%k%") ""
		END
	END
	"after .*" BEGIN
		warn=1
		INNER_PATCH_SAVE match_col "%location%" BEGIN
			REPLACE_TEXTUALLY "after " ""
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
			PATCH_IF "%k%" STR_EQ "%match_col%" BEGIN
				SPRINT $columns("%column%") ""
				warn=0
			END
		END
	END
	DEFAULT
		PATCH_WARN "'%location%' is not a legal location for 2da_insert_column. Legal locations are 'before COLUMN', 'after COLUMN', 'first' (or 'start'), and 'last' (or 'end')"
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
	END
	// put it at the end if you can't find a match
	PATCH_IF warn BEGIN
		PATCH_IF !silent BEGIN 
			PATCH_WARN "Failed to find column '%match_col%' in 2da_insert_column; putting it at the end instead"
		END
		PHP_EACH columns_in AS k=>discard BEGIN
			SPRINT $columns("%k%") ""
		END
		SPRINT $columns("%column%") ""
	END
	// write the main array
	PHP_EACH rows AS this_row=>discard BEGIN
		PHP_EACH columns AS this_col=>discard2 BEGIN
			PATCH_IF "%this_col%" STR_EQ "%column%" BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") "%entry%" 
			END ELSE BEGIN
				SPRINT $SFO_2da_working_array("%this_row%" "%this_col%") $"%array%"("%this_row%" "%this_col%")
			END		
		END	
	END
	// flush it into output
	CLEAR_ARRAY array
	PHP_EACH SFO_2da_working_array AS k=>v BEGIN
		SPRINT $array("%k_0%" "%k_1%") "%v%"
	END
	END
END		


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_clone_row}
{
Given a 2d array, a row label 'clone_from', and a new row label 'clone_to', insert a copy of the clone_from
row with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION 2da_clone_row
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			clone_to=""
			location=""
			clone_from=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_clone_row"
	END
	// create a blank row
	LPF 2da_insert_row INT_VAR silent STR_VAR array row="%clone_to%" location RET_ARRAY array END
	// get the columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// clone the data
	PATCH_IF !"%array%" STR_EQ "array" BEGIN 
		CLEAR_ARRAY array
		PHP_EACH "%array%" AS k=>v BEGIN
			SPRINT $array("%k_0%" "%k_1%") "%v%"
		END	
	END
	warn=1
	PHP_EACH columns AS col=>discard BEGIN
		PATCH_IF VARIABLE_IS_SET $"%array%"("%clone_from%" "%col%") BEGIN
			SPRINT $array("%clone_to%" "%col%") $"%array%"("%clone_from%" "%col%")
			warn=0
		END
	END
	PATCH_IF (warn && !silent) BEGIN
		PATCH_WARN "row %clone_from% does not exist, so can't be cloned; new row will be blank"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_clone_column}
{
Given a 2d array, a column label 'clone_from', and a new column label 'clone_to', insert a copy of the clone_from
column with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_clone_column
	INT_VAR silent=0//boolean
	STR_VAR array=""//array
			clone_to=""
			location=""
			clone_from=""
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
	PATCH_IF "%array%" STR_EQ "" BEGIN
		PATCH_WARN "no array specified in 2da_clone_column"
	END
	// create a blank row
	LPF 2da_insert_column INT_VAR silent STR_VAR array column="%clone_to%" location RET_ARRAY array END
	// get the columns
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
	// clone the data
	PATCH_IF !"%array%" STR_EQ "array" BEGIN 
		CLEAR_ARRAY array
		PHP_EACH "%array%" AS k=>v BEGIN
			SPRINT $array("%k_0%" "%k_1%") "%v%"
		END	
	END
	warn=1
	PHP_EACH rows AS row=>discard BEGIN
		PATCH_IF VARIABLE_IS_SET $"%array%"("%row%" "%clone_from%") BEGIN
			SPRINT $array("%row%" "%clone_to%") $"%array%"("%row%" "%clone_from%")
			warn=0
		END
	END
	PATCH_IF (warn && !silent) BEGIN
		PATCH_WARN "column %clone_from% does not exist, so can't be cloned; new column will be blank"
	END
	END
END		

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_column_to_array}
{
Given a 2d array and column label 'column', extract that column as a 1d array indexed by the 
row labels. 

If we can't find the column label, we return an empty array (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_column_to_array
	INT_VAR silent=0//boolean
	STR_VAR column="" 
			array=""//array
	RET_ARRAY array_out
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY array_out
	found=0
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF "%k_1%" STR_EQ "%column%" BEGIN
			found=1
			SPRINT $array_out("%k_0%") "%v%"
		END
	END
	PATCH_IF !(found || silent) BEGIN
		PATCH_WARN "Column %column% not found in 2da %array%; returning empty array"
	END
  END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_row_to_array}
{
Given a 2d array and row label 'row', extract that row as a 1d array indexed by the 
column labels. 

If we can't find the row label, we return an empty array (and whine about it unless silent=1).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_row_to_array
	INT_VAR silent=0//boolean
	STR_VAR row="" 
			array=""//array
	RET_ARRAY array_out
BEGIN
  OUTER_PATCH "" BEGIN
	CLEAR_ARRAY array_out
	found=0
	PHP_EACH "%array%" AS k=>v BEGIN
		PATCH_IF "%k_0%" STR_EQ "%row%" BEGIN
			found=1
			SPRINT $array_out("%k_1%") "%v%"
		END
	END
	PATCH_IF !(found || silent) BEGIN
		PATCH_WARN "Row %row% not found in 2da %array%; returning empty array"
	END
  END
END


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_to_3da}
{
Given a 2d array and two column headers, extract a 3d array where the first two keys are the
values in the new columns and the third is the old column header.

e.g. if row 14 has col1=x, col2=y, then 3da(x,y,z)=2da(14,z).
}
*/
//////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
/// 2da to 3da - we ignore the row labels, and use 2 columns to construct the new labels
////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION 2da_to_3da 
	STR_VAR column1=""
			column2=""
			array=""//array
	RET_ARRAY array_out
BEGIN
	OUTER_PATCH "" BEGIN
		CLEAR_ARRAY array_out
	LPF array_keys STR_VAR array RET_ARRAY rows=keys1 columns=keys2 END
		PHP_EACH rows AS row=>discard BEGIN
			SPRINT k1 $"%array%"("%row%" "%column1%")
			SPRINT k2 $"%array%"("%row%" "%column2%")
			PHP_EACH columns AS column=>discard2 BEGIN
				PATCH_MATCH "%column%" WITH 
				"%column1%" "%column2%" BEGIN
				END
				DEFAULT
					SPRINT $array_out("%k1%" "%k2%" "%column%") $"%array%"("%row%" "%column%")
				END			
			END	
		END
	END
END


//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_make}
{
Given two arrays in k=>_ format, make a 2da with each character filled with some fixed data
}
*/
//////////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION 2da_make
	STR_VAR rows=""//array
			columns=""//array
			fill="*"
	RET_ARRAY array
BEGIN
	OUTER_PATCH "" BEGIN
		CLEAR_ARRAY array
		PHP_EACH "%rows%" AS row=>discard BEGIN
			PHP_EACH "%columns%" AS col=>discard2 BEGIN
				SPRINT $array("%row%" "%col%") "%fill%"
			END
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////
/*
document{2da_process_table}
{
'table' should be a header table whose headers are the arguments of the action function 'function'.
(INT_VAR arguments should be indicated with ':i'.) Each row of the table is fed to the function.
}
*/
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION 2da_process_table
	INT_VAR inline=0
	STR_VAR table=""
			path=""
			location=""
			locbase=""
			function=""
BEGIN
	// get the data
	LAF 2da_read INT_VAR inline STR_VAR file="%table%" path location locbase type=table_header case=mixed RET_ARRAY rows columns array END
	// get the STR and INT variables
	ACTION_CLEAR_ARRAY ints
	ACTION_CLEAR_ARRAY strs
	OUTER_SPRINT int_string ""
	OUTER_SPRINT str_string ""
	ACTION_PHP_EACH columns AS arg=>discard BEGIN
		OUTER_SET is_int=0
		OUTER_PATCH_SAVE arg "%arg%" BEGIN
			REPLACE_EVALUATE "\(.*\):i" BEGIN
				is_int=1
			END
			"%MATCH1%"
		END
		ACTION_IF is_int BEGIN
			OUTER_SPRINT $ints("%arg%") ""
			OUTER_SPRINT int_string "%int_string%%arg% "
		END ELSE BEGIN
			OUTER_SPRINT $strs("%arg%") ""
			OUTER_SPRINT str_string "%str_string%%arg% "
		END
	END
	// make the function call
	COPY ".../stratagems-inline/process_table_include.tpc" "%workspace%" EVALUATE_BUFFER 
	// do the rows
	ACTION_PHP_EACH rows AS row=>discard BEGIN
		ACTION_PHP_EACH ints AS int=>discard2 BEGIN
			OUTER_SET "%int%"=$array("%row%" "%int%:i")
		END
		ACTION_PHP_EACH strs AS str=>discard2 BEGIN
			OUTER_SPRINT "%str%" $array("%row%" "%str%")
		END	
		REINCLUDE "%workspace%/process_table_include.tpc"
	END
END	

<<<<<<<<.../stratagems-inline/process_table_include.tpc
LAF %function% INT_VAR %int_string% STR_VAR %str_string% END
>>>>>>>>
/*
describe-library{Functions in lib_2daq act on in-game 2da files in-place, rather than the read/write paradigm used in lib_2da. They're optimized for speed insofar as I can manage it (the 'q' stands for 'quick').}

*/





/*
document{2daq_inject}
{
Given a 2D struct 'array' and a 2da file resref, (or, in patch context, the current 2da file) insert the elements of the struct into the 2da. (i.e. if the struct contains "array_x_y" and x and y are row and column entries in the 2da, insert the value of array_x_y at (x,y).

If reflect=1, swap rows and columns. If rowname_column is nonzero, look up the row names in that column.
}

*/

DEFINE_PATCH_FUNCTION 2daq_inject
	INT_VAR reflect=0//boolean
			rowname_column=0
			data_read=0//boolean
	STR_VAR array=""//array
BEGIN
	made_edits=0
	COUNT_2DA_COLS colcount
	PATCH_MATCH "%colcount%" WITH
	2 BEGIN
		col_row=2
		main_row=1
	END
	3 BEGIN
		col_row=1
		main_row=0
	END
	DEFAULT
		col_row=0
		main_row=0
	END
	PATCH_IF !data_read BEGIN
		READ_2DA_ENTRIES_NOW "sfo_2daq_data" colcount 
		READ_2DA_ENTRIES_NOW "sfo_2daq_data_cols" ( colcount - 1)
	END
	// go through the columns
	FOR (col=1;col<colcount;++col) BEGIN
		READ_2DA_ENTRY_FORMER "sfo_2daq_data_cols" col_row (col - 1) col_header
		// then the rows
		FOR (row=main_row;row<sfo_2daq_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER sfo_2daq_data row rowname_column row_header
			data_here=0
			PATCH_IF reflect BEGIN
				PATCH_IF VARIABLE_IS_SET $"%array%"("%col_header%" "%row_header%") BEGIN
					SPRINT data $"%array%"("%col_header%" "%row_header%")
					data_here=1
				END 
			END ELSE BEGIN
				PATCH_IF VARIABLE_IS_SET $"%array%"("%row_header%" "%col_header%") && !(col=rowname_column) BEGIN
					SPRINT data $"%array%"("%row_header%" "%col_header%")
					data_here=1	
				END
			END
			PATCH_IF data_here BEGIN
				READ_2DA_ENTRY_FORMER sfo_2daq_data row col data_old
				PATCH_IF IS_AN_INT data && IS_AN_INT data_old BEGIN
					proceed=!(data=data_old)
				END ELSE BEGIN
					proceed=("%data%" STR_CMP "%data_old%")
				END
				PATCH_IF proceed BEGIN
					SET_2DA_ENTRY_LATER sfo_2daq_data_out row col " %data%" // the space is to prevent WEIDU gratuitously changing from hex to decimal
					made_edits=1
				END	
			END
		END
	END
	// flush values
	PATCH_IF made_edits BEGIN
		SET_2DA_ENTRIES_NOW sfo_2daq_data_out colcount
		PRETTY_PRINT_2DA
		REPLACE_TEXTUALLY "2DA[ %TAB%]+V1.0" "2DA V1.0"
	END
END

DEFINE_ACTION_FUNCTION 2daq_inject
	INT_VAR reflect=0//boolean
			rowname_column=0
			data_read=0//boolean
	STR_VAR array=""//array
			resref=""
BEGIN
	COPY_EXISTING "%resref%.2da" override
		LPF 2daq_inject INT_VAR data_read reflect rowname_column STR_VAR array END
	BUT_ONLY
END

/*
document{2daq_has_column}
{
Return 1 iff the current 2da file has 'column' as a column id. 
}

*/

DEFINE_PATCH_FUNCTION 2daq_has_column
	INT_VAR data_read=0//boolean
	STR_VAR column=""
	RET value
BEGIN
	value=0
	PATCH_IF INDEX_BUFFER (CASE_INSENSITIVE "%column%")>=0 BEGIN
		COUNT_2DA_COLS colcount
		PATCH_MATCH "%colcount%" WITH
		2 BEGIN
			col_row=2
			main_row=1
		END
		3 BEGIN
			col_row=1
			main_row=0
		END
		DEFAULT
			col_row=0
			main_row=0
		END
		PATCH_IF !data_read BEGIN
			READ_2DA_ENTRIES_NOW sfo_2daq_data_cols (colcount - 1)
		END
		FOR (col_number=1;col_number<colcount;++col_number) BEGIN
			READ_2DA_ENTRY_FORMER "sfo_2daq_data_cols" col_row (col_number - 1) col_header
			PATCH_IF "%col_header%" STR_EQ "%column%" BEGIN
				value=1
				col_number=colcount
			END
		END
	END
END


/*
document{2daq_has_row}
{
Return 1 iff the current 2da file has 'row' as a row id. (Check rowname_column).
}

*/

DEFINE_PATCH_FUNCTION 2daq_has_row
	INT_VAR rowname_column=0
			data_read=0//boolean
	STR_VAR row=""
	RET value
BEGIN
	value=0
	PATCH_IF INDEX_BUFFER (CASE_INSENSITIVE "%row%")>=0 BEGIN
		COUNT_2DA_COLS colcount
		PATCH_MATCH "%colcount%" WITH
		2 BEGIN
			col_row=2
			main_row=1
		END
		3 BEGIN
			col_row=1
			main_row=0
		END
		DEFAULT
			col_row=0
			main_row=0
		END
		PATCH_IF !data_read BEGIN
			READ_2DA_ENTRIES_NOW sfo_2daq_data colcount
		END
		FOR (row_number=main_row;row_number<sfo_2daq_data;++row_number) BEGIN
			READ_2DA_ENTRY_FORMER sfo_2daq_data row_number rowname_column entry
			PATCH_IF "%entry%" STR_EQ "%row%" BEGIN
				value=1
				row_number=sfo_2daq_data
			END
		END
	END
END


/*
document{2daq_extract}
{
Given a column header and/or a row header, and a 2da file resref, (or, in patch context, the current 2da file), extract the column or row as k=>v array using the row or column headers, as appropriate, as keys.

If both row and column are set, instead return the element (if any) at (row,column) as 'value', as well as its row as 'rownum'.
}

*/

DEFINE_PATCH_FUNCTION 2daq_extract
	INT_VAR rowname_column=0
			data_read=0
	STR_VAR row=""
			column=""
			case=mixed//[mixed|upper|lower]
	RET value
		rownum
	RET_ARRAY array
BEGIN
	CLEAR_ARRAY array
	PATCH_IF "%row%%column%" STR_EQ "" BEGIN
		PATCH_FAIL "2daq_extract failure: no row or column selected"
	END
	rownum="-1"
	SPRINT value ""
	COUNT_2DA_COLS colcount
	PATCH_MATCH "%colcount%" WITH
	2 BEGIN
		col_row=2
		main_row=1
	END
	3 BEGIN
		col_row=1
		main_row=0
	END
	DEFAULT
		col_row=0
		main_row=0
	END
	PATCH_IF !data_read BEGIN
		READ_2DA_ENTRIES_NOW "sfo_2daq_data" colcount 
		READ_2DA_ENTRIES_NOW "sfo_2daq_data_cols" ( colcount - 1)
	END
	PATCH_IF "%column%" STR_CMP "" BEGIN
		FOR (col_number=1;col_number<colcount;++col_number) BEGIN
			READ_2DA_ENTRY_FORMER "sfo_2daq_data_cols" col_row (col_number - 1) col_header
			PATCH_IF "%col_header%" STR_EQ "%column%" BEGIN
			// then the rows
				FOR (row_number=main_row;row_number<sfo_2daq_data;++row_number) BEGIN
					READ_2DA_ENTRY_FORMER sfo_2daq_data row_number rowname_column row_header
					PATCH_IF "%row_header%" STR_EQ "%row%" || "%row%" STR_EQ ""BEGIN
						READ_2DA_ENTRY_FORMER sfo_2daq_data row_number col_number value
						PATCH_MATCH "%case%" WITH
						upper BEGIN
							TO_UPPER value
							TO_UPPER row_header
						END
						lower BEGIN
							TO_LOWER value
							TO_LOWER row_header
						END
						DEFAULT
						END
						SPRINT $array("%row_header%") "%value%"
						PATCH_IF "%row_header%" STR_EQ "%row%" BEGIN // if we're just getting 'row'/'col', terminate
							row_number=sfo_2daq_data
						END
					END 
				END
				col=colcount
			END		
		END	
	END ELSE BEGIN
		FOR (row_number=main_row;row_number<sfo_2daq_data;++row_number) BEGIN
			READ_2DA_ENTRY_FORMER sfo_2daq_data row_number rowname_column row_header
			PATCH_IF "%row_header%" STR_EQ "%row%" BEGIN
				FOR (col_number=1;col_number<colcount;++col_number) BEGIN
					READ_2DA_ENTRY_FORMER "sfo_2daq_data_cols" col_row (col_number - 1) col_header
					READ_2DA_ENTRY_FORMER sfo_2daq_data row_number col_number value
					PATCH_MATCH "%case%" WITH
					upper BEGIN
						TO_UPPER value
						TO_UPPER col_header
					END
					lower BEGIN
						TO_LOWER value
						TO_LOWER col_header
					END
					DEFAULT
					END

					SPRINT $array("%col_header%") "%value%"
					rownum=row_number
				END
				row_number=sfo_2daq_data
			END
		END
	END
END

DEFINE_ACTION_FUNCTION 2daq_extract
	INT_VAR rowname_column=0
			data_read=0//boolean
	STR_VAR resref=""
			row=""
			column=""
			case=""
	RET value
	RET_ARRAY array
BEGIN
	COPY_EXISTING - "%resref%.2da" nowhere
		LPF 2daq_extract INT_VAR data_read rowname_column STR_VAR row column case RET value RET_ARRAY array END
	
END

/*
document{2daq_insert_column}
{
Adds a new column, with header 'column', as the last column, or the second-to-last column if insert_loc is 'before_last'. All entries are filled with the 2da default value. }
*/


DEFINE_PATCH_FUNCTION 2daq_insert_column
	STR_VAR column=""
			insert_loc="last"//[last|before_last]
BEGIN
	READ_2DA_ENTRY 1 0 1 default
	PATCH_MATCH "%insert_loc%" WITH
	last BEGIN
		count=0
		REPLACE_EVALUATE "^\([^%WNL%%LNL%%MNL%]+\)" BEGIN
			PATCH_IF count<2 BEGIN
				SPRINT out "%MATCH1%"
			END ELSE
			PATCH_IF count=2 BEGIN
				SPRINT out "%MATCH1%%TAB%%column%"
			END ELSE BEGIN
				SPRINT out "%MATCH1%%TAB%%default%"
			END
			++count
		END
		"%out%"	
	END
	before_last BEGIN
		count=0
		REPLACE_EVALUATE "^\(.+\)[ %TAB%]+\([^ %TAB%%WNL%%MNL%%LNL%]+\)" BEGIN
			PATCH_IF count<1 BEGIN
				SPRINT out "%MATCH1%%TAB%%MATCH2%"
			END ELSE
			PATCH_IF count=1 BEGIN
				SPRINT out "%MATCH1%%TAB%%column%%TAB%%MATCH2%"
			END ELSE BEGIN
				SPRINT out "%MATCH1%%TAB%%default%%TAB%%MATCH2%"
			END
			++count
		END
		"%out%"		
	END
	DEFAULT
		PATCH_FAIL "Unrecognised insert_loc %insert_loc% in 2daq_insert_column"
	END
	PRETTY_PRINT_2DA
	

END

/*
document{2daq_insert_row}
{
Adds a new row, with header 'row', as the last row. All entries are filled with the 2da default value. If rowname_column>0, we put the header in this column, and assume column 0 should be numbered sequentially from 0.
}
*/

DEFINE_PATCH_FUNCTION 2daq_insert_row
	INT_VAR rowname_column=0
	STR_VAR row=""
BEGIN	
	COUNT_2DA_COLS colcount
	READ_2DA_ENTRY 1 0 1 default
	SPRINT data ""
	FOR (n=0;n<colcount;++n) BEGIN
		PATCH_IF n=rowname_column BEGIN
			SPRINT data "%data%%row%%TAB%"
		END ELSE 
		PATCH_IF n=0 BEGIN
			COUNT_2DA_ROWS colcount rowcount
			SPRINT data "%data%%rowcount%%TAB%"
		END ELSE BEGIN
			SPRINT data "%data%%default%%TAB%"
		END
	END
	insert_point=BUFFER_LENGTH
	INSERT_BYTES insert_point STRING_LENGTH "%WNL%%data%"
	WRITE_ASCII insert_point "%WNL%%data%"
	PRETTY_PRINT_2DA
END



/*
document{2daq_copy_column}
{
Copies a column in the current 2da file to the right-hand side of the table, with new column name 'column_new'. Returns 1 if copy is successful. Stoically silent if it isn't.

}


*/



DEFINE_PATCH_FUNCTION 2daq_copy_column
	INT_VAR data_read=0//boolean
	STR_VAR column=""
			column_new="%column%"
	RET value
BEGIN
	value=0
	COUNT_2DA_COLS colcount
	PATCH_MATCH "%colcount%" WITH
	2 BEGIN
		col_row=2
		main_row=1
	END
	3 BEGIN
		col_row=1
		main_row=0
	END
	DEFAULT
		col_row=0
		main_row=0
	END
	PATCH_IF !data_read BEGIN
		READ_2DA_ENTRIES_NOW "sfo_2daq_data" colcount 
		READ_2DA_ENTRIES_NOW "sfo_2daq_data_cols" ( colcount - 1)
	END
	FOR (col_number=1;col_number<colcount;++col_number) BEGIN
		READ_2DA_ENTRY_FORMER sfo_2daq_data_cols col_row (col_number - 1) col_header
		PATCH_IF "%col_header%" STR_EQ "%column%" BEGIN
			value=1
			FOR (row_number=main_row;row_number<sfo_2daq_data;++row_number) BEGIN
				READ_2DA_ENTRY_FORMER sfo_2daq_data row_number col_number entry
				READ_2DA_ENTRY_FORMER sfo_2daq_data row_number (colcount - 1) end_entry
				SET_2DA_ENTRY_LATER sfo_2daq_data_out row_number (colcount - 1) "%end_entry%SFO_DIVIDER%entry%"
			END
			READ_2DA_ENTRY_FORMER sfo_2daq_data_cols col_row (colcount - 2) end_col
			SET_2DA_ENTRY_LATER sfo_2daq_data_cols_out col_row (colcount - 2) "%end_col%SFO_DIVIDER%column_new%"
			SET_2DA_ENTRIES_NOW sfo_2daq_data_cols_out (colcount - 1)
			col_number=colcount
		END
	END
	PATCH_IF value BEGIN
		SET_2DA_ENTRIES_NOW sfo_2daq_data_out colcount
		REPLACE_TEXTUALLY "SFO_DIVIDER" "%TAB%"
		PRETTY_PRINT_2DA
	END
	

END

/*
document{2daq_copy_row}
{
Copies a row in the current 2da file to the bottom of the table, with new row name 'row_new'. Returns 1 if copy is successful. Stoically silent if it isn't.

If 'rowname_column' is set, the row id is looked up in that column, and column 0 is assumed to be numbered sequentially.
(This is the convention for kitlist.2da.)

}


*/


DEFINE_PATCH_FUNCTION 2daq_copy_row
	INT_VAR rowname_column=0
			data_read=0//boolean
	STR_VAR row=""
			row_new="%row%"
	RET value
BEGIN
	value=0
	PATCH_IF rowname_column=0 BEGIN
		REPLACE_EVALUATE CASE_INSENSITIVE "^\(%row%[ %TAB%].*\)" BEGIN
			INNER_PATCH_SAVE new_row "%MATCH1%" BEGIN
				REPLACE_TEXTUALLY CASE_INSENSITIVE "^%row%" "%row_new%"
			END
			value=1
		END
		"%MATCH1%"
		PATCH_IF value BEGIN
			insert_point=BUFFER_LENGTH
			INSERT_BYTES insert_point STRING_LENGTH "%new_row%"
			WRITE_ASCII insert_point "%new_row%"
			PRETTY_PRINT_2DA
		END
	END ELSE BEGIN
		COUNT_2DA_COLS colcount
		PATCH_MATCH "%colcount%" WITH
		2 BEGIN
			col_row=2
			main_row=1
		END
		3 BEGIN
			col_row=1
			main_row=0
		END
		DEFAULT
			col_row=0
			main_row=0
		END
		PATCH_IF !data_read BEGIN
			READ_2DA_ENTRIES_NOW "sfo_2daq_data" colcount 
		END
		FOR (row_number=main_row;row_number<sfo_2daq_data;++row_number) BEGIN
			READ_2DA_ENTRY_FORMER sfo_2daq_data row_number rowname_column this_row
			PATCH_IF "%this_row%" STR_EQ "%row%" BEGIN
				SPRINT row_with_case "%this_row%"
				SET_2DA_ENTRY row_number rowname_column colcount "SFO_FOR_COPYING"
				value=1
				row_number=sfo_2daq_data
			END
		END
		PATCH_IF value BEGIN
			REPLACE_EVALUATE "^\([0-9]+\)\(.*SFO_FOR_COPYING.*\)" BEGIN
				SPRINT new_row "SFO_NEW_NUMBER%MATCH2%"
				INNER_PATCH_SAVE new_row "%new_row%" BEGIN
					REPLACE_TEXTUALLY SFO_FOR_COPYING SFO_NEW_ROWNAME
				END
			END
			"%MATCH1%%MATCH2%"
			insert_point=BUFFER_LENGTH
			INSERT_BYTES insert_point STRING_LENGTH "%new_row%"
			WRITE_ASCII insert_point "%new_row%"
			REPLACE_TEXTUALLY SFO_NEW_NUMBER "%sfo_2daq_data%"
			REPLACE_TEXTUALLY "SFO_FOR_COPYING" "%row_with_case%"
			REPLACE_TEXTUALLY "SFO_NEW_ROWNAME" "%row_new%"
			PRETTY_PRINT_2DA
		END
	END
END
/* describe-library
{Functions to manipulate WEIDU arrays.
Functions in this library should be pure (no side effects) except insofar as they're explicitly writing array data into a file. They shouldn't interact with IE resources at all.
Most functions here assume a simple (i.e. not multidimensional) array.

Functions should start with 'array_'.}

*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_map}
{Take a k->v array is input; return keymap(k)->map(v). (Either function can be absent, in which case it's treated as the identity.) 
You can use the anonymous function construct.}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_map
	STR_VAR array=""//array
			map=""//function
			keymap=""//function
	RET_ARRAY array
BEGIN
	// anonymous function construct
	LAF anon_check INT_VAR has_output=1 STR_VAR function="%map%" RET map=function END
	LAF anon_check INT_VAR has_output=1 STR_VAR function="%keymap%" RET keymap=function END

	// map
	ACTION_IF "%map%" STR_CMP "" BEGIN
		ACTION_PHP_EACH "%array%" AS k=>v BEGIN
			OUTER_PATCH "" BEGIN
				LPF "%map%" STR_VAR arguments="%v%" RET value END
			END
			OUTER_SPRINT $"%array%"("%k%") "%value%"
		END
	END
	//keymap
	ACTION_IF "%keymap%" STR_CMP "" BEGIN
		// make the new array
		ACTION_CLEAR_ARRAY SFO_working_array
		ACTION_PHP_EACH "%array%" AS arguments=>v BEGIN
			OUTER_PATCH "" BEGIN
				LPF "%keymap%" STR_VAR arguments RET value END
				SPRINT $SFO_working_array("%value%") "%v%"
			END
		END
		// flush into the output array
		LAF array_copy STR_VAR array=SFO_working_array RET_ARRAY array END
	END ELSE BEGIN
		LAF array_copy STR_VAR array="%array%" RET_ARRAY array END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_split}
{Take a k->v array as input, along with functions 'match_key' and/or 'match_value'; return an array 'split' of all elements with keys that match 'kmatch'
and values that match 'vmatch', and an array 'match' of all that don't. You can use the anonymous function construct.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_split
	STR_VAR array=""//array
			match_key=""//function
			match_value=""//function
	RET_ARRAY split rest
BEGIN
	OUTER_PATCH "" BEGIN
		// anonymous function construct
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%match_key%" RET match_key=function SFO_anon_func_count END
		LPF anon_check INT_VAR has_output=1 STR_VAR function="%match_value%" RET match_value=function SFO_anon_func_count END

		CLEAR_ARRAY split
		CLEAR_ARRAY rest
		PHP_EACH "%array%" AS k=>v BEGIN
			PATCH_IF "%match_key%" STR_CMP "" BEGIN
				LPF "%match_key%" STR_VAR arguments="%k%" RET value1=value END
			END ELSE BEGIN
				value1=1
			END
			PATCH_IF "%match_value%" STR_CMP "" BEGIN
				LPF "%match_value%" STR_VAR arguments="%v%" RET value2=value END
			END ELSE BEGIN
				value2=1
			END
			PATCH_IF value1 && value2 BEGIN
				SPRINT $split("%k%") "%v%"
			END ELSE BEGIN
				SPRINT $rest("%k%") "%v%"		
			END
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_contains}
{Depending on which of 'key' and 'val' are set, return true if (i) array 'array' contains 'key' as a key; (ii) array 'array' contains 
'val' as a value; (iii) array 'array' contains the pair 'key'=>'val', or I suppose (iv) array 'array' is non-empty.</p>

<p>This is intentionally case-sensitive (since a common use-case is going to be pulling an array element out by its key if it's in
the array).}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_contains
	STR_VAR array=""//array
			key=""
			val=""
	RET value
BEGIN
	OUTER_SET value=0
	ACTION_PHP_EACH "%array%" AS k1=>v1 BEGIN
		ACTION_IF ("%key%" STRING_EQUAL "%k1%" || "%key%" STR_EQ "") && ("%val%" STRING_EQUAL "%v1%" || "%val%" STR_EQ "") BEGIN
			OUTER_SET value=1
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_length}
{Returns the number of elements in the array. ('value' and 'length' are synonyms.)}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_length
	STR_VAR array=""//array
	RET value length
BEGIN
	OUTER_SET value=0
	ACTION_PHP_EACH "%array%" AS k1=>v1 BEGIN
		OUTER_SET ++value
	END
	OUTER_SET length=value
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_read}
{Take a file (or, for the patch version, the current file), which should be a table, (not necessarily a 2da) and read in the first two
columns into a k->v array. (If there's only one column, read it into a k->_ array.)

Start at row firstrow.

In action context, return value=1 if the file exists, value=0 if it doesn't, and whine if it doesn't unless silent=1.

If backwards=1, swap the order of key and value.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION array_read
	INT_VAR firstrow=0
			backwards=0//boolean
	STR_VAR case=mixed//[upper|lower|mixed]
	RET_ARRAY array
BEGIN
	CLEAR_ARRAY array
	COUNT_2DA_COLS colcount
	PATCH_IF colcount>2 BEGIN
		colcount=2
	END
	empty=1
	PATCH_IF colcount>0 BEGIN
		READ_2DA_ENTRIES_NOW SFO_data colcount
		FOR (row=firstrow;row<SFO_data;++row) BEGIN
			empty=0
			READ_2DA_ENTRY_FORMER SFO_data row 0 k
			PATCH_IF colcount=2 BEGIN
				READ_2DA_ENTRY_FORMER SFO_data row 1 v
			END ELSE BEGIN
				SPRINT v ""
			END
			PATCH_MATCH "%case%" WITH
			upper BEGIN
				TO_UPPER v
				TO_UPPER k
			END
			lower BEGIN
				TO_LOWER v
				TO_LOWER k
			END
			DEFAULT
			END
			PATCH_IF !("%k%" STR_EQ "2DA" && "%v%" STR_EQ "1.0") BEGIN
				PATCH_IF !backwards BEGIN
					SPRINT $array("%k%") "%v%"
				END ELSE BEGIN
					SPRINT $array("%v%") "%k%"
				
				END
			END
		END
	END
	PATCH_IF empty BEGIN
		SPRINT $array("null") discard
	END
END

DEFINE_ACTION_FUNCTION array_read
	INT_VAR firstrow=0
			silent=0
			backwards=0//boolean
			inline=0//boolean
	STR_VAR file="" path="" location="" locbase=""
			case=mixed//[upper|lower|mixed]
	RET value
	RET_ARRAY array
BEGIN
	LAF sfo_path STR_VAR file path location locbase RET file_path END
	ACTION_IF FILE_EXISTS "%file_path%" || inline BEGIN
		COPY "%file_path%" "%workspace%"
			LPF array_read INT_VAR firstrow backwards STR_VAR case RET_ARRAY array END
		BUT_ONLY
		OUTER_SET value=1
	END ELSE BEGIN
		OUTER_SET value=0
		ACTION_IF !silent BEGIN
			ACTION_CLEAR_ARRAY array
			WARN "array_read: file %file_path% does not exist"
		END
	END
END
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_echo}
{Print an array to the screen (good for debugging). If single_line=1, returns a single string with comma-separated entries;
otherwise returns one k=>v per line.}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION array_echo
	INT_VAR single_line=0//debug
	STR_VAR array=""//array
BEGIN
    OUTER_SPRINT report ""
	ACTION_PHP_EACH "%array%" AS sfo_reserved_array_echo_k=>v BEGIN
			OUTER_SPRINT key ""
			OUTER_SET ind=0
			OUTER_WHILE VARIABLE_IS_SET "sfo_reserved_array_echo_k_%ind%" BEGIN
				OUTER_SET ++ind
			END
			OUTER_FOR (i=0;i<ind;++i) BEGIN
				OUTER_SPRINT temp EVAL "%sfo_reserved_array_echo_k_%i%%"
				ACTION_IF !("%key%" STR_EQ "") BEGIN
					OUTER_SPRINT key "%key%,"
				END
				OUTER_SPRINT key "%key%%temp%"
			END
			ACTION_IF single_line BEGIN
				OUTER_SPRINT report "%report%%key%: %v%, "
			END ELSE BEGIN
				PRINT "%key%: %v%"
			END
	END
	ACTION_IF single_line BEGIN
		PRINT "%report%"
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_invert}
{Input an array of k->v; output an array of v->k.}

*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION array_invert
	STR_VAR array=""//array
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY SFO_working_array
	ACTION_PHP_EACH "%array%" AS k=>v BEGIN
		OUTER_SPRINT $SFO_working_array("%v%") "%k%"
	END
	ACTION_CLEAR_ARRAY array
	ACTION_PHP_EACH SFO_working_array AS k=>v BEGIN
		OUTER_SPRINT $array("%k%") "%v%"
	END


END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_log}
{Output an array as a 2-column table. If 'new' is set, overwrite any existing file by the same name; if not, append. If 'permanent' is
set, the table will persist even if the component is uninstalled. (This automatically sets 'new'.)}

*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION array_log 
	INT_VAR new=0//boolean
			permanent=0//boolean
	STR_VAR path="%data_loc%"
			file=""
			array=""
BEGIN
	
	ACTION_IF permanent BEGIN
		COPY + ".../stratagems-inline/blank" "%path%/%file%"
	END ELSE
	ACTION_IF !FILE_EXISTS "%path%/%file%" || new BEGIN
		COPY ".../stratagems-inline/blank" "%path%/%file%"
	END
	OUTER_SPRINT data ""
	ACTION_PHP_EACH "%array%" AS k=>v BEGIN
		OUTER_SPRINT data "%data%%k%%TAB%%v%%WNL%"
	END
	ACTION_IF permanent BEGIN
		COPY + "%path%/%file%" "%path%"
			insert_point=BUFFER_LENGTH
			INSERT_BYTES insert_point STRING_LENGTH "%data%"
			WRITE_ASCII insert_point "%data%"
		BUT_ONLY
	
		END ELSE BEGIN
		COPY "%path%/%file%" "%path%"
			insert_point=BUFFER_LENGTH
			INSERT_BYTES insert_point STRING_LENGTH "%data%"
			WRITE_ASCII insert_point "%data%"
		BUT_ONLY
	END
END

//////////////////////////////////////////////////////////////////////////////////
/*
document{array_2d_to_list} 
{Take a 2d array (k1,k2)->v. Return a 1d array with the k1 as keys and a list of the k2 as values. Optionally, require that v=require_value. 
If sort=1, sort entries lexicographically.
}

*/
//////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION array_2d_to_list
	INT_VAR sort=1//Boolean
	STR_VAR array=""//array
			separator=" "
			require_value=""
	RET_ARRAY list
BEGIN
	ACTION_CLEAR_ARRAY list
	LAF array_keys STR_VAR array RET_ARRAY keys1 keys2 END
	ACTION_SORT_ARRAY_INDICES keys2 LEXICOGRAPHICALLY
	ACTION_PHP_EACH keys1 AS k1=>discard BEGIN
		OUTER_SPRINT $list("%k1%") ""
		ACTION_PHP_EACH keys2 AS k2=>discard BEGIN
			ACTION_IF VARIABLE_IS_SET $"%array%"("%k1%" "%k2%") BEGIN
				ACTION_IF "%require_value%" STR_EQ "" || $"%array%"("%k1%" "%k2%") STR_EQ "%require_value%" BEGIN
					OUTER_SPRINT $list("%k1%") EVAL "%list_%k1%%%k2%%separator%"					
				END
			END
		END
	END
	// strip trailing symbol
	ACTION_PHP_EACH list AS k=>v BEGIN
		OUTER_PATCH_SAVE v "%v%" BEGIN
			REPLACE_TEXTUALLY "%separator%$" ""
		END
		OUTER_SPRINT $list("%k%") "%v%"
	END


END

//////////////////////////////////////////////////////////////////////////////////
/*
document{array_keys_from_string} 
{Take a string of strings separated by 'separator' (a character). Read them in as the keys of an array. (Values are blank.)}

*/
//////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_keys_from_string
	STR_VAR separator=" "
			string=""
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY array
	OUTER_WHILE "%string%" STR_CMP "" BEGIN
		LAF return_first_entry STR_VAR list="%string%" separator RET entry string=list END
		OUTER_SPRINT $array("%entry%") ""
	END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_values_from_string}
{
Given a string of strings separated by 'separator' (a character), return an [int]=>v array of those strings, labelled by sequential integers. If 'quick' is set, 
assume no entries are quoted. 'quick' only works for a ' ' or tab separator. 
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DEFINE_DIMORPHIC_FUNCTION array_values_from_string
	INT_VAR quick=0
	STR_VAR string=""
			separator=" "
	RET array_length
	RET_ARRAY array
BEGIN
	OUTER_SET count=0
	ACTION_CLEAR_ARRAY array
	ACTION_IF quick BEGIN
		ACTION_IF "%separator%" STR_CMP " " BEGIN
			WARN "list_to_array doesn't allow quick mode with a non-space separator"
			LAF list_to_array STR_VAR list="%string%" separator RET_ARRAY array END
		END ELSE BEGIN
			OUTER_SPRINT list "%string% "
			OUTER_PATCH "%list%" BEGIN
				REPLACE_EVALUATE "\([^ %TAB%]+\)[ %TAB%]+" BEGIN
					SPRINT $array("%count%") "%MATCH1%"
					++count
				END
				""
			END
		END
	END ELSE BEGIN
		OUTER_WHILE "%string%" STR_CMP "" BEGIN
			LAF return_first_entry STR_VAR list="%string%" RET entry string=list END
			OUTER_SPRINT $array("%count%") "%entry%"
			OUTER_SET ++count
		END
	END
	OUTER_SET array_length=count
END

//////////////////////////////////////////////////////////////////////////////////
/*
document{array_from_string} 
{Take a string of k=>v pairs separated by spaces. Read them into an array. }

*/
//////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION array_from_string
	STR_VAR string="" 
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY array
	OUTER_WHILE "%string%" STR_CMP "" BEGIN
		LAF return_first_pair STR_VAR list="%string%" RET key value string=list END
		OUTER_SPRINT $array("%key%") "%value%"
	END

END

//////////////////////////////////////////////////////////////////////////////////
/*
document{array_copy} 
{Copy an array.}

*/
//////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION array_copy
	STR_VAR array=""
	RET_ARRAY array
BEGIN
	ACTION_IF "%array%" STR_CMP "array" BEGIN
	ACTION_CLEAR_ARRAY array
		ACTION_PHP_EACH "%array%" AS sfo_reserved_array_copy_k=>discard BEGIN
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_copy_k_1 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_copy_k_0%") $"%array%"("%sfo_reserved_array_copy_k_0%")
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_copy_k_2 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%") $"%array%"("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%")
			END ELSE		
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_copy_k_3 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%") $"%array%"("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%")
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_copy_k_4 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%" "%sfo_reserved_array_copy_k_3%") $"%array%"("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%" "%sfo_reserved_array_copy_k_3%")
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_copy_k_5 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%" "%sfo_reserved_array_copy_k_3%" "%sfo_reserved_array_copy_k_4%") $"%array%"("%sfo_reserved_array_copy_k_0%" "%sfo_reserved_array_copy_k_1%" "%sfo_reserved_array_copy_k_2%" "%sfo_reserved_array_copy_k_3%" "%sfo_reserved_array_copy_k_4%")
			END ELSE BEGIN		
				WARN "array_copy can't handle arrays more than 5 levels deep"
			END
		END
	END

END

//////////////////////////////////////////////////////////////////////////////////
/*
document{array_fill} 
{Given an array of keys, set each to the value 'fill'.}

*/
//////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_fill
	STR_VAR array=""//array
			fill="*"  
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY array
	ACTION_PHP_EACH "%array%" AS sfo_reserved_array_fill_k=>discard BEGIN
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_fill_k_1 BEGIN
				OUTER_SPRINT $array("%sfo_reserved_array_fill_k_0%") "%fill%"
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_fill_k_2 BEGIN
				OUTER_SPRINT $array("%sfo_reserved_array_fill_k_0%" "%sfo_reserved_array_fill_k_1%") "%fill%"
		END ELSE		
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_fill_k_3 BEGIN
				OUTER_SPRINT $array("%sfo_reserved_array_fill_k_0%" "%sfo_reserved_array_fill_k_1%" "%sfo_reserved_array_fill_k_2%") "%fill%" 
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_fill_k_4 BEGIN
				OUTER_SPRINT $array("%sfo_reserved_array_fill_k_0%" "%sfo_reserved_array_fill_k_1%" "%sfo_reserved_array_fill_k_2%" "%sfo_reserved_array_fill_k_3%") "%fill%"
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_fill_k_5 BEGIN
				OUTER_SPRINT $array("%sfo_reserved_array_fill_k_0%" "%sfo_reserved_array_fill_k_1%" "%sfo_reserved_array_fill_k_2%" "%sfo_reserved_array_fill_k_3%" "%sfo_reserved_array_fill_k_4%") "%fill%"
		END ELSE BEGIN		
			WARN "array_fill can't handle arrays more than 5 levels deep"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_join}
{Take two arrays and combine them, so that key k is in the new array iff it is in one or other of the old arrays. If there's a clash
of key allocations, array2 gets priority.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION array_join
	STR_VAR array1=""//array
			array2=""//array
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY array
	ACTION_FOR_EACH oldarray IN "%array1%" "%array2%" BEGIN
		ACTION_PHP_EACH "%oldarray%" AS sfo_reserved_array_join_k=>v BEGIN
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_join_k_1 BEGIN
					ACTION_IF "%sfo_reserved_array_join_k_0%-%v%" STR_CMP "null-discard" BEGIN
						OUTER_SPRINT $array("%sfo_reserved_array_join_k_0%") "%v%"
					END
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_join_k_2 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_join_k_0%" "%sfo_reserved_array_join_k_1%") "%v%"
			END ELSE		
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_join_k_3 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_join_k_0%" "%sfo_reserved_array_join_k_1%" "%sfo_reserved_array_join_k_2%") "%v%" 
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_join_k_4 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_join_k_0%" "%sfo_reserved_array_join_k_1%" "%sfo_reserved_array_join_k_2%" "%sfo_reserved_array_join_k_3%") "%v%"
			END ELSE
			ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_join_k_5 BEGIN
					OUTER_SPRINT $array("%sfo_reserved_array_join_k_0%" "%sfo_reserved_array_join_k_1%" "%sfo_reserved_array_join_k_2%" "%sfo_reserved_array_join_k_3%" "%sfo_reserved_array_join_k_4%") "%v%"
			END ELSE BEGIN		
				WARN "array_join can't handle arrays more than 5 levels deep"
			END
		END
	END
	
END



//////////////////////////////////////////////////////////////////////////////////
/*
document{array_keys} 
{Given an array, return arrays k=>_ of the first five levels of its keys.}

*/
//////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_keys
	STR_VAR array=""//array 
	RET_ARRAY keys1 keys2 keys3 keys4 keys5
BEGIN
	ACTION_FOR_EACH keys IN keys1 keys2 keys3 keys4 keys5 BEGIN
		ACTION_CLEAR_ARRAY "%keys%"
	END
	ACTION_PHP_EACH "%array%" AS sfo_reserved_array_keys_k=>discard BEGIN
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_keys_k_1 BEGIN
				OUTER_SPRINT $keys1("%sfo_reserved_array_keys_k_0%") ""
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_keys_k_2 BEGIN
				OUTER_SPRINT $keys1("%sfo_reserved_array_keys_k_0%") ""
				OUTER_SPRINT $keys2("%sfo_reserved_array_keys_k_1%") ""
		END ELSE		
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_keys_k_3 BEGIN
				OUTER_SPRINT $keys1("%sfo_reserved_array_keys_k_0%") ""
				OUTER_SPRINT $keys2("%sfo_reserved_array_keys_k_1%") ""
				OUTER_SPRINT $keys3("%sfo_reserved_array_keys_k_2%") ""
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_keys_k_4 BEGIN
				OUTER_SPRINT $keys1("%sfo_reserved_array_keys_k_0%") ""
				OUTER_SPRINT $keys2("%sfo_reserved_array_keys_k_1%") ""
				OUTER_SPRINT $keys3("%sfo_reserved_array_keys_k_2%") ""
				OUTER_SPRINT $keys4("%sfo_reserved_array_keys_k_3%") ""
		END ELSE
		ACTION_IF !VARIABLE_IS_SET sfo_reserved_array_keys_k_5 BEGIN
				OUTER_SPRINT $keys1("%sfo_reserved_array_keys_k_0%") ""
				OUTER_SPRINT $keys2("%sfo_reserved_array_keys_k_1%") ""
				OUTER_SPRINT $keys3("%sfo_reserved_array_keys_k_2%") ""
				OUTER_SPRINT $keys4("%sfo_reserved_array_keys_k_3%") ""
				OUTER_SPRINT $keys5("%sfo_reserved_array_keys_k_4%") ""
		END 
	END
END

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{array_sort}
{
Given a patch function (of argument->value type) with domain the keys of an array, sort that array alphabetically
by the values of the function. The function doesn't have to be 1:1. You can use the anonymous function construct.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION array_sort
	STR_VAR array=""
			function=""
	RET_ARRAY array
BEGIN
	ACTION_CLEAR_ARRAY sorting_array
	LAF anon_check INT_VAR has_output=1 STR_VAR function RET function END

	OUTER_SET uniqueness_counter=0
	ACTION_PHP_EACH "%array%" AS arguments=>discard BEGIN
		OUTER_PATCH "" BEGIN
			LPF "%function%" STR_VAR arguments RET value END
		END
		OUTER_SPRINT value "%value%%uniqueness_counter%"
		OUTER_SPRINT $sorting_array("%value%") "%arguments%"
		OUTER_SET ++uniqueness_counter
	END
	ACTION_SORT_ARRAY_INDICES sorting_array LEXICOGRAPHICALLY
	ACTION_CLEAR_ARRAY array_out
	ACTION_PHP_EACH sorting_array AS discard=>key BEGIN
		OUTER_SPRINT $array_out("%key%") $"%array%"("%key%")
	END
	LAF array_copy STR_VAR array=array_out RET_ARRAY array END
END
///////////////////////////////////////////////////////////////////////////////
/*
document{data_spell_resrefs}
{
Read in every entry in spell.ids and set a variable with that name whose
value is the spell resref, and store the data in the sfo_spell_resrefs array

e.g. WIZARD_FIREBALL = SPWI304
     $sfo_spell_resrefs("WIZARD_FIREBALL") = SPWI304

Also, for wizard/priest spells, store the spell level in the format

WIZARD_FIREBALL_LEVEL=3


If extended spell namespace is in use, add the spells from dw_ext_spell.ids too
}
*/
///////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_spell_resrefs BEGIN
    LOCAL_SPRINT idsname ""
	LOCAL_SPRINT resref ""
	LAF data_internal_spell_resrefs RET_ARRAY sfo_spell_resrefs sfo_spell_levels END
    ACTION_PHP_EACH sfo_spell_resrefs AS idsname=>resref BEGIN
        OUTER_SPRINT "%idsname%" "%resref%"
		ACTION_IF VARIABLE_IS_SET $sfo_spell_levels("%idsname%") BEGIN
			OUTER_SPRINT "%idsname%_LEVEL" $sfo_spell_levels("%idsname%")
		END
    END
    OUTER_SET SFO_internal_spells_read=1 
END

DEFINE_ACTION_FUNCTION data_internal_spell_resrefs//internal
    RET_ARRAY sfo_spell_resrefs
			  sfo_spell_levels
BEGIN
    SILENT
    // first get data from spell.ids
    COPY_EXISTING - spell.ids nowhere
        READ_2DA_ENTRIES_NOW spell_resref_entries 2
        FOR (this_row=0;this_row<spell_resref_entries;this_row +=1) BEGIN
            READ_2DA_ENTRY_FORMER spell_resref_entries this_row 1 idsname
            READ_2DA_ENTRY_FORMER spell_resref_entries this_row 0 idsnum
            PATCH_IF IS_AN_INT idsnum BEGIN
				INNER_PATCH_SAVE idsref "%idsnum%" BEGIN
					 SET $sfo_spell_levels("%idsname%")="-1"
					 REPLACE_EVALUATE "\([12]\)\([1-9]\)\([0-9][0-9]\)" BEGIN
						SET $sfo_spell_levels("%idsname%")="%MATCH2%"					
					 END
					 "%MATCH1%%MATCH2%%MATCH3%"
					 REPLACE_TEXTUALLY "1\([0-9][0-9][0-9]\)" "SPPR\1"
					 REPLACE_TEXTUALLY "2\([0-9][0-9][0-9]\)" "SPWI\1"
					 REPLACE_TEXTUALLY "3\([0-9][0-9][0-9]\)" "SPIN\1"
					 REPLACE_TEXTUALLY "4\([0-9][0-9][0-9]\)" "SPCL\1"
				END
				TO_UPPER idsref
                SPRINT $sfo_spell_resrefs("%idsname%") "%idsref%"
            END
        END
    BUT_ONLY
	// add data from dw_ext_spell.ids
	ACTION_IF FILE_EXISTS "%data_loc_shared%/dw_ext_spell.ids" BEGIN
		COPY - "%data_loc_shared%/dw_ext_spell.ids" nowhere
		   READ_2DA_ENTRIES_NOW extra_spell_resref_entries 2
			FOR (this_row=0;this_row<extra_spell_resref_entries;this_row +=1) BEGIN
				READ_2DA_ENTRY_FORMER extra_spell_resref_entries this_row 1 idsname
				READ_2DA_ENTRY_FORMER extra_spell_resref_entries this_row 0 idsref
				TO_UPPER idsref
				SPRINT $sfo_spell_resrefs("%idsname%") "%idsref%"
				INNER_PATCH "%idsref%" BEGIN
					REPLACE_EVALUATE "\(SPPR\|SPWI\)\([1-9]\)" BEGIN
						SET $sfo_spell_levels("%idsname%")="%MATCH2%"
					END
					""
				END
			END			
		BUT_ONLY
	END
	// add some bespoke ones
	ACTION_IF FILE_EXISTS "%MOD_FOLDER%/%sfo_library_path%/data/extra_spell_ids.txt" BEGIN
		LAF array_read STR_VAR file=extra_spell_ids.txt locbase="%sfo_library_path%/data" RET_ARRAY bespoke_ids=array END
	END ELSE BEGIN
		LAF array_read INT_VAR inline=1 STR_VAR file=".../stratagems-inline/extra_spell_ids.txt" RET_ARRAY bespoke_ids=array END
	END
	ACTION_PHP_EACH bespoke_ids AS idsname=>idsref BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME "%resref%.spl" BEGIN
			COPY_EXISTING - "%resref%.spl" nowhere
				READ_LONG 0x34 level
				SET $sfo_spell_levels("%idsname%")=level
			BUT_ONLY
		END
		OUTER_SPRINT $sfo_spell_resrefs("%idsname%") "%idsref%"
		
	END
END

///////////////////////////////////////////////////////////////////////////////
/*
document{data_scroll_resrefs}
{
Reads in every divine and arcane
spell, and stores them like this:

WIZARD_FIREBALL_SCROLL=scrl1g
$sfo_arcane_scrolls("WIZARD_FIREBALL")=scrl1g
CLERIC_FREE_ACTION_SCROLL=scrl58
$sfo_divine_scrolls("CLERIC_FREE_ACTION")=scrl58
}
*/
///////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_scroll_resrefs
BEGIN
	LOCAL_SPRINT idsname ""
	LOCAL_SPRINT resref ""
	LAF data_internal_scroll_resrefs RET_ARRAY sfo_arcane_scrolls sfo_divine_scrolls END
    ACTION_PHP_EACH sfo_arcane_scrolls AS idsname=>resref BEGIN
        OUTER_SPRINT "%idsname%_SCROLL" "%resref%"
    END
    ACTION_PHP_EACH sfo_divine_scrolls AS idsname=>resref BEGIN
        OUTER_SPRINT "%idsname%_SCROLL" "%resref%"
    END
END


DEFINE_ACTION_FUNCTION data_internal_scroll_resrefs//internal
    RET_ARRAY sfo_arcane_scrolls
              sfo_divine_scrolls
BEGIN
    SILENT
	ACTION_IF !VARIABLE_IS_SET SFO_internal_spells_read BEGIN
		FAIL "data_scroll_resrefs requires data_spell_resrefs to have been run"
	END
    // go through the item files
    COPY_EXISTING_REGEXP ".*\.itm" override
        // handle TUTU file conventions, we want "_SCRL" prioritised over "SCRL"
        PATCH_IF FILE_EXISTS_IN_GAME ~_%SOURCE_RES%.itm~ BEGIN
           SPRINT filename ~_%SOURCE_RES%~
        END ELSE BEGIN
           SPRINT filename ~%SOURCE_RES%~
        END
        TO_LOWER filename
        PATCH_MATCH "%filename%" WITH
        TTSCRL01 TTSCRL02 BEGIN END // tutorial scrolls - skip them
        DEFAULT
			INNER_ACTION BEGIN
				// the core spell edit
				COPY_EXISTING - ~%filename%.itm~ nowhere
					PATCH_IF SHORT_AT 0x1c=11 BEGIN // scroll
						PATCH_IF (INDEX_BUFFER (CASE_INSENSITIVE SPWI)>=0 || INDEX_BUFFER (CASE_INSENSITIVE SPPR)>=0) BEGIN // probably a spell scroll, go through carefully
							SET success=0
							GET_OFFSET_ARRAY ab_arr ITM_V10_HEADERS
							PHP_EACH ab_arr AS ab_ind=>ab_off BEGIN
								GET_OFFSET_ARRAY2 fx_arr ab_off ITM_V10_HEAD_EFFECTS
								PHP_EACH fx_arr AS fx_ind=>fx_off BEGIN
									READ_SHORT fx_off opcode
									PATCH_IF (opcode=146 || opcode=147 || opcode=148) & !success BEGIN
										SET success=1
										READ_ASCII (0x14 + fx_off) resref
										TO_UPPER resref
										SPRINT $internal_scroll_map("%resref%") "%filename%"
									END
								END
							END
						END
					END
				BUT_ONLY // end of the core spell edit
			END // end of inner_action
        END
    BUT_ONLY // end of the outer item edit
	// match up the arrays
    ACTION_PHP_EACH sfo_spell_resrefs AS idsname=>resref BEGIN
        ACTION_IF VARIABLE_IS_SET $internal_scroll_map("%resref%") BEGIN
			ACTION_MATCH "%idsname%" WITH 
			"WIZARD_.*" BEGIN
				  OUTER_SPRINT $sfo_arcane_scrolls("%idsname%") $internal_scroll_map("%resref%")
			END
			"CLERIC_.*" BEGIN
				  OUTER_SPRINT $sfo_divine_scrolls("%idsname%") $internal_scroll_map("%resref%")
			END
			DEFAULT 
			END
        END
    END
END

///////////////////////////////////////////////////////////////////////////////
/*
document{data_thac0}
{
Read in thac0 for all classes and store in a 2da, in the form 
$sfo_thac0("class" "level")=n
}
*/
///////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_thac0

BEGIN
	LAF 2da_read STR_VAR file=thac0.2da case=lower RET_ARRAY sfo_thac0=array END
	OUTER_SET sfo_thac0_read=1
END



///////////////////////////////////////////////////////////////////////////////
/*
document{data_saving_throws}
{
Read in saving throws for all classes and store in a 3da, in the form 
$sfo_saves("class" "level" "type")=n

Here type is 'poison','wands','polymorph','breath', or 'spells', and class is lowercased.
}
*/
///////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_saving_throws 
BEGIN
	LOCAL_SPRINT type ""
	LOCAL_SPRINT class ""
	LOCAL_SPRINT n ""
	LOCAL_SPRINT savetype ""
	ACTION_CLEAR_ARRAY class_map
	ACTION_CLEAR_ARRAY save_name_map
	OUTER_SET sfo_saves_read=1
	ACTION_DEFINE_ASSOCIATIVE_ARRAY class_map BEGIN
        mage=> WIZ
        fighter=> WAR
        cleric=> PRS
        thief=> ROG
        bard=> ROG
        paladin=> WAR
        druid=> PRS
        ranger=> WAR
        monk=> MONK
        sorcerer=> WIZ
		shaman=>PRS
	END
	ACTION_DEFINE_ASSOCIATIVE_ARRAY save_name_map BEGIN
		DEATH=>death
		WANDS=>wands
		POLY=>polymorph
		BREATH=>breath
		SPELL=>spells
	END
	ACTION_FOR_EACH type IN WIZ WAR PRS ROG MONK BEGIN
		SILENT
		LAF 2da_read STR_VAR file="SAVE%type%.2da" rowmap="value:=$save_name_map(~__~)" RET_ARRAY "SFO_reserved_array_%type%"=array SFO_reserved_columns=columns SFO_reserved_rows=rows END
	END
	VERBOSE
	ACTION_PHP_EACH class_map AS class=>type BEGIN
		ACTION_PHP_EACH SFO_reserved_columns AS n=>discard BEGIN
			ACTION_PHP_EACH SFO_reserved_rows AS savetype=>discard2 BEGIN
				OUTER_SET "sfo_saves_%class%_%n%_%savetype%" = $"SFO_reserved_array_%type%"("%savetype%" "%n%")
			END
		END
	END
	ACTION_CLEAR_ARRAY class_map
	ACTION_CLEAR_ARRAY save_name_map
END

///////////////////////////////////////////////////////////////////////////////
/*
document{data_spells_by_level}
{
Read in spell slots for all classes and store in a struct 'sfo_spell_level', in the form

sfo_spell_level_%class%_%level%_%spell_level%"=n (# spells known at level)
sfo_spell_level_sl_to_cl_%class%_%level%=n (minimum level at which caster gets spells of this level)
sfo_spell_level_cl_to_sl_%class%_%level%=n (maximum level of spells known at caster level)
sfo_spell_level_max_%class%=n (max level of spells known)

}
*/
///////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_spells_by_level

BEGIN
	LOCAL_SPRINT type ""
	LOCAL_SPRINT k ""
	LOCAL_SPRINT v ""
	LOCAL_SPRINT class ""
	LOCAL_SET spell_level=0
	LOCAL_SET class_level=0
	LOCAL_SET max=0
	LOCAL_SET max_global=0
	LOCAL_SET n=0
	ACTION_IF !VARIABLE_IS_SET sfo_data_spells_by_level_set BEGIN
		OUTER_SET sfo_data_spells_by_level_set=1
		ACTION_CLEAR_ARRAY SFO_reserved_data_class_map
		ACTION_DEFINE_ASSOCIATIVE_ARRAY SFO_reserved_data_class_map BEGIN
			mage=> WIZ
			fighter=> "NULL"
			cleric=> PRS
			thief=> "NULL"
			bard=> BRD
			paladin=> PAL
			druid=> DRU
			ranger=> RAN
			monk=> "NULL"
			sorcerer=> SRC
			shaman=>SHM
		END
		SILENT
		ACTION_IF !VARIABLE_IS_SET enhanced_edition BEGIN
			OUTER_SET enhanced_edition=GAME_IS "BGEE BG2EE IWDEE EET"
		END
		ACTION_FOR_EACH type IN WIZ PRS BRD PAL RAN SRC DRU SHM BEGIN
			ACTION_IF "%type%" STR_CMP "SHM" || enhanced_edition BEGIN 
				COPY_EXISTING - "MXSPL%type%.2da" nowhere
					COUNT_2DA_COLS colcount
					READ_2DA_ENTRIES_NOW mxspl_data colcount
					READ_2DA_ENTRIES_NOW mxspl_headers (colcount - 1)
					CLEAR_ARRAY col_headers
					FOR (col=1;col<colcount;++col) BEGIN
						READ_2DA_ENTRY_FORMER mxspl_headers 0 (col - 1) col_header
						SPRINT $col_headers("%col%") "%col_header%"
					END
					FOR (row=0;row<mxspl_data;++row) BEGIN
						READ_2DA_ENTRY_FORMER mxspl_data row 0 row_header
						PHP_EACH col_headers AS col=>col_header BEGIN
							READ_2DA_ENTRY_FORMER mxspl_data row col data
							SPRINT $"sfo_mxspl_%type%"("%row_header%" "%col_header%") "%data%"
						END
					END
				BUT_ONLY
			END
		END
		VERBOSE
		ACTION_PHP_EACH SFO_reserved_data_class_map AS class=>type BEGIN
			// get the main array
			OUTER_FOR (class_level=1;class_level<=50;++class_level) BEGIN
				OUTER_FOR (spell_level=1;spell_level<=9;++spell_level) BEGIN
				//	OUTER_SET $sfo_spell_level("%class%" "%class_level%" "%spell_level%")=0
				//OUTER_SET $"sfo_spell_level_%class%"("%class_level%" "%spell_level%")=0
				OUTER_SET "sfo_spell_level_%class%_%class_level%_%spell_level%"=0
				END
			END
			ACTION_PHP_EACH "sfo_mxspl_%type%" AS k=>v BEGIN
				OUTER_SET "sfo_spell_level_%class%_%k_0%_%k_1%"=v
			END
			 // infer the maxima
			 
			OUTER_SET max_global=0
			OUTER_SET max=0
			OUTER_FOR (n=1;n<=9;++n) BEGIN
				OUTER_SET "sfo_spell_level_sl_to_cl_%class%_%n%"=99
			END
			OUTER_FOR (class_level=1;class_level<=50;++class_level) BEGIN
				// intentionally don't reset max, it's nondecreasing
				OUTER_FOR (spell_level=max+1;spell_level<=9;++spell_level) BEGIN
					ACTION_IF "sfo_spell_level_%class%_%class_level%_%spell_level%">0 BEGIN
						OUTER_SET max=spell_level // take advantage of no gaps
						OUTER_SET max_global=spell_level
						ACTION_IF "sfo_spell_level_sl_to_cl_%class%_%spell_level%"=99 BEGIN
							OUTER_SET "sfo_spell_level_sl_to_cl_%class%_%spell_level%"=class_level
						END
					END
				END
				OUTER_SET "sfo_spell_level_cl_to_sl_%class%_%class_level%"=max
			END
			OUTER_SET "sfo_spell_level_max_%class%"=max_global
			
		END
	END
	
END

///////////////////////////////////////////////////////////////////////
/*
document{data_priest_spells}
{
Return arrays "sfo_druid_spells" and "sfo_cleric_[alignment]_spells_n", containing the learnable cleric and druid spells of in resref=>level form.
[alignment] is each of the nine alignments as presented in align.ids, lowercased. Arrays are ordered from highest to lowest level and from highest-numbered
to lowest-numbered spell (this facilitates correctly (or at least intuitively) ordering the learned-spell lists if we use cre_quickset_known_spells).
}

*/
///////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_priest_spells
BEGIN
	SILENT
	LAF data_priest_spells_core 
	RET_ARRAY sfo_cleric_lawful_good_spells
			  sfo_cleric_neutral_good_spells
			  sfo_cleric_chaotic_good_spells
			  sfo_cleric_lawful_neutral_spells
			  sfo_cleric_neutral_spells
			  sfo_cleric_chaotic_neutral_spells
			  sfo_cleric_lawful_evil_spells
			  sfo_cleric_neutral_evil_spells
			  sfo_cleric_chaotic_evil_spells
			  sfo_druid_spells 
	END
	VERBOSE
	OUTER_SET sfo_data_priest_spells_loaded=1
END

DEFINE_ACTION_FUNCTION data_priest_spells_core//internal
	RET_ARRAY sfo_cleric_lawful_good_spells
			  sfo_cleric_neutral_good_spells
			  sfo_cleric_chaotic_good_spells
			  sfo_cleric_lawful_neutral_spells
			  sfo_cleric_neutral_spells
			  sfo_cleric_chaotic_neutral_spells
			  sfo_cleric_lawful_evil_spells
			  sfo_cleric_neutral_evil_spells
			  sfo_cleric_chaotic_evil_spells
			  sfo_druid_spells
BEGIN
	// load hidespl (note that 2.6 doesn't use the is_final thing)
	ACTION_IF FILE_EXISTS_IN_GAME "hidespl.2da" BEGIN
		LAF 2da_read STR_VAR file=hidespl.2da RET_ARRAY rows array END
		ACTION_IF enhanced_edition BEGIN
			LAF 2da_extract_array STR_VAR array range=IS_HIDDEN RET_ARRAY hidden_spells=array END
		END ELSE BEGIN
			ACTION_PHP_EACH rows AS k=>v BEGIN
				OUTER_SET $hidden_spells("%k%")=1
			END	
		END
	END
	// go through the spells
	OUTER_FOR (level=7;level>=1;level=level - 1) BEGIN
		OUTER_SET max=enhanced_edition?50:(level=7?20:50)
		OUTER_FOR (number=level*100+max;number>=level*100+1;number=number - 1) BEGIN
			OUTER_SPRINT resref "SPPR%number%"
			ACTION_IF FILE_EXISTS_IN_GAME "%resref%.spl" && (!VARIABLE_IS_SET $hidden_spells("%resref%") || $hidden_spells("%resref%")=0 ) BEGIN
				COPY_EXISTING - "%resref%.spl" nowhere
					READ_BYTE 0x21 usable_class
					usable_druid=((usable_class BAND 0b10000000) = 0)
					usable_cleric=((usable_class BAND 0b01000000) = 0)
					PATCH_IF usable_druid BEGIN
						SET $sfo_druid_spells("%resref%")=level
					END
					PATCH_IF usable_cleric BEGIN
					READ_BYTE 0x1e alignment
						PATCH_IF ((alignment BAND 0b00010100)=0) BEGIN
							SET $sfo_cleric_lawful_good_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00100100)=0) BEGIN
							SET $sfo_cleric_neutral_good_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00000101)=0) BEGIN
							SET $sfo_cleric_chaotic_good_spells("%resref%")=level
						END						
						PATCH_IF ((alignment BAND 0b00011000)=0) BEGIN
							SET $sfo_cleric_lawful_neutral_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00101000)=0) BEGIN
							SET $sfo_cleric_neutral_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00001001)=0) BEGIN
							SET $sfo_cleric_chaotic_neutral_spells("%resref%")=level
						END						
						PATCH_IF ((alignment BAND 0b00010010)=0) BEGIN
							SET $sfo_cleric_lawful_evil_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00100010)=0) BEGIN
							SET $sfo_cleric_neutral_evil_spells("%resref%")=level
						END
						PATCH_IF ((alignment BAND 0b00000011)=0) BEGIN
							SET $sfo_cleric_chaotic_evil_spells("%resref%")=level
						END	
					END
				//BUT_ONLY
			
			
			END
		END
		
	END

END

///////////////////////////////////////////////////////////////////////
/*
document{data_joinable_dvs}
{
Returns the array 'sfo_joinable_dvs', in k=>_ form, containing the lowercased dvs of all joinable creatures
}

*/
///////////////////////////////////////////////////////////////////////

DEFINE_ACTION_MACRO data_joinable_dvs BEGIN
	LAF data_joinable_dvs_core RET_ARRAY sfo_joinable_dvs END
	OUTER_SET sfo_data_joinable_dvs_loaded=1
END

DEFINE_ACTION_FUNCTION data_joinable_dvs_core//internal
	RET_ARRAY sfo_joinable_dvs
BEGIN
	// main npcs
	LAF 2da_read STR_VAR file=pdialog.2da case=lower RET_ARRAY sfo_joinable_dvs=rows END
	// campaign npcs
	ACTION_IF FILE_EXISTS_IN_GAME "campaign.2da" BEGIN
		COPY_EXISTING - campaign.2da nowhere
			COUNT_2DA_ROWS 0 rowcount 
			PATCH_IF rowcount>3 BEGIN
				LPF 2da_read RET_ARRAY campaign_array=array END
				LPF 2da_extract_array STR_VAR array=campaign_array range=PDIALOG RET_ARRAY pdialog_array=array END
				INNER_ACTION BEGIN
					ACTION_PHP_EACH pdialog_array AS file=>discard BEGIN
						ACTION_IF FILE_EXISTS_IN_GAME "%file%.2da" BEGIN
							LAF 2da_read STR_VAR file="%file%.2da" caet=lower RET_ARRAY rows END
							LAF array_join STR_VAR array1=sfo_joinable_dvs array2=rows RET_ARRAY sfo_joinable_dvs=array END
						END
					END
				END
			END
		BUT_ONLY
	END
	// the tutorial NPCs from Candlekeep
	ACTION_IF is_bg1 BEGIN
		ACTION_FOR_EACH dv IN arkanis canderous deder mordaine osprey BEGIN
			OUTER_SPRINT $sfo_joinable_dvs("%dv%") ""
		END
	END
	// set all values to ""
	ACTION_PHP_EACH sfo_joinable_dvs AS k=>v BEGIN
		OUTER_SPRINT $sfo_joinable_dvs("%k%") ""
	END

END



/*
describe-library{
Functions here should be pure functions (no side effects, no reference to external data) and so should all be dimorphic. No specific naming convention.
Be cautious putting functions in here.

Functions here should have no dependencies outside lib_fn.
}



*/

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{return_first_entry}
{
Given a list of strings (separated by spaces, either bare or in "" or ~~ quotes), return the first entry, and the rest of the list. If 'separator' is specified,
use it instead of space to separate strings. (It should be a single character.) If you use ' ' as a separator, newlines and tabs are replaced by spaces in processing the string
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION return_first_entry
	 STR_VAR list=""
			 separator=" "
     RET     entry
             list
BEGIN
	ACTION_IF "%separator%" STR_EQ "" BEGIN
		FAIL "return_first_entry called with empty separator (list=%list%)"
	END
	ACTION_IF "%separator%" STR_EQ " " BEGIN
		OUTER_PATCH_SAVE list "%list%" BEGIN
			REPLACE_TEXTUALLY "[%WNL%%LNL%%MNL%%TAB%]+" " "
		END
	END
	LAF trim_string STR_VAR string="%list%" character="%separator%" RET list=string END
	OUTER_PATCH_SAVE list "%list%" BEGIN
		PATCH_IF BUFFER_LENGTH=0 BEGIN
			SPRINT entry ""
			SPRINT list ""
			PATCH_WARN "return_first_entry called on empty string"
		END ELSE BEGIN
		// get the first character, to check version
			pointer=0
			done=0
			in_tilde_quote=0
			in_quote=0
			WHILE !done BEGIN
			// get the character
				READ_ASCII pointer char (1)
			// match it
				PATCH_MATCH "%char%" WITH
				"%separator%" BEGIN
					// if we're not in quote context, we're done. If we are, ignore it.
					PATCH_IF !in_quote && !in_tilde_quote BEGIN
						done=1
					END
				END
				~"~ BEGIN
					// toggle quote context
					in_quote=!in_quote
				END
				"~"BEGIN
					// toggle quote context
					in_tilde_quote=!in_tilde_quote
				END
				DEFAULT
				END
				// advance the pointer
				++pointer
				PATCH_IF pointer=BUFFER_LENGTH BEGIN
					done=1
					++pointer
				END 
			END
			// extract the string
			READ_ASCII 0x0 entry (pointer - 1)
			DELETE_BYTES 0x0 (pointer - 1)
			
		END


	END
	LAF trim_string STR_VAR string="%list%" character="%separator%" RET list=string END
	LAF trim_string STR_VAR string="%entry%" character="%separator%" RET entry=string END
	OUTER_PATCH_SAVE entry "%entry%" BEGIN
		REPLACE_TEXTUALLY "^~\(.*\)~$" "\1"
		REPLACE_TEXTUALLY ~^"\(.*\)"$~ "\1"
	END
END

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{trim_string}
{
Given a single string, and a character (space by default) remove any occurrences of the character from the beginning and end of the string.
If require_both=1, only strip if the character appears at beginning and end (and only strip one).
*/
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION trim_string
	INT_VAR require_both=0
	STR_VAR character=" " 
			string=""
	RET string
BEGIN
	OUTER_PATCH_SAVE string "%string%" BEGIN
		ind=INDEX_BUFFER ("%character%")
		PATCH_IF !require_both BEGIN
			WHILE ind=0 BEGIN
				DELETE_BYTES 0x0 1
				ind=INDEX_BUFFER ("%character%")
			END
			 
			rind=RINDEX_BUFFER ("%character%")
			len=BUFFER_LENGTH
			WHILE len>0 && rind=len - 1 BEGIN
				DELETE_BYTES (BUFFER_LENGTH - 1) 1
				rind=RINDEX_BUFFER ("%character%")
				len=BUFFER_LENGTH
			END
		END ELSE BEGIN
			PATCH_IF BUFFER_LENGTH>=2 BEGIN
				READ_ASCII 0x0 lchar (1)
				READ_ASCII BUFFER_LENGTH -1 rchar (1)
				PATCH_IF "%lchar%" STR_EQ "%character%" && "%rchar%" STR_EQ "%character%" BEGIN
					DELETE_BYTES BUFFER_LENGTH - 1 1
					DELETE_BYTES 0x0 1
				END
			END
		END
	END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{return_first_pair}
{
Given a string in the form 'key=>value list', return the first key, the first value, and the rest of the string. if 'arrow' is specified, its value is used in place of 
'=>' to separate key-value pairs. 'key' and 'value' can be bare strings or can be wrapped in "" or ~~.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION return_first_pair
     STR_VAR list=""
             arrow="=>"
     RET list
         key
         value

BEGIN
	OUTER_PATCH_SAVE list ~%list%~ BEGIN REPLACE_TEXTUALLY ~%arrow%~ ~ %arrow% ~ END
     // we can now treat the list as an ordinary list. Return the first entry, discard the second (which should be =>), return the third
     LAF return_first_entry STR_VAR list RET list key=entry END
     LAF return_first_entry STR_VAR list RET list discard=entry END
     ACTION_IF ~%discard%~ STR_CMP ~%arrow%~ BEGIN
        WARN "Warning: it looks as if some entry that should be a key%arrow%value list, isn't (~list~ is currently %list%, key=%key%)"
     END
     LAF return_first_entry STR_VAR list RET list value=entry END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{tolower}
{
Given a string, return it in lower case. (This is for use in functional programming - WEIDU's TO_LOWER suffices for first-order code.)
}

document{toupper}
{
Given a string, return it in upper case.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION tolower STR_VAR arguments="" RET value BEGIN OUTER_SPRINT value "%arguments%" ACTION_TO_LOWER value END
DEFINE_DIMORPHIC_FUNCTION toupper STR_VAR arguments="" RET value BEGIN OUTER_SPRINT value "%arguments%" ACTION_TO_UPPER value END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{eval}
{
Given a string, return its value if it's a variable, or the string itself if not.
Also permits 'argument'->'value' interface.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION eval
	STR_VAR var=""
			arguments=""
	RET var value
BEGIN
	ACTION_IF "%var%" STR_EQ "" BEGIN
		OUTER_SPRINT var "%arguments%"
	END
	ACTION_IF VARIABLE_IS_SET "%var%" BEGIN
		OUTER_SPRINT var EVAL "%%var%%"
	END 
	OUTER_SPRINT value "%var%"
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{point_in_bounds}
{
Determine whether (x,y) are inside the rectangle with bottom left point (xmin,ymin) and top right point (xmax,ymax)
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_DIMORPHIC_FUNCTION point_in_bounds
   INT_VAR x=0
           xmin=0
           xmax=0
           y=0
           ymin=0
           ymax=0
   RET in_bounds
       x_in_bounds
       y_in_bounds
BEGIN
   OUTER_SET x_in_bounds=(x>=xmin && x<=xmax ? 1 : 0) || (x<0)
   OUTER_SET y_in_bounds=(y>=ymin && y<=ymax ? 1 : 0) || (y<0)
   OUTER_SET in_bounds = x_in_bounds * y_in_bounds
END

//////////////////////////////////////////
/*
document{divide_round_up}
{
Divide two numbers, rounding up
any remainder
}
*/
//////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION divide_round_up
   INT_VAR numerator=0
           denominator=0
   RET value
BEGIN
	OUTER_PATCH "" BEGIN
   PATCH_IF (numerator / denominator) * denominator = numerator BEGIN
      SET value = numerator / denominator
   END ELSE BEGIN
      SET value = (numerator / denominator) + 1
   END
   END
END


//////////////////////////////////////////
/*
document{invert_string}
{
Break 'string' into 'block_size'xN substrings,
and invert the order of those substrings. }
*/
//////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION invert_string
    INT_VAR block_size=0
    STR_VAR string=""
    RET string
BEGIN	
	OUTER_PATCH "" BEGIN
    SET number=(STRING_LENGTH "%string%") / block_size
    SPRINT string_old "%string%"
    SPRINT string ""
    INNER_PATCH "%string_old%" BEGIN
      FOR (n=0;n<number;n+=1) BEGIN
          SET index=n*block_size
          READ_ASCII index data (block_size)
          SPRINT string "%data%"^"%string%"
      END
    END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*

document{ensure_hex}
{
Forces the string 'in' into hex form and passes it as 'out'. If pad_length is set to a non-zero value, ensure the hex is (at least) that long.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION ensure_hex
     INT_VAR pad_length=0
     STR_VAR in=""
     RET out
BEGIN
	OUTER_PATCH "" BEGIN
      SNPRINT 2 check "%in%"
      PATCH_IF "%check%" STRING_EQUAL_CASE "0x" BEGIN
         PATCH_IF pad_length>0 BEGIN
            INNER_PATCH_SAVE in "%in%" BEGIN
               DELETE_BYTES 0x0 2
            END
            WHILE pad_length>STRING_LENGTH "%in%" BEGIN
               SPRINT in "0%in%"
            END
            SPRINT in "0x%in%"
         END
         TO_LOWER in
         SPRINT out "%in%"
      END ELSE BEGIN
         LPF hexify INT_VAR in pad_length RET out END
      END
	END
END

DEFINE_PATCH_FUNCTION hex_digit//internal
    INT_VAR digit=0
    RET out
BEGIN
   PATCH_IF (digit>=16 || digit<0) BEGIN
            INNER_ACTION BEGIN
               FAIL "not a digit"
            END
   END
   PATCH_CLEAR_ARRAY hex_digit_map
   DEFINE_ASSOCIATIVE_ARRAY hex_digit_map BEGIN
      15=>f
      14=>e
      13=>d
      12=>c
      11=>b
      10=>a
   END
   PATCH_IF VARIABLE_IS_SET $hex_digit_map("%digit%") BEGIN
      SPRINT out $hex_digit_map("%digit%")
   END ELSE BEGIN
      SPRINT out "%digit%"
   END
END

DEFINE_PATCH_FUNCTION hexify//internal
    INT_VAR in=0
            pad_length=0
    STR_VAR out=""
    RET out
BEGIN
   SET div=in / 16
   SET digit=in - (div * 16)
   LPF hex_digit INT_VAR digit RET char=out END
   SPRINT out "%char%%out%"
   PATCH_IF div>0 BEGIN
      LPF hexify INT_VAR in= "%div%" pad_length STR_VAR out RET out=out  END
   END ELSE BEGIN
      WHILE pad_length>STRING_LENGTH "%out%" BEGIN
         SPRINT out "0%out%"
      END
      SPRINT out "0x%out%"


   END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*

document{despecialize}
{
Take a string, and return it with any WEIDU regexp special characters escaped out.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION despecialize 
	STR_VAR string=""
	RET string
BEGIN
	OUTER_PATCH_SAVE string "%string%" BEGIN
		PATCH_FOR_EACH spc IN "\" "$" "^" "." "*" "+" "?" "[" "]"  BEGIN
			REPLACE_TEXTUALLY EXACT_MATCH "%spc%" "\%spc%"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{tolower_safe}
{
Convert the (assumed mixed-case) string to lowercase, skipping any accented characters
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION tolower_safe
	STR_VAR arguments=""
	RET value
BEGIN
	OUTER_SPRINT value ""
	OUTER_PATCH "%arguments%" BEGIN
		len=BUFFER_LENGTH
		WHILE len>0 BEGIN
			READ_ASCII 0x0 char (1)
			PATCH_MATCH "%char%" WITH 
			"[A-Z]" BEGIN
				TO_LOWER char
			END
			DEFAULT
			END
			SPRINT value "%value%%char%"
			DELETE_BYTES 0x0 1
			len -=1
		END
	END
END

/*
document{ext}
{Returns the extension of the currently-being-patched file, if we can tell.
(we can tell for 2da, are, chr, cre, dlg, gam, itm, pro, spl, sto, vef, vvc, wed, and wmp)
Also return its version

By default we return lowercase; if you want it in uppercase, set uppercase=1.
}

*/

DEFINE_PATCH_FUNCTION ext 
	INT_VAR uppercase=0//boolean 
	RET ext 
		version
BEGIN

	READ_ASCII 0x0 ext (3)
	READ_ASCII 0x4 version (4)
	INNER_PATCH_SAVE version "%version%" BEGIN
		REPLACE_TEXTUALLY " " ""
	END
	PATCH_MATCH "%ext%" WITH
	2da are chr cre dlg gam itm pro spl sto vef vvc wed
	BEGIN END
	wma BEGIN
		SPRINT ext wmp
	END	
	DEFAULT
		PATCH_WARN "unable to identify file type; defaulting to '' " 
		SPRINT ext ""
		SPRINT version ""
	END
	PATCH_IF uppercase BEGIN
		TO_UPPER ext
		TO_UPPER version
	END ELSE BEGIN
		TO_LOWER ext
		TO_LOWER version
	END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{merge_scripts}
{
If both 'top' and 'bottom' exist, merge them into a new script, and give it a guaranteed-unique name unless a name
is specified. In any case, return the name.
If one doesn't exist, return the name of the other.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION merge_scripts
   STR_VAR top=""
           bottom=""
           script=""
   RET script
BEGIN
	ACTION_IF FILE_EXISTS_IN_GAME "%top%.bcs" BEGIN
		ACTION_IF FILE_EXISTS_IN_GAME "%bottom%.bcs" BEGIN
			ACTION_IF "%script%" STR_EQ "" BEGIN
				LAF GET_UNIQUE_FILE_NAME STR_VAR extension=bcs RET script=filename END
			END
			COPY_EXISTING "%bottom%.bcs" "%workspace%/%bottom%.baf"
				DECOMPILE_BCS_TO_BAF
			COPY_EXISTING "%top%.bcs" "override/%script%.bcs"
				DECOMPILE_BCS_TO_BAF
				APPEND_FILE TEXT "%workspace%/%bottom%.baf"
			COMPILE_BAF_TO_BCS
		END ELSE BEGIN
			OUTER_SPRINT script "%top%"
		END
	END ELSE BEGIN
		OUTER_SPRINT script "%bottom%"
	END

END




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{insert_script}
{
Given a numbered-from-0 array of scripts 'script_array', and a new  script 'script' (synonym: 'arguments'), insert the new script in position 'loc'. 
Insert position can be 'high', 'low', 'after x' (defaults to 'high' if
x isn't present), or 'before x' (defaults to 'low' if x isn't present).
If there isn't space, merge the two lowest scripts to make space.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION insert_script
	STR_VAR script_array=""
			script=""
			arguments=""
			loc=""
	RET_ARRAY script_array
BEGIN
	OUTER_PATCH "" BEGIN
		SPRINT script "%arguments%%script%"
		// write into new array
		PHP_EACH "%script_array%" AS k=>v BEGIN
			SPRINT $script_array("%k%") "%v%"
		END
		LPF array_length STR_VAR array=script_array RET length END
		// check for space
		space=0
		PHP_EACH script_array AS ind=>this_script BEGIN
			PATCH_MATCH "%this_script%" WITH
			"" "none" "null" BEGIN
				space=1
			END
			DEFAULT
			END
		END
		// if necessary, make space
		PATCH_IF !space BEGIN
			i1=length - 2
			i2=length - 1
			SPRINT top $script_array("%i1%")
			SPRINT bottom $script_array("%i2%")
			LPF merge_scripts STR_VAR top bottom RET new_script=script END
			SPRINT $script_array("%i1%") "%new_script%"
			SPRINT $script_array("%i2%") ""
		END
		// carry out insertion
		PATCH_MATCH "%loc%" WITH
		low BEGIN
			SPRINT buffer "%script%"
			FOR (ind=length - 1; ind>=0;ind=ind - 1) BEGIN
				SPRINT this_script $script_array("%ind%")
				PATCH_IF "%buffer%" STR_CMP "" BEGIN
					SPRINT $script_array("%ind%") "%buffer%"
					PATCH_MATCH "%this_script%" WITH
					"" "none" "null" BEGIN
						SPRINT buffer ""
					END
					DEFAULT
						SPRINT buffer "%this_script%"
					END				
				END			
			
			END
		END
		high BEGIN
			SPRINT buffer "%script%"
			PHP_EACH script_array AS ind=>this_script BEGIN
				PATCH_IF "%buffer%" STR_CMP "" BEGIN
					SPRINT $script_array("%ind%") "%buffer%"
					PATCH_MATCH "%this_script%" WITH
					"" "none" "null" BEGIN
						SPRINT buffer ""
					END
					DEFAULT
						SPRINT buffer "%this_script%"
					END				
				END			
			END
		END
		"after .*" BEGIN
			INNER_PATCH "%loc%" BEGIN
				REPLACE_EVALUATE "after \(.*\)" BEGIN
					SPRINT match_script "%MATCH1%"
				END
				""
			END
			// find index of 'match_script'
			match_index="-1"
			PHP_EACH script_array AS ind=>this_script BEGIN
				PATCH_IF "%this_script%" STR_EQ "%match_script%" BEGIN
					match_index=ind
				END
			END
			PATCH_IF match_index<0 BEGIN
				LPF insert_script STR_VAR script_array script loc=high RET_ARRAY script_array END
			END ELSE BEGIN
			// is there room below?
				space_below=0
				FOR (ind=match_index;ind<length;++ind) BEGIN
					SPRINT this_script $script_array("%ind%")
					PATCH_MATCH "%this_script%" WITH
					"" "none" "null" BEGIN
						space_below=1
					END
					DEFAULT
					END
				END
				PATCH_IF space_below BEGIN
					SPRINT buffer "%script%"
					FOR (ind=match_index+1;ind<length;++ind) BEGIN
						PATCH_IF "%buffer%" STR_CMP "" BEGIN
							SPRINT this_script $script_array("%ind%")
							SPRINT $script_array("%ind%") "%buffer%"
							PATCH_MATCH "%this_script%" WITH
							"" "none" "null" BEGIN
								SPRINT buffer ""
							END
							DEFAULT
								SPRINT buffer "%this_script%"
							END
						END
					
					END		
				END ELSE BEGIN
					// if there's no space below, there's space above
					SPRINT buffer "%script%"
					FOR (ind=match_index;ind>=0;ind=ind - 1) BEGIN
						PATCH_IF "%buffer%" STR_CMP "" BEGIN
							SPRINT this_script $script_array("%ind%")
							SPRINT $script_array("%ind%") "%buffer%"
							PATCH_MATCH "%this_script%" WITH
							"" "none" "null" BEGIN
								SPRINT buffer ""
							END
							DEFAULT
								SPRINT buffer "%this_script%"
							END
						END				
					END
				END
		
			END
		
		END
		"before .*" BEGIN
			INNER_PATCH "%loc%" BEGIN
				REPLACE_EVALUATE "before \(.*\)" BEGIN
					SPRINT match_script "%MATCH1%"
				END
				""
			END
			// find index of 'match_script'
			match_index="-1"
			PHP_EACH script_array AS ind=>this_script BEGIN
				PATCH_IF "%this_script%" STR_EQ "%match_script%" BEGIN
					match_index=ind
				END
			END
			PATCH_IF match_index<0 BEGIN
				LPF insert_script STR_VAR script_array script loc=low RET_ARRAY script_array END
			END ELSE BEGIN
			// is there room above?
				space_above=0
				FOR (ind=0;ind<=match_index;++ind) BEGIN
					SPRINT this_script $script_array("%ind%")
					PATCH_MATCH "%this_script%" WITH
					"" "none" "null" BEGIN
						space_above=1
					END
					DEFAULT
					END
				END
				PATCH_IF space_above BEGIN
					SPRINT buffer "%script%"
					FOR (ind=match_index - 1;ind>=0;ind=ind - 1) BEGIN
						PATCH_IF "%buffer%" STR_CMP "" BEGIN
							SPRINT this_script $script_array("%ind%")
							SPRINT $script_array("%ind%") "%buffer%"
							PATCH_MATCH "%this_script%" WITH
							"" "none" "null" BEGIN
								SPRINT buffer ""
							END
							DEFAULT
								SPRINT buffer "%this_script%"
							END
						END
					
					END		
				END ELSE BEGIN
					// if there's no space above, there's space below
					SPRINT buffer "%script%"
					FOR (ind=match_index;ind<length;++ind) BEGIN
						PATCH_IF "%buffer%" STR_CMP "" BEGIN
							SPRINT this_script $script_array("%ind%")
							SPRINT $script_array("%ind%") "%buffer%"
							PATCH_MATCH "%this_script%" WITH
							"" "none" "null" BEGIN
								SPRINT buffer ""
							END
							DEFAULT
								SPRINT buffer "%this_script%"
							END
						END				
					END
				END
		
			END
		
		END
		
		
		
		DEFAULT
			PATCH_WARN "unrecognised location %loc% in insert_script"
		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{install}
{
'arguments' (synonym: 'files'; synonym:'file') is a list of files (including extensions) located at the location given by path/location/locbase. Each is copied over to the override;
if any are BAF/D, they are COMPILE EVALUATE_BUFFERred; if they are SSL, they are compiled to BCS; if they are v1 CREs, we run FJ_CRE_EFF_V2 to force V2 effects. 
If none of 'location', 'locbase', and 'path' are set, set location=resource. 
If overwrite=0, don't overwrite already-present files (does not affect scripts).

If 'ext' (legacy synonym: 'postfix') is set, automatically add that file extension (so LAF install STR_VAR files="script1 script2" ext=baf ... END installs script1.baf and script2.baf).

If the argument is 'all', apply to every file at the path. 
If both 'ext' and 'all' are set, apply to every file at the path with that file extension.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION install
	INT_VAR overwrite=1//boolean
			inline=0//boolean
	STR_VAR arguments=""
			files=""
			file=""
			location=""
			locbase=""
			path=""
			postfix=""
			ext=""
BEGIN
	OUTER_SPRINT ext "%ext%%postfix%"
	ACTION_IF "%location%%locbase%%path%" STR_EQ "" BEGIN
		OUTER_SPRINT location resource
	END
	ACTION_IF "%files%%file%" STR_CMP "" BEGIN
		OUTER_SPRINT arguments "%files%%file%"
	END
	ACTION_IF inline BEGIN
		OUTER_SPRINT path ".../stratagems_inline"
	END ELSE BEGIN
		LAF sfo_path STR_VAR path location locbase RET path END
	END
	ACTION_IF "%arguments%" STR_EQ "all" BEGIN
		ACTION_IF "%ext%" STR_EQ "" BEGIN
			ACTION_BASH_FOR "%path%" ".*" BEGIN
				LAF install INT_VAR overwrite STR_VAR arguments="%BASH_FOR_FILE%" path END
			END		
		END ELSE BEGIN
			ACTION_BASH_FOR "%path%" ".*\.%ext%" BEGIN
				LAF install INT_VAR overwrite STR_VAR arguments="%BASH_FOR_FILE%" path END
			END			
		END
	END ELSE BEGIN		
		OUTER_WHILE "%arguments%" STR_CMP "" BEGIN
			LAF return_first_entry STR_VAR list="%arguments%" RET file=entry arguments=list END
			LAF sfo_path STR_VAR file path location locbase RET file_path END
			ACTION_IF "%ext%" STR_CMP "" BEGIN
				OUTER_SPRINT file "%file%.%ext%"
				OUTER_SPRINT file_path "%file_path%.%ext%"
			END
			ACTION_MATCH "%file%" WITH
			".*\.\(baf\|d\)" BEGIN
				COMPILE "%file_path%" EVALUATE_BUFFER
			END
			".*\.ssl" BEGIN
				OUTER_PATCH_SAVE script "%file%" BEGIN
					REPLACE_TEXTUALLY "\.ssl" ""
				END
				LAF ssl_to_bcs INT_VAR inline STR_VAR script location locbase path END
			END
			
			DEFAULT
				ACTION_IF overwrite || !FILE_EXISTS_IN_GAME "%file%" BEGIN
					COPY "%file_path%" override
						PATCH_IF "%SOURCE_EXT%" STR_EQ "cre" && BYTE_AT 0x33=0 BEGIN
							LPF FJ_CRE_EFF_V2 END
						END
				END
			END
		END
	END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{resolve_splprot_entry}
{
Given 'stat', 'val' (legacy synonym: 'value'), and either 'relation_number' or 'relation', return an appropriate entry in splprot.2da, adding
it if necessary. (see IESDP opcode documentation for opcode 324).</p>

<p>'Relation' can be:
<ul>
<li>'equals'/'equal' (resolves to 1)
<li>'less'/'less_than' (resolves to 2)
<li>'greater'/'greater_than' (resolves to 3)
<li>'less_than_equal'/'less_than_equals'/'less_equal' (resolves to 0)
<li>'greater_equal'/'greater_equals' (resolves to 4)
<li>'not_equal' (resolves to 5)
</ul>

<p>'description', if set, is added to the bare number of a new entry, following the 2.6 EE style. (Existing entries do not gain descriptions.)
}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION resolve_splprot_entry 
      INT_VAR 	stat=0
				val=0
				value=0
				relation_number=0
      STR_VAR 	relation=""
				description=""
      RET value
BEGIN
      ACTION_IF !(value=0) BEGIN
		OUTER_SET val=value
	  END
      ACTION_MATCH "%relation%" WITH
         equals equal BEGIN 
            OUTER_SET relation_number=1
         END
         greater greater_than BEGIN
            OUTER_SET relation_number=3
         END
         less less_than BEGIN
            OUTER_SET relation_number=2
         END
         greater_equal greater_equals BEGIN
            OUTER_SET relation_number= 4
         END
         less_than_equal less_equal less_than_equals BEGIN
            OUTER_SET relation_number=0
         END
         not_equal BEGIN
            OUTER_SET relation_number=5
         END
         "" BEGIN END
      DEFAULT
         LAF warning STR_VAR warning="unrecognised relation %relation% in resolve_splprot_entry; defaulting to 0" END
         OUTER_SET relation_number=0
      END
      COPY_EXISTING "splprot.2da" override
            READ_2DA_ENTRIES_NOW splprot_array 4
            SET value="-1"
            FOR (i=0;i<splprot_array;i+=1) BEGIN
                   READ_2DA_ENTRY_FORMER splprot_array i 1 this_stat
                   READ_2DA_ENTRY_FORMER splprot_array i 2 this_val
                   READ_2DA_ENTRY_FORMER splprot_array i 3 this_relation
                   PATCH_IF (IS_AN_INT this_stat && IS_AN_INT this_val && IS_AN_INT this_relation) BEGIN
                     PATCH_IF (stat=this_stat && val=this_val && relation_number=this_relation) BEGIN
                      SET value=i
                      SET i=splprot_array
                     END
                   END
            END
            PATCH_IF value<0 BEGIN
				PATCH_IF "%description%" STR_CMP "" BEGIN
					SPRINT row_label "%splprot_array%_%description%"
				END ELSE BEGIN
					SPRINT row_label "%splprot_array%"
				END
               INSERT_2DA_ROW splprot_array 4 "%row_label%%TAB%%stat%%TAB%%val%%TAB%%relation_number%"
               SET value=splprot_array
			   PRETTY_PRINT_2DA
            END
      BUT_ONLY
END

//////////////////////////////////////////////////////////////
/*
document{resolve_statdesc}
{
Adds a new line to statdesc.2da. You need to specify:
- the strref of a string, 'strref' (or you can specify the string
directly, 'string', and it will be added to dialog.tlk)
- the name ('bam') of the bam file to be used for the line. (It can be an in-game file, or
one to be copied over from your mod directory - SFO will see if it exists, and try to copy
it if it doesn't.)
- the location of the bam file, if it is in your mod directory, specified SFO-style via 'location','locbase','path'.
- the actual name to be used for the bam file, 'bam_name'. If you leave it blank, 'bam' will be used instead (always
do this if you are using an in-game file). If you set it to 'auto', a unique name will be auto-generated.

If you set the INT_VAR 'check_first', SFO will first check that line number to see if it exists. If it does, its line will
be returned and no new line will be added; however, the description will be set if it is currently blank.

}
*/
//////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION resolve_statdesc
	INT_VAR check_first="-1"
			strref="-1"
	STR_VAR string=""
			bam=""
			bam_name=""
			path=""
			location=""
			locbase=""
	RET stat_num
BEGIN
	COPY_EXISTING "statdesc.2da" override
		LPF 2da_read RET_ARRAY array END
		stat_num="-1"
		new="-1"
		PATCH_IF "%string%" STR_CMP "" BEGIN
			strref=RESOLVE_STR_REF ("%string%")
		END
		PATCH_IF VARIABLE_IS_SET $array("%check_first%" DESCRIPTION) BEGIN
			PATCH_IF $array("%check_first%" DESCRIPTION)=strref BEGIN
				stat_num=check_first
				new=0
			END ELSE
			PATCH_IF $array("%check_first%" DESCRIPTION)="-1" BEGIN
				SET $array("%check_first%" DESCRIPTION)=strref	
				stat_num=check_first
				new=1
			END 
		END
		PATCH_IF stat_num<0 BEGIN
			stat_num=200
			WHILE VARIABLE_IS_SET $array("%stat_num%" DESCRIPTION) BEGIN
				++stat_num
			END
			SET $array("%stat_num%" DESCRIPTION)=strref	
			new=1
		END
		PATCH_IF new BEGIN
			PATCH_MATCH "%bam_name%" WITH
			"" BEGIN
				SPRINT bam_name "%bam%"
			END 
			"auto" BEGIN
				n=1
				WHILE FILE_EXISTS_IN_GAME "dwicon%n%.bam" BEGIN
					++n
				END
				SPRINT bam_name "dwicon%n%"
			END
			DEFAULT
			END
			PATCH_IF "%bam%" STR_CMP "****" && !FILE_EXISTS_IN_GAME "%bam%.bam" BEGIN
				LPF sfo_path STR_VAR file="%bam%" location locbase path RET file_path END
				PATCH_IF FILE_EXISTS "%file_path%.bam" BEGIN
				INNER_ACTION BEGIN
					COPY "%file_path%.bam" "override/%bam_name%.bam"
				END
				END ELSE BEGIN
					LPF warning STR_VAR warning="supposed icon BAM file %bam% does not exist at the specified location (%file_path%.bam)" END 
				END
			END
			SPRINT $array("%stat_num%" BAM_FILE) "%bam_name%"
		END
		LPF 2da_write STR_VAR array default="-1" END
	BUT_ONLY
END
			
////////////////////////////////////////////////////////////////////////////////////////////
/* 
document{add_basic_spell_ability}
{
Add a standard (innate) ability to the currently-being-patched spell, assumed to be a blank
freshly-created v1 spell from WEIDU's CREATE command. (For lightweight spell-creation.)
}
*/
////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION add_basic_spell_ability
BEGIN
	PATCH_IF !(BUFFER_LENGTH=0x72) BEGIN
		PATCH_FAIL "add_basic_spell_ability only works on a blank, freshly-created v1 spell"
	END
	INNER_PATCH_SAVE ab_data "" BEGIN
		INSERT_BYTES 0x0 0x28
		WRITE_SHORT 0x0 1
		WRITE_SHORT 0x2 4
		WRITE_BYTE 0xc 1
		WRITE_SHORT 0x22 1
		WRITE_SHORT 0x24 1
		WRITE_SHORT 0x26 1
	END
	WRITE_SHORT 0x68 1
	WRITE_SHORT 0x6a 0x9a
	INSERT_BYTES 0x72 0x28
	WRITE_ASCII 0x72 "%ab_data%"
END

////////////////////////////////////////////////////////////////////////////////////////////
/* 
document{extend}
{
Extend the script(s) 'script' (legacy synonyms: file, files) with 'top' at the top and/or 'bottom' at the bottom. top and bottom location
is specified in the usual SFO way. If inline=1, 'top' and 'bottom' are assumed inlined at .../stratagems-inline

If ssl=1, assume 'top' and 'bottom' are ssl scripts.
If tv=1, prepend %tutu_var% to each script.
If allow_missing=1, skip silently any missing script (default is to WARN).
}
*/
////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION extend
	INT_VAR inline=0
			ssl=0
			tv=0
			allow_missing=0
	STR_VAR script=""
			files=""
			file=""
			location=""
			locbase=""
			path=""
			top=""
			bottom=""
BEGIN
	OUTER_SPRINT script "%script%%file%%files%"
	ACTION_IF "%script%" STR_CMP "" BEGIN
		LAF return_first_entry STR_VAR list="%script%" RET script_here=entry script=list END
		ACTION_IF tv BEGIN
			OUTER_SPRINT script_here "%tutu_var%%script_here%"
		END
		ACTION_IF FILE_EXISTS_IN_GAME "%script_here%.bcs" BEGIN
			ACTION_IF "%top%%bottom%" STR_EQ "" BEGIN
				WARN "You called extend with no top or bottom"
			END
			ACTION_IF ssl BEGIN
				ACTION_IF "%top%" STR_CMP "" BEGIN
					LAF ssl_to_baf INT_VAR inline STR_VAR script="%top%" location locbase path END
				END
				ACTION_IF "%bottom%" STR_CMP "" BEGIN
					LAF ssl_to_baf INT_VAR inline STR_VAR script="%bottom%" location locbase path END
				END
				LAF extend INT_VAR tv STR_VAR script="%script_here%" path="%workspace%/ssl_out" top bottom END	
			END ELSE BEGIN		
				ACTION_IF inline BEGIN
					OUTER_SPRINT path ".../stratagems-inline"
				END ELSE BEGIN
					LAF sfo_path STR_VAR path location locbase RET path END
				END
				ACTION_IF "%top%" STR_CMP "" BEGIN
					EXTEND_TOP "%script_here%.bcs" "%path%/%top%.baf" EVALUATE_BUFFER
				END
				ACTION_IF "%bottom%" STR_CMP "" BEGIN
					EXTEND_BOTTOM "%script_here%.bcs" "%path%/%bottom%.baf" EVALUATE_BUFFER
				END		
			END
		END ELSE 
		ACTION_IF !allow_missing BEGIN
			WARN "WARNING (extend): tried to extend script %script_here%, but it does not exist" 
		END
		// recurse
		LAF extend INT_VAR inline ssl tv allow_missing STR_VAR script location locbase path top bottom END
	END
	
END
	
////////////////////////////////////////////////////////////////////////////////////////////
/* 
document{extend_area_script}
{
Extend the area script of area 'area' with 'top' at the top and/or 'bottom' at the bottom. If the script doesn't exist, we create one, using standard conventions.
'area' can be a list of areas, in which case each one is extended.
}
*/
////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION extend_area_script
	INT_VAR inline=0
			ssl=0
	STR_VAR area=""
			location=""
			locbase=""
			path=""
			top=""
			bottom=""
BEGIN
	ACTION_IF "%area%" STR_CMP "" BEGIN
		LAF return_first_entry STR_VAR list="%area%" RET area_here=entry area=list END
		ACTION_IF "%top%%bottom%" STR_EQ "" BEGIN
			WARN "You called extend_area_script with no top or bottom"
		END
		COPY_EXISTING "%area_here%.are" override
			READ_ASCII 0x94 script
			PATCH_IF "%script%" STR_EQ "" BEGIN
				PATCH_MATCH "%area_here%" WITH 
				"_AR+" BEGIN
					INNER_PATCH_SAVE script "%area_here%" BEGIN
						REPLACE_TEXTUALLY CASE_INSENSITIVE "_AR" "FW"
					END
				END
				DEFAULT
					SPRINT script "%area_here%"
				END
				WRITE_ASCII 0x94 "%script%"
			END
		LAF extend INT_VAR inline ssl STR_VAR script location locbase path top bottom END
		LAF extend_area_script INT_VAR inline STR_VAR area location locbase path top bottom END
	END
END
/*
describe-library
{Functions to interact with ini files. (Probably quite short, since we probably won't write them and once we've read them in we can use array tools.)

Functions here should begin with 'ini_'}

*/

/*
document{ini_read}
{
Read in a file, or in patch context this file, in the 'ini' format. By default, store it in a 2d array (section,key)-> value. If 'flat' is set, instead store it as key=>value, ignoring sections. 
If 'backwards' is set, swap key and value. if 'case' is set, force the key and value into upper or lower case.
Also return a k=>_ array 'section_array' of section keys.

In action context, if path,location, and locbase are all blank, assume an in-game ini file.

Ini entries wrapped in "" will have them stripped.
}
*/

DEFINE_PATCH_FUNCTION ini_read
	INT_VAR backwards=0//Boolean
			flat=0//Boolean
	STR_VAR case=""//[upper|lower]
	RET_ARRAY array section_array
BEGIN
	CLEAR_ARRAY array
	CLEAR_ARRAY section_array
	SPRINT section default
	READ_ASCII 0x0 data (BUFFER_LENGTH)
	LPF data_lines STR_VAR data RET_ARRAY lines END
	PHP_EACH lines AS ind=>line BEGIN
		INNER_PATCH "%line%" BEGIN
			READ_ASCII (BUFFER_LENGTH - 1) last_char (1)
			REPLACE_EVALUATE "^\[\([^]]*\)\]" BEGIN
				SPRINT section "%MATCH1%"
				PATCH_MATCH "%case%" WITH
				upper BEGIN
					TO_UPPER section
				END
				lower BEGIN
					TO_LOWER section
				END
				DEFAULT
				END
				SPRINT $section_array("%section%") ""
			END
			""
			REPLACE_EVALUATE "\(^[^ =%WNL%%LNL%%MNL%]*[^ %TAB%]\)[ %TAB%]*=[ %TAB%]*\([^ %TAB%].*\)" BEGIN
			SPRINT key "%MATCH1%"
			SPRINT value "%MATCH2%"
			INNER_PATCH_SAVE key "%key%" BEGIN
				REPLACE_TEXTUALLY "^[ %TAB%]+" "" // strip leading spaces
			END
			INNER_PATCH_SAVE value "%value%" BEGIN	// strip trailing spaces
				REPLACE_TEXTUALLY "[ %TAB%]+$" ""
			END
			PATCH_MATCH "%case%" WITH
			upper BEGIN
				TO_UPPER key
				TO_UPPER value
			END
			lower BEGIN
				TO_LOWER key
				TO_LOWER value
			END
			DEFAULT
			END
			LPF trim_string INT_VAR require_both=1 STR_VAR string="%value%" character=~"~ RET value=string END
			PATCH_IF backwards BEGIN
					SPRINT temp "%value%"
					SPRINT value "%key%"
					SPRINT key "%temp%"
				END
				PATCH_IF flat BEGIN
					SPRINT $array("%key%") "%value%"
				END ELSE BEGIN
					SPRINT $array("%section%" "%key%") "%value%"
				END
			END
			""
		END	
	END

END

DEFINE_ACTION_FUNCTION ini_read
	INT_VAR backwards=0//Boolean
			flat=0//Boolean
	STR_VAR file=""
			path=""
			location=""
			locbase=""
			case=""//[upper|lower]
	RET_ARRAY array section_array
BEGIN
	LAF sfo_path STR_VAR file path location locbase RET path END
	ACTION_IF "%path%" STR_EQ "" BEGIN
		COPY_EXISTING - "%file%" nowhere
			LPF ini_read INT_VAR backwards flat STR_VAR case RET_ARRAY array section_array END
		BUT_ONLY
	END ELSE BEGIN
		COPY - "%path%/%file%" nowhere
			LPF ini_read INT_VAR backwards flat STR_VAR case RET_ARRAY array section_array END
		BUT_ONLY	
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Load the standard ini
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
document{ini_load}
{
Loads the default ini into SFO_reserved_ini_hash and SFO_reserved_ini_hash_2d. 

The ini is located at %SFO_ini_file_location%/%SFO_ini_file% - by default these are %MOD_FOLDER% and %MOD_FOLDER%.ini respectively, but they can be set to other values.
}

*/

DEFINE_ACTION_MACRO ini_load BEGIN
	ACTION_IF !VARIABLE_IS_SET SFO_ini_loaded BEGIN
		OUTER_SET SFO_ini_loaded=1
		ACTION_IF !VARIABLE_IS_SET SFO_ini_file BEGIN
			OUTER_SPRINT SFO_ini_file "%MOD_FOLDER%.ini"
		END
		ACTION_IF !VARIABLE_IS_SET SFO_ini_file_location BEGIN
			OUTER_SPRINT SFO_ini_file_location "%MOD_FOLDER%"
		END
		ACTION_IF FILE_EXISTS "%SFO_ini_file_location%/%SFO_ini_file%" BEGIN
			LAF ini_read INT_VAR flat=1 STR_VAR file="%SFO_ini_file%" path="%SFO_ini_file_location%" RET_ARRAY SFO_reserved_ini_hash=array END
			LAF ini_read INT_VAR flat=0 STR_VAR file="%SFO_ini_file%" path="%SFO_ini_file_location%" RET_ARRAY SFO_reserved_ini_hash_2d=array END
		END
	END	
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// Check an ini value (case-insensitive)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
document{ini_check}
{
Return a value from the mod's ini (which needs to have previously been read in, as a flat ini, into SFO_reserved_ini_hash).
If 'section' is set, instead return a section-dependent value from the ini (it needs to have previously been read into SFO_reserved_ini_hash_2d).
If the ini doesn't contain that value, whine unless silent=1. ini and arguments are synonyms.
}


*/


DEFINE_DIMORPHIC_FUNCTION ini_check
        INT_VAR silent=0
		STR_VAR ini=""
				arguments=""
				section=""
        RET value
BEGIN
	OUTER_PATCH "" BEGIN
		PATCH_IF "%arguments%" STR_CMP "" BEGIN
			SPRINT ini "%arguments%"
		END
        TO_LOWER ini
		PATCH_IF "%section%" STR_EQ "" BEGIN
			PATCH_IF !VARIABLE_IS_SET $SFO_reserved_ini_hash(~%ini%~) BEGIN
			   SPRINT value 0
			   PATCH_IF !silent BEGIN
					PATCH_WARN "ini entry %ini% has been checked, but is not present in the ini file"
			   END
			END ELSE BEGIN
			   SPRINT value $SFO_reserved_ini_hash(~%ini%~)
			END
		END ELSE BEGIN
			PATCH_IF !VARIABLE_IS_SET $SFO_reserved_ini_hash_2d(~%section%~ ~%ini%~) BEGIN
			   SPRINT value 0
			   PATCH_IF !silent BEGIN
					PATCH_WARN "ini entry %ini% in section %section% has been checked, but is not present in the ini file"
			   END
			END ELSE BEGIN
			   SPRINT value $SFO_reserved_ini_hash_2d(~%section%~ ~%ini%~)
			END
		
		
		END
	END
END

/*
document{check_ini}
{
Legacy name for ini_check.
}

*/

DEFINE_DIMORPHIC_FUNCTION check_ini
        INT_VAR silent=0
		STR_VAR ini=""
				arguments=""
				section=""
        RET value
BEGIN
	LAF ini_check INT_VAR silent STR_VAR ini arguments section RET value END
END
<<<<<<<<.../stratagems-inline/blank
>>>>>>>>


/*
describe-library{}
{
Functions tied to SFO's own core functioning. Functions here should depend only on lib_fn and lib_tools.

}

*/


/*

document{sfo_load}
{
Given a list of space-separated sfo library functions, load those functions and (recursively) any libraries they depend on.
}


*/

DEFINE_ACTION_FUNCTION sfo_load
	STR_VAR library=""
BEGIN
	// sanity check
	ACTION_IF !VARIABLE_IS_SET sfo_setup_run || !sfo_setup_run BEGIN
		FAIL "You need to run the 'sfo_setup' macro before loading any SFO functions."
	END
	// default variable
	ACTION_IF !VARIABLE_IS_SET sfo_library_path BEGIN
		OUTER_SPRINT sfo_library_path sfo
	END
	// get the libraries into an array
	ACTION_CLEAR_ARRAY original_array
	ACTION_CLEAR_ARRAY load_array
	ACTION_TO_LOWER library
	OUTER_PATCH "%library% " BEGIN
		REPLACE_EVALUATE "\([^ ]+\) " BEGIN
			SPRINT library "%MATCH1%"
			PATCH_IF INDEX ("\." "%library%")<0 BEGIN
				SPRINT library "%library%.tph"
			END
			SPRINT $original_array("%library%") ""
			SPRINT $load_array("%library%") ""
		END
		""
	END
	COPY - "%MOD_FOLDER%/%sfo_library_path%/data/sfo_dependencies.2da" nowhere // have to do this manually since we haven't loaded lib_2da
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW dependency_data colcount
		READ_2DA_ENTRIES_NOW dependency_columns (colcount - 1)
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY_FORMER dependency_columns 0 (col - 1) header
			SPRINT $col_header("%col%") "%header%"
		END
		FOR (row=0;row<dependency_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER dependency_data row 0 library
			PATCH_IF VARIABLE_IS_SET $load_array("%library%") BEGIN
				FOR (col=1;col<colcount;++col) BEGIN
					READ_2DA_ENTRY_FORMER dependency_data row col depends
					PATCH_IF depends BEGIN
						SPRINT depends_name $col_header("%col%")
						SPRINT $load_array("%depends_name%") ""
					END
				END
			END
		END
	
	ACTION_PHP_EACH load_array AS library=>discard BEGIN
		ACTION_MATCH "%library%" WITH
		"lib_sfo.tph" BEGIN
		END
		DEFAULT
			PRINT "Loading %library%"
			INCLUDE "%MOD_FOLDER%/%sfo_library_path%/%library%"
		END
	END
END



/*

document{sfo_path}
{
Given some or all of 'file', 'path', 'location' and 'locbase', return a full filespec file_path (e.g. %MOD_FOLDER%/lib/lib_soundset.tph) and the path bit (e.g. "%MOD_FOLDER%/lib).</p>
<p>
Determined as follows:
<ul>
<li>if 'path' is set, just use it.
<li>if not, and 'location' is set:
	<ul>
	<li>if 'locbase is set, use '%MOD_FOLDER%/locbase/location'
	<li>if not, and the 'component_loc' variable is set, use '%MOD_FOLDER%/component_loc/location'
	<li>otherwise, use '%MOD_FOLDER%/location'
	</ul>
<li>if not, and 'locbase' is set, use '%MOD_FOLDER%/locbase'
<li>otherwise, just use ""
	
}

*/

DEFINE_DIMORPHIC_FUNCTION sfo_path
	STR_VAR path=""
			location=""
			locbase=""
			file=""
	RET file_path
		path
BEGIN
	ACTION_IF !"%path%" STR_EQ "" BEGIN
		OUTER_SPRINT file_path "%path%/%file%"
	END ELSE
	ACTION_IF !"%location%" STR_EQ "" BEGIN
		ACTION_IF !"%locbase%" STR_EQ "" BEGIN
			OUTER_SPRINT path "%MOD_FOLDER%/%locbase%/%location%"	
		END ELSE
		ACTION_IF (VARIABLE_IS_SET component_loc) && !"%component_loc%" STR_EQ "" BEGIN
			OUTER_SPRINT path "%MOD_FOLDER%/%component_loc%/%location%"
		END ELSE BEGIN
			OUTER_SPRINT path "%MOD_FOLDER%/%location%"
		END	
	END ELSE
	ACTION_IF !"%locbase%" STR_EQ "" BEGIN
			OUTER_SPRINT path "%MOD_FOLDER%/%locbase%"
	END ELSE BEGIN
		OUTER_SPRINT path ""
	END
	ACTION_IF "%path%" STR_EQ "" BEGIN
		OUTER_SPRINT file_path "%file%"
	END ELSE BEGIN
		OUTER_SPRINT file_path "%path%/%file%"
	END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
document{log_this}
{
Dump the string 'input' (synonym:'arguments') into the text file 'file' (by default placed in the %data_loc% directory, but you can override), creating it if necessary.

If repeat=0, only do this if it's not already there.
If new=1, wipe any existing contents
}


*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION log_this
        INT_VAR repeat=1//boolean
				new=0//boolean
		STR_VAR file=""
                input=""
				arguments=""
                path="%data_loc%"
                location=""
                locbase=""
BEGIN
        ACTION_IF "%file%" STR_EQ "" BEGIN
			FAIL "No 'file' argment in log_this function"
		END
		OUTER_SPRINT input "%input%%arguments%"
		LAF sfo_path STR_VAR location locbase path file RET file_path END
        ACTION_IF !FILE_EXISTS ~%file_path%~ || new BEGIN
           COPY ~.../stratagems-inline/blank~ ~%file_path%~
        END
		ACTION_IF !repeat BEGIN
			LAF despecialize STR_VAR string="%input%" RET input_despec=string END
			OUTER_SET proceed=!FILE_CONTAINS_EVALUATED ("%file_path%" "%input_despec%\($\|%WNL%\|%MNL%\|%LNL\)")
		END ELSE BEGIN
			OUTER_SET proceed=1
		END
        ACTION_IF proceed BEGIN
           APPEND_OUTER ~%file_path%~ ~%input%~
        END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
document{warning}
{
Dump the string 'warning' (synonym: 'arguments') into data_loc/sfo_warnings.txt, prepended with the component number and mod name.
If repeat=0, only do this if it's not already there.
}


*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION warning
        INT_VAR repeat=0
		STR_VAR warning=""
				arguments=""
BEGIN
		PRINT "SFO warning: %warning%%arguments%"
		LAF log_this INT_VAR repeat STR_VAR file=sfo_warnings.txt input= ~%TP2_BASE_NAME% component %COMPONENT_NUMBER%: %warning%%arguments%~ END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
document{regexp_warning}
{
Special case of 'warning' used specifically as a soft-fail for regexps.
}


*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION regexp_warning
 STR_VAR file=""
		 parent="<unknown>"
BEGIN
	OUTER_PATCH "" BEGIN
		PATCH_IF "%file%" STRING_EQUAL_CASE "" BEGIN
			SPRINT file "%SOURCE_FILE%"
		END
		SPRINT warning "The mod's '%parent%' function has encountered a file it doesn't know how to patch, probably %file% (probably the file was broken by a previous mod). The error message was '%ERROR_MESSAGE%'. 
		WEIDU has skipped it and continued with installation, but this may cause instabilities."
		PATCH_WARN "%warning%"
		LPF warning STR_VAR warning END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{sfo_handle_charsets}
{
SFO wrapper for HANDLE_CHARSETS.
}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION sfo_handle_charsets
	INT_VAR sfo_from_utf8=0//boolean
	STR_VAR sfo_tra_path=""
			sfo_iconv_path="%sfo_tra_path%/iconv"
	RET sfo_tra_loc
		scs_tra_loc
BEGIN
	ACTION_IF FILE_EXISTS "%MOD_FOLDER%/%sfo_iconv_path%/iconv.exe" && !VARIABLE_IS_SET SFO_charsets_handled BEGIN
		OUTER_SET SFO_charsets_handled=1
		ACTION_IF sfo_from_utf8=0 BEGIN
			ACTION_IF enhanced_edition BEGIN
				LAF HANDLE_CHARSETS 
					INT_VAR infer_charsets=1
							from_utf8=0
					STR_VAR	tra_path="%MOD_FOLDER%/%sfo_tra_path%"
							out_path="%ext_lang_loc%"
							iconv_path="%MOD_FOLDER%/%sfo_iconv_path%"
				END	
				OUTER_SPRINT sfo_tra_loc "%ext_lang_loc%"
			END ELSE BEGIN
				OUTER_SPRINT sfo_tra_loc "%MOD_FOLDER%/%sfo_tra_path%"
			END
			OUTER_SPRINT scs_tra_loc "%sfo_tra_loc%" // legacy
		END ELSE BEGIN
			ACTION_IF !enhanced_edition BEGIN
				LAF HANDLE_CHARSETS 
					INT_VAR infer_charsets=1
							from_utf8=1
					STR_VAR	tra_path="%MOD_FOLDER%/%sfo_tra_path%"
							out_path="%ext_lang_loc%"
							iconv_path="%MOD_FOLDER%/%sfo_iconv_path%"
				END	
				OUTER_SPRINT sfo_tra_loc "%ext_lang_loc%"
			END ELSE BEGIN
				OUTER_SPRINT sfo_tra_loc "%MOD_FOLDER%/%sfo_tra_path%"
			END
		END
	END ELSE BEGIN
		OUTER_SPRINT sfo_tra_loc "%sfo_tra_loc%"
	END
	OUTER_SPRINT scs_tra_loc "%sfo_tra_loc%" // legacy	
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{sfo_setup}
{
Set up the SFO directories and variables.

}

*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 
DEFINE_ACTION_MACRO sfo_setup BEGIN
  
	OUTER_SET sfo_setup_run=1
  
 ////// Blank file

<<<<<<<< .../stratagems-inline/blank
>>>>>>>>
  
 //// readme

<<<<<<<< .../stratagems-inline/readme.txt
This folder is created by DavidW's mods for storing and building files. Other modders are welcome to use it; it's organised as follows:

Workspace: for building things. Put anything you like in here; don't expect it still to be there next time you check.

Data: for storing data that you want to read between components of your mod, or between different mods. Store data in a subfolder of 'Data'. I suggest using a folder with the same name as your mod folder itself; alternatively, use a folder with your modder prefix. Don't have your mod edit anything in someone else's folder without permission.

Markers: for putting small files that let other components of your mod, or other mods, detect what your mod has done. (This is not a good way to detect whether a component is installed at all, as it does not play nicely with automated installers; use REQUIRE/FORBID_COMPONENT and similar for that.) Since this folder is shared, use your modder prefix for any file stored in it. I suggest ".mrk" as a file suffix.

Backup: you can backup your mod here if you'd rather not use a folder in your own mod folder. Use
BACKUP "weidu_external/backup/[your mod folder name]" in your tp2. 
>>>>>>>>
  
  
   //////////////////////////////////////////////////////////////
   /// set the default variables if they're not set already
   //////////////////////////////////////////////////////////////

   ACTION_IF !VARIABLE_IS_SET sfo_library_path BEGIN
      OUTER_SPRINT sfo_libary_path sfo
   END
   
   ACTION_IF !VARIABLE_IS_SET lua_loc BEGIN
		OUTER_SPRINT lua_loc lua
   END

   ACTION_IF !VARIABLE_IS_SET external_loc BEGIN
      OUTER_SPRINT external_loc weidu_external
   END

   ACTION_IF !VARIABLE_IS_SET sfo_tra_path BEGIN
      OUTER_SPRINT sfo_tra_path lang
   END

   ACTION_IF !VARIABLE_IS_SET sfo_iconv_path BEGIN
      OUTER_SPRINT sfo_iconv_path "%sfo_tra_path%/iconv"
   END

   ACTION_IF !VARIABLE_IS_SET base_language BEGIN
      OUTER_SPRINT base_language english
   END
   
   ACTION_IF !VARIABLE_IS_SET ext_lang_loc BEGIN
		OUTER_SPRINT ext_lang_loc "%external_loc%/lang/%MOD_FOLDER%"
   END
   ACTION_IF !VARIABLE_IS_SET ext_audio_loc BEGIN
		OUTER_SPRINT ext_audio_loc "%external_loc%/audio/%MOD_FOLDER%"
   END
   
   ACTION_IF !VARIABLE_IS_SET ssl_loc BEGIN
		OUTER_SPRINT ssl_loc "%MOD_FOLDER%/bin"
   END

   ACTION_IF !VARIABLE_IS_SET sfo_from_utf8 BEGIN
	OUTER_SET sfo_from_utf8=0
   END
   
   //////////////////////////////////////////////////////////////
   /// make the external folders
   //////////////////////////////////////////////////////////////

   MKDIR "%external_loc%"
   MKDIR "%external_loc%/workspace"
   MKDIR "%external_loc%/workspace/ssl_out"
   MKDIR "%external_loc%/data/%MOD_FOLDER%"
   MKDIR "%external_loc%/data/dw_shared"
   MKDIR "%external_loc%/markers"
   MKDIR "%external_loc%/lang"


   //////////////////////////////////////////////////////////////
   /// Install the readme
   //////////////////////////////////////////////////////////////
	
	COPY + ".../stratagems-inline/readme.txt" "%external_loc%"

   //////////////////////////////////////////////////////////////
   /// Set variables for the external locations
   //////////////////////////////////////////////////////////////

   OUTER_SPRINT workspace "%external_loc%/workspace"
   OUTER_SPRINT data_loc_root "%external_loc%/data"
   OUTER_SPRINT data_loc "%external_loc%/data/%MOD_FOLDER%"
   OUTER_SPRINT marker_loc "%external_loc%/markers"
   OUTER_SPRINT ext_lang_loc "%external_loc%/lang/%MOD_FOLDER%"
   OUTER_SPRINT data_loc_shared "%external_loc%/data/dw_shared"
   OUTER_SPRINT batch_loc "%external_loc%/batch"
   
    ///////////////////////////////////////////////////
	// check what install we're running on
	///////////////////////////////////////////////////

  OUTER_SET enhanced_edition = ( GAME_IS ~bgee bg2ee eet iwdee pstee~ ? 1 : 0)
  OUTER_SET is_tobex = (FILE_EXISTS "tobex.dll")
  OUTER_SET is_bg1 = ( GAME_IS ~bgee tutu tutu_totsc bgt eet bg1 totsc~ ? 1 : 0)
  OUTER_SET is_bg2 = ( GAME_IS ~bg2ee eet bgt tob soa~ ? 1 : 0)
  OUTER_SET is_sod = ( GAME_INCLUDES sod)
  OUTER_SET is_iwd = ( GAME_IS ~iwdee iwd how totlm~ ? 1 : 0)
  OUTER_SET is_tutu = ( GAME_IS ~tutu tutu_totsc~ ? 1 : 0)
  OUTER_SET is_eet = ( GAME_IS ~eet~ ? 1 : 0)

  ACTION_IF !VARIABLE_IS_SET tutu_var BEGIN
     ACTION_IF is_tutu BEGIN
        OUTER_SPRINT tutu_var "_"
     END ELSE BEGIN
        OUTER_SPRINT tutu_var ""
     END
  END
  
  ACTION_IF GAME_IS "eet" BEGIN
     OUTER_SPRINT eet_var "_"
  END ELSE BEGIN
     OUTER_SPRINT eet_var ""
  END
 
  
    ///////////////////////////////////////////////////
	//set SSL variables
	///////////////////////////////////////////////////
 
  
     OUTER_SPRINT percentage "%"
	OUTER_SPRINT sslvariables "%percentage%MOD_FOLDER%percentage%=%MOD_FOLDER%&%percentage%tutu_var%percentage%=%tutu_var%"

   
END


/*
document{sfo_crossplatform}
{
Load appropriate values of the various variables for different versions of BG.
}
*/

DEFINE_ACTION_MACRO sfo_crossplatform BEGIN
 
	LOCAL_SPRINT letter ""
	LOCAL_SPRINT thegame ""
	LOCAL_SPRINT rows ""
	LOCAL_SPRINT var ""
	LOCAL_SPRINT val ""
	LOCAL_SPRINT area_array ""
	LOCAL_SPRINT name_array ""
	LOCAL_SET chapter_delta=0
	LOCAL_SET num=0

	ACTION_IF !VARIABLE_IS_SET sfo_crossplatform_set BEGIN
		
		OUTER_SET sfo_crossplatform_set=1
	 
		// file naming - general case (these are used enough that they tend to creep into even BG2 code, so it's worth defining them once and for all)

		ACTION_FOR_EACH letter IN a b c d e f g h i j k l m n o p q r s t u v w x y z BEGIN
			ACTION_IF is_tutu BEGIN
				OUTER_SPRINT ~tutu_script%letter%~ ~_~
			END ELSE BEGIN
				OUTER_SPRINT ~tutu_script%letter%~ ~%letter%~
			END
		END
		
		// the rest of this is skipped unless on a BG1 install
		
		ACTION_IF is_bg1 BEGIN
		
		// setup
		 
			ACTION_IF is_tutu BEGIN
				OUTER_SPRINT thegame tutu
			END ELSE 
			ACTION_IF GAME_IS bgt BEGIN
				OUTER_SPRINT thegame bgt
			END ELSE
			ACTION_IF GAME_IS bgee BEGIN
				OUTER_SPRINT thegame bgee
			END ELSE 
			ACTION_IF GAME_IS eet BEGIN
				OUTER_SPRINT thegame eet
			END ELSE BEGIN
				FAIL ~Error in sfo_crossplatform: unrecognised BG1 game~
			END
		
		// area codes (and associated area scripts)
			ACTION_IF FILE_EXISTS "%MOD_FOLDER%/%sfo_library_path%/data/bg1_area_list.2da" BEGIN
				LAF 2da_read STR_VAR file=bg1_area_list.2da locbase="%sfo_library_path%/data" case=mixed RET_ARRAY area_array=array rows END
			END ELSE BEGIN
				LAF 2da_read INT_VAR inline=1 STR_VAR file=".../stratagems-inline/bg1_area_list.2da" case=mixed RET_ARRAY area_array=array rows END		
			END
			ACTION_PHP_EACH rows AS var=>discard BEGIN
				ACTION_IF "%thegame%" STR_EQ "bgt" BEGIN
					OUTER_SPRINT val $area_array("%var%" "bgt")
				END ELSE BEGIN
					OUTER_SPRINT val $area_array("%var%" "default")
					ACTION_MATCH "%thegame%" WITH
					eet BEGIN
						OUTER_PATCH_SAVE val "%val%" BEGIN
							WRITE_ASCII 0x0 BG (2)
						END	
						OUTER_SPRINT val_bcs "%val%"
					END
					tutu BEGIN
						OUTER_PATCH_SAVE val_bcs "%val%" BEGIN
							INSERT_BYTES 0x0 1
							WRITE_ASCII 0x0 "_"
						END
						OUTER_PATCH_SAVE val "%val%" BEGIN
							WRITE_ASCII 0x0 FW (2)
						END
					END	
					DEFAULT
						OUTER_SPRINT val_bcs "%val%"
					END				
				END
				OUTER_SPRINT "%var%" "%val%"
				OUTER_SPRINT "%var%_BCS" "%val_bcs%"
			END
	   
		// residuals
		
			ACTION_IF FILE_EXISTS "%MOD_FOLDER%/%sfo_library_path%/data/bg1_file_names.2da" BEGIN
				LAF 2da_read STR_VAR file=bg1_file_names.2da locbase="%sfo_library_path%/data" case=mixed RET_ARRAY name_array=array rows END
			END ELSE BEGIN
				LAF 2da_read INT_VAR inline=1 STR_VAR file=".../stratagems-inline/bg1_file_names.2da" case=mixed RET_ARRAY name_array=array rows END
			END
			ACTION_PHP_EACH rows AS var=>discard BEGIN
				OUTER_SPRINT val $name_array("%var%" "%thegame%")
				ACTION_IF "%val%" STR_CMP "null" BEGIN
					OUTER_SPRINT "%var%" "%val%"
				END
			END	
		
			 // chapters
		  
			OUTER_SET chapter_delta= ( ~%thegame%~ STRING_EQUAL bgt ? 1 : 0)
			OUTER_FOR (num=1;num<=7;num +=1) BEGIN
				OUTER_SET ~bg1_chapter_%num%~ =num + chapter_delta
			END


			  // testing
			  /*
			  PRINT ~tutu_var is "%tutu_var%"~
			  PRINT ~tutu_scriptbg is %tutu_scriptbg%~
			  PRINT ~tutu_scriptf is %tutu_scriptf%~
			  PRINT ~bg1_skeleton_warrior is %bg1_skeleton_warrior%~
			  PRINT ~bg1_chapter_4 is %bg1_chapter_4%~
			  PRINT ~Undercity_TempleofBhaal is %Undercity_TempleofBhaal%~
			  ACTION_READLN bloook
			  */

		END // end of BG1 section

		ACTION_IF is_bg2 BEGIN    // BG2 section

			OUTER_SET chapter_delta= ( ~%thegame%~ STRING_EQUAL eet ? 12 : 0)
			OUTER_FOR (num=1;num<=10;num +=1) BEGIN
				OUTER_SET ~bg2_chapter_%num%~ =num + chapter_delta
			END


		END
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{make_label}
{
Set a marker file, which can be checked by check_label. </p>

<p>Do not use make_label or check_label in your base tp2 to decide whether to install a component, as they are invisible to Project Infinity and the like.
}

*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION make_label
	STR_VAR label=""
BEGIN
    COPY ~.../stratagems-inline/blank~ ~%marker_loc%/%label%.mrk~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{check_label}
{
Check for a marker file, which can be set by make_label.</p>

<p>Do not use make_label or check_label in your base tp2 to decide whether to install a component, as they are invisible to Project Infinity and the like.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION check_label
    STR_VAR label=""
			prefix=""
    RET value
BEGIN
   OUTER_SET value=FILE_EXISTS ~%marker_loc%/%prefix%%label%.mrk~ 
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{sfo_fix}
{
A few basic fixes:
<ul>
<li>make sure dir.ids is present and working
<li>add some possibly-missing entries to gtimes.ids and spell.ids
<li>remove + from missile.ids
<li>on BGEE, add some spell.ids entries missing that are present on SoD
</ul>
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION sfo_fix BEGIN

	SILENT
	LAF check_label STR_VAR label="dw-sfo-fix" RET value END
	ACTION_IF !value BEGIN
		LAF make_label STR_VAR label="dw-sfo-fix" END
		
		////////////////////////////////////////////////////////////////////////////////
		/// make sure dir.ids is present and working
		////////////////////////////////////////////////////////////////////////////////

<<<<<<<<.../stratagems-inline/dir.ids
IDS
0 S
1 SSW
2 SW
3 SWW
4 W
5 NWW
6 NW
7 NNW
8 N
9 NNE
10 NE
11 NEE
12 E
13 SEE
14 SE
15 SSE
>>>>>>>>

        COPY ".../stratagems-inline/dir.ids" override
        COPY_EXISTING "action.ids" override
             REPLACE_TEXTUALLY "Face\*)" "Face*DIR)"
             REPLACE_TEXTUALLY "Direction\*)" "Direction*DIR)"
        BUT_ONLY

		////////////////////////////////////////////////////////////////////////////////
		// add a few possibly-missing IDS entries (direct from EEAsc)
		////////////////////////////////////////////////////////////////////////////////

        APPEND ~gtimes.ids~ ~6 ONE_ROUND~                    UNLESS ~ONE_ROUND~
        APPEND ~gtimes.ids~ ~12 TWO_ROUNDS~                    UNLESS ~TWO_ROUNDS~
        APPEND ~gtimes.ids~ ~18 THREE_ROUNDS~                    UNLESS ~THREE_ROUNDS~
        APPEND ~gtimes.ids~ ~24 FOUR_ROUNDS~                    UNLESS ~FOUR_ROUNDS~
        APPEND ~gtimes.ids~ ~30 FIVE_ROUNDS~                    UNLESS ~FIVE_ROUNDS~
        APPEND ~gtimes.ids~ ~54 NINE_ROUNDS~                    UNLESS ~NINE_ROUNDS~
        APPEND ~gtimes.ids~ ~60 TEN_ROUNDS~                     UNLESS ~TEN_ROUNDS~
        APPEND ~gtimes.ids~ ~10 TWO_MINUTES~                    UNLESS ~TWO_MINUTES~
        APPEND ~gtimes.ids~ ~45 NINE_MINUTES~                    UNLESS ~NINE_MINUTES~
        APPEND ~gtimes.ids~ ~100 TWENTY_MINUTES~                    UNLESS ~TWENTY_MINUTES~
        APPEND ~gtimes.ids~ ~300 ONE_HOUR~                    UNLESS ~ONE_HOUR~
        APPEND ~spell.ids~  ~2302 WIZARD_REMOVE_MAGIC~          UNLESS ~WIZARD_REMOVE_MAGIC~
        APPEND ~spell.ids~  ~2705 WIZARD_KHELBENS_WARDING_WHIP~ UNLESS ~WIZARD_KHELBENS_WARDING_WHIP~

		// on EE, make sure FarthestObject etc are present
		
		ACTION_IF enhanced_edition BEGIN
			APPEND ~object.ids~ ~105 FarthestEnemyOf~ UNLESS ~105 FarthestEnemyOf~			
			APPEND ~object.ids~ ~106 SecondFarthestEnemyOf~ UNLESS ~106 SecondFarthestEnemyOf~
			APPEND ~object.ids~ ~107 ThirdFarthestEnemyOf~ UNLESS ~107 ThirdFarthestEnemyOf~
			APPEND ~object.ids~ ~108 FourthFarthestEnemyOf~ UNLESS ~108 FourthFarthestEnemyOf~
			APPEND ~object.ids~ ~109 FifthFarthestEnemyOf~ UNLESS ~109 FifthFarthestEnemyOf~
			APPEND ~object.ids~ ~110 SixthFarthestEnemyOf~ UNLESS ~110 SixthFarthestEnemyOf~
			APPEND ~object.ids~ ~111 SeventhFarthestEnemyOf~ UNLESS ~111 SeventhFarthestEnemyOf~
			APPEND ~object.ids~ ~112 EighthFarthestEnemyOf~ UNLESS ~112 EighthFarthestEnemyOf~
			APPEND ~object.ids~ ~113 NinthFarthestEnemyOf~ UNLESS ~113 NinthFarthestEnemyOf~
			APPEND ~object.ids~ ~114 TenthFarthestEnemyOf~ UNLESS ~114 TenthFarthestEnemyOf~
		END
		
		// on BGEE without SoD, append some missing spell.ids entries
		
		ACTION_IF GAME_IS bgee && !GAME_INCLUDES sod BEGIN
			ACTION_CLEAR_ARRAY extra_spell_ids_entries
			ACTION_DEFINE_ASSOCIATIVE_ARRAY extra_spell_ids_entries BEGIN
				3122=>AVENGER_SHAPESHIFT_NATURAL_FORM
				3123=>DRUID_SHAPESHIFT_FROM_BLACKBEAR
				3124=>SHAPESHIFTER_SHAPESHIFT_NATURAL_FORM
				3150=>SHAPESHIFT_NATURAL_FORM_1
				3151=>SHAPESHIFT_NATURAL_FORM_2
				4611=>DRUID_SHAPESHIFT_BROWNBEAR
				4612=>DRUID_SHAPESHIFT_WOLF
				4613=>DRUID_SHAPESHIFT_BLACKBEAR
				4632=>AVENGER_SHAPESHIFT_SWORDSPIDER
				4633=>AVENGER_SHAPESHIFT_BABYWYVERN
				4634=>AVENGER_SHAPESHIFT_FIRESALAMANDER
				4643=>SHAPESHIFTER_SHAPESHIFT_WEREWOLF
				4644=>SHAPESHIFTER_SHAPESHIFT_GREATERWEREWOLF
				2490=>WIZARD_POLYMORPH_NATURAL_FORM
				2493=>WIZARD_POLYMORPH_FLIND
				2494=>WIZARD_POLYMORPH_OGRE
				2495=>WIZARD_POLYMORPH_SPIDER
				2496=>WIZARD_POLYMORPH_MUSTARD_JELLY
				2497=>WIZARD_POLYMORPH_BROWN_BEAR
				2498=>WIZARD_POLYMORPH_BLACK_BEAR
				2499=>WIZARD_POLYMORPH_WOLF
			END
			ACTION_PHP_EACH extra_spell_ids_entries AS ind=>sym BEGIN
				APPEND spell.ids "%ind%%TAB%%sym%" UNLESS "%sym%"
			END		
		END

		////////////////////////////////////////////////////////////////////////////////
		//deal with the broken objects in vBG2
		////////////////////////////////////////////////////////////////////////////////

		ACTION_IF !enhanced_edition BEGIN
			ACTION_FOR_EACH bad IN "iplot01k.itm" "iplot04g.itm" "iplot04h.itm" "iplot04i.itm" "xr2400.are" "xr2600.are" BEGIN
				ACTION_IF FILE_EXISTS_IN_GAME "%bad%" BEGIN
					DISABLE_FROM_KEY "%bad%"
				END
			END
		END
		
		////////////////////////////////////////////////////////////////////////////////
		//remove + signs from missile.ids
		////////////////////////////////////////////////////////////////////////////////

		COPY_EXISTING "missile.ids" override
			REPLACE_TEXTUALLY "\+" "plus_"
		BUT_ONLY

		////////////////////////////////////////////////////////////////////////////////
		//make the rows in weapprof unique
		////////////////////////////////////////////////////////////////////////////////

		COPY_EXISTING weapprof.2da override
			SET_2DA_ENTRY_LATER weapprof_fix 4 0 SPEAR_BG1
			SET_2DA_ENTRY_LATER weapprof_fix 7 0 AXE_BG1
			SET_2DA_ENTRIES_NOW weapprof_fix 4


	END
	VERBOSE

END


DEFINE_ACTION_MACRO sfo_batch_set BEGIN
	OUTER_SET SFO_batch_mode=1
	MKDIR "%batch_loc%"
	LAF new_file INT_VAR no_log=1 STR_VAR file="%MOD_FOLDER%.bat" path="%batch_loc%" arguments="setup-%MOD_FOLDER% --uninstall --force-install-list" END
	AT_EXIT "%batch_loc%/%MOD_FOLDER%.bat"
END


DEFINE_ACTION_FUNCTION sfo_batch_update BEGIN
	COPY "%batch_loc%/%MOD_FOLDER%.bat" "%batch_loc%"
		SPRINT string " %COMPONENT_NUMBER%"
		insert_point=BUFFER_LENGTH
		INSERT_BYTES insert_point STRING_LENGTH "%string%"
		WRITE_ASCII insert_point "%string%"
END
/*
describe-library
{
Functions here do simple, IE-independent tasks. (If they're pure functions without side effects they should be in lib_fn instead.)
No special naming conventions. (Be cautious!)

Functions here should have no dependencies outside lib_tools, except that they can have an *ignorable* dependency on sfo_path.
}

ignore-dependencies{sfo_path}
*/

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{data_lines}
{
Given either 'data' (a string) or a path to a file, return either the string or the file separated into an array of lines, separated by line-breaks.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION data_lines
	STR_VAR data="" path="" file=""
	RET_ARRAY lines
BEGIN
	ACTION_IF !("%file%" STR_EQ "") BEGIN
		ACTION_IF "%path%" STR_CMP "" BEGIN
			OUTER_SPRINT file_path "%file%"
		END ELSE BEGIN
			OUTER_SPRINT file_path "%path%/%file%"		
		END
		COPY - "%file_path%" "%workspace%"
			READ_ASCII 0x0 data (BUFFER_LENGTH)
	END
	OUTER_PATCH "%data%" BEGIN
		CLEAR_ARRAY lines
		count=0
		REPLACE_EVALUATE "^\([^%WNL%%MNL%%LNL%]+\)" BEGIN
			SPRINT $lines("%count%") "%MATCH1%"
			++count
		END	
		""
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{read_whatever}
{
Given an offset in the current file, and given a length that is 1,2,or 4, read the appropriate-length integer from that offset.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION read_whatever
	INT_VAR length=0//[1|2|4]
			offset=0
	RET value
BEGIN
	PATCH_MATCH "%length%" WITH
	4 BEGIN
		READ_LONG offset value
	END
	2 BEGIN
		READ_SHORT offset value
	END
	1 BEGIN
		READ_BYTE offset value
	END
	DEFAULT
		PATCH_WARN "length %length% is not recognised by write_whatever"
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{write_whatever}
{
Given an offset in the current file, a length that is 1,2,or 4, and an integer, write the integer to an appropriate-length slot at that offset.
}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION write_whatever
	INT_VAR length=0//[1|2|4]
			write=0
			offset=0
BEGIN
	PATCH_MATCH "%length%" WITH
	4 BEGIN
		WRITE_LONG offset write
	END
	2 BEGIN
		WRITE_SHORT offset write
	END
	1 BEGIN
		WRITE_BYTE offset write
	END
	DEFAULT
		PATCH_WARN "length %length% is not recognised by write_whatever"
	END
END



////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{find_parenthesis_range}
{
given an index in a file, a left string, and a right string, extract the
index number of the left string and the matching right string
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION find_parenthesis_range
     INT_VAR index=0
	 STR_VAR left="{"
             right="}"
     RET     start
             end
BEGIN
     SET next_right="-1"
     SET start=INDEX_BUFFER("%left%" index)
     PATCH_IF start>=0 BEGIN
        SET indent=1
        SET loc=start + 1
        WHILE indent>0 BEGIN
           SET next_left = INDEX_BUFFER ("%left%" loc)
           SET next_right = INDEX_BUFFER ("%right%" loc)
           PATCH_IF next_right<0 BEGIN
              SET indent=0
              PATCH_WARN "Failed to properly extract next %left%---%right% section from file %SOURCE_RES%, starting at %index%" 
           END ELSE 
           PATCH_IF next_left<0 BEGIN
              SET indent -=1
              SET loc=next_right + 1
           END ELSE
           PATCH_IF (next_left<next_right && next_left>=0) BEGIN
              SET indent +=1
              SET loc=next_left + 1
           END ELSE BEGIN
              SET indent -=1
              SET loc=next_right + 1
           END
        END
        SET end=next_right
     END ELSE BEGIN
		end="-1"
	 END
END

////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{GET_UNIQUE_FILE_NAME}
{
A temporary fix for the WEIDU version, until Wisp fixes it.

(deprecated as of WEIDU v248, which fixes the bug.)
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////


/*
DEFINE_PATCH_FUNCTION ~GET_UNIQUE_FILE_NAME~
  STR_VAR
          extension = ""
          base = ""
  RET filename
  BEGIN
    PATCH_IF ~%extension%~ STRING_EQUAL_CASE ~~ THEN BEGIN
      PATCH_FAIL ~GET_UNIQUE_FILE_NAME requires to define the extension variable.~
    END

    INNER_ACTION BEGIN
      ACTION_IF ! FILE_EXISTS_IN_GAME ~get_unique_filename_%extension%.ids~ THEN BEGIN
        <<<<<<<< empty
        >>>>>>>>
        COPY + empty ~override/get_unique_filename_%extension%.ids~
      END
    END

    value = ("%base%" STR_CMP "")? IDS_OF_SYMBOL (~get_unique_filename_%extension%~ ~%base%~): 0 - 1
	PATCH_IF value = 0 - 1 THEN BEGIN
      found = 0
      WHILE !found BEGIN
        ++value
        LPF ~BASE36~ INT_VAR value = value RET maybe = base36 END
        LOOKUP_IDS_SYMBOL_OF_INT exists ~get_unique_filename_%extension%~ value
        PATCH_IF IS_AN_INT exists
          && !FILE_EXISTS_IN_GAME ~__%maybe%.%extension%~ THEN BEGIN
          found = 1
        END
      END
      PATCH_IF "%base%" STR_CMP "" BEGIN
		  INNER_ACTION BEGIN
			APPEND + ~get_unique_filename_%extension%.ids~ ~%value% %base%~
		  END
	  END
    END ELSE BEGIN
      LPF ~BASE36~ INT_VAR value = value RET maybe = base36 END
    END

    SPRINT filename ~__%maybe%~
END

DEFINE_ACTION_FUNCTION GET_UNIQUE_FILE_NAME
  STR_VAR
          extension = ""
          base = ""
  RET filename
  BEGIN
	OUTER_PATCH "" BEGIN
		LPF GET_UNIQUE_FILE_NAME STR_VAR extension base RET filename END
	END
END
*/

////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{append}
{
Append the string 'arguments' at the end of the file 'file' at locations given by location/locbase/path (only use 'path' if you want to run self-contained), or, in patch context, at the end of the current file, with no spacing or line breaks
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION append 
	STR_VAR arguments=""
BEGIN
	insert_point=BUFFER_LENGTH
	INSERT_BYTES insert_point STRING_LENGTH "%arguments%"
	WRITE_ASCII insert_point "%arguments%"
END

DEFINE_ACTION_FUNCTION append
	INT_VAR no_log=0
	STR_VAR arguments=""
			file=""
			location=""
			locbase=""
			path=""
BEGIN
	ACTION_IF "%location%%locbase%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR file path location locbase RET file_path END
	END ELSE BEGIN
		ACTION_IF "%path%" STR_EQ "" BEGIN
			OUTER_SPRINT "%file_path%" "%file%"
		END ELSE BEGIN
			OUTER_SPRINT "%file_path%" "%path%/%file%"
		END
	END
	ACTION_IF no_log BEGIN
		COPY + "%file_path%" "%file_path%"
			LPF append STR_VAR arguments END	
	END ELSE BEGIN
		COPY "%file_path%" "%file_path%"
			LPF append STR_VAR arguments END
	END
END

////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{new_file}
{
Create a new file 'file' at locations given by location/locbase/path (use only 'path' if you want to run self-contained), containing only the string 'arguments' with no spacing or line breaks
}
*/
////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_DIMORPHIC_FUNCTION new_file
	INT_VAR no_log=0
	STR_VAR arguments=""
			file=""
			location=""
			locbase=""
			path=""
BEGIN
	ACTION_IF "%location%%locbase%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR file path location locbase RET file_path END
	END ELSE BEGIN
		ACTION_IF "%path%" STR_EQ "" BEGIN
			OUTER_SPRINT "file_path" "%file%"
		END ELSE BEGIN
			OUTER_SPRINT "file_path" "%path%/%file%"
		END
	END
	ACTION_IF no_log BEGIN
		COPY + ".../stratagems-inline/blank" "%file_path%"
			LPF append STR_VAR arguments END	
	END ELSE BEGIN
		COPY ".../stratagems-inline/blank" "%file_path%"
			LPF append STR_VAR arguments END
	END
END
	
/*
ignore-dependencies{anon_define sfo_path}
describe-library{Functions to patch the Enhanced-Edition user interface.</p>

<p>These functions mostly work like this. An object in the current file (normally ui.menu, but sometimes a ui object extracted from ui.menu) is located by (i) the object type (e.g., 'menu'), a field in the object used to identify it (e.g., 'name' - this is the default value), and a value of that field (e.g., 'CHARGEN_CLASS'). 
The function then goes through the UI until it finds the (hopefully unique) object matching that description. The object is pulled out of ui.menu and patched; then it's substituted back in.<p>

<p>Technically this library depends on lib_anon (since it permits anonymous functions) and lib_sfo (since it uses sfo_path) but if you don't use either feature, it's self-contained.}

*/

/*
document{UI_alter_object}
{Apply the patch function 'patch' to the matched ui object in the current file, and substitute the result back in. You can use the anonymous function construct.}
*/

DEFINE_PATCH_FUNCTION UI_alter_object
    STR_VAR object="" 
            object_type=""
            object_name_field="name"
            patch=""//function
BEGIN
   LPF UI_patch_object_master STR_VAR object object_type object_name_field patch type=alter END
END

/*
document{UI_analyze_object}
{Apply the patch function 'patch' to the matched ui object in the current file. 'patch' should return an array called 'patch_output, which is in turn returned
by UI_analyze object return 'patch_output' The actual result of the patch is discarded (i.e., the file being patched isn't changed), so the purpose of
this is to extract information from ui.menu. You can use the anonymous function construct.}
*/

DEFINE_PATCH_FUNCTION UI_analyze_object
    STR_VAR object=""
            object_type=""
            object_name_field="name"
            patch=""//function
    RET_ARRAY patch_output
BEGIN
   LPF UI_patch_object_master STR_VAR object object_type object_name_field patch type=analyze RET_ARRAY patch_output END
END

/*
document{UI_return_object}
{Apply the patch function 'patch' to the matched ui object in the current file, and then return that object, as the value of a string variable.}
*/

DEFINE_PATCH_FUNCTION UI_return_object // for secondary analysis
    STR_VAR object=""
            object_type=""
            object_name_field="name"
            patch=""//function
    RET object_data
BEGIN
   LPF UI_patch_object_master STR_VAR object object_type object_name_field patch type=return RET object_data END
END

/*
document{UI_replace_object}
{Replace the matched ui object in the current file with the contents of the file 'replace' (optionally located at the location picked out by path/location/locbase in usual SFO fashion).}
*/

DEFINE_PATCH_FUNCTION UI_replace_object
    STR_VAR object=""
            object_type=""
            object_name_field="name"
            replace=""
			path=""
			location=""
			locbase=""
BEGIN
   INNER_ACTION BEGIN
	  ACTION_IF "%path%%location%%locbase%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR path location locbase file="%replace%" RET replace=file_path END
	  END
      COPY - "%replace%" nowhere EVALUATE_BUFFER
        READ_ASCII 0x0 insert_data (BUFFER_LENGTH)
        SPRINT insert_data "%WNL%%insert_data%%WNL%"
      BUT_ONLY
   END
   LPF UI_patch_object_master STR_VAR object object_type object_name_field type=replace insert_data END
END

/*
document{UI_insert_into_object}
{Insert the contents of the file 'insert' (optionally located at the location picked out by path/location/locbase in usual SFO fashion) at the end of the matched ui object in the current file. Alternately, insert the string 'insert_data' in this way.}
*/

DEFINE_PATCH_FUNCTION UI_insert_into_object
    STR_VAR object=""
            object_type=""
            object_name_field="name"
            insert=""
			insert_data=""
			path=""
			location=""
			locbase=""
BEGIN
   INNER_ACTION BEGIN
	  ACTION_IF "%path%%location%%locbase%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR path location locbase file="%insert%" RET insert=file_path END
	  END
	  ACTION_IF "%insert_data%" STR_EQ "" BEGIN
		  COPY - "%insert%" nowhere EVALUATE_BUFFER
			READ_ASCII 0x0 insert_data (BUFFER_LENGTH)
			SPRINT insert_data "%WNL%%insert_data%%WNL%"
		  BUT_ONLY
	  END
   END
   LPF UI_patch_object_master STR_VAR object object_type object_name_field type=insert_into insert_data END
END

DEFINE_PATCH_FUNCTION UI_patch_object_master//internal
    STR_VAR object=""
            object_type=""
            object_name_field="name"
            patch=""
            type=""
            insert_data=""
    RET object_data
    RET_ARRAY patch_output
BEGIN
    PATCH_IF INDEX ("[ <>=\+/*{}]" "%patch%")>=0 BEGIN
		LPF anon_define INT_VAR has_output=1 STR_VAR function="%patch%" RET patch=function SFO_anon_func_count END
    END
   SPRINT object_data ""
   SPRINT $patch_output("NULL") ""
   SET index=0
   WHILE index>=0 BEGIN
      SET index=INDEX_BUFFER ("%object_type%" index)
      PATCH_IF index>=0 BEGIN
          LPF find_parenthesis_range_localcopy STR_VAR left="{" right="}" index RET start end END
          PATCH_IF start<0 BEGIN
             SET index = "-1"
          END ELSE BEGIN
             READ_ASCII start+1 data (end - start - 1)
             SET change=0
             INNER_PATCH_SAVE data "%data%" BEGIN
                PATCH_IF ( INDEX_BUFFER (~%object_name_field%\( \|%TAB%\)*['"]?%object%['"]?~) > 0 || "%object%" STRING_EQUAL "") BEGIN
                   PATCH_MATCH "%type%" WITH
                   alter BEGIN
                       SET change=1
                       LPF "%patch%" END
                   END
                   analyze BEGIN
                      LPF "%patch%" RET_ARRAY patch_output END
                   END
                   insert_into BEGIN
                      SET change=1
                      SET end_here = BUFFER_LENGTH - 1
                      INSERT_BYTES end_here (STRING_LENGTH "%insert_data%")
                      WRITE_ASCIIE end_here "%insert_data%"
                   END
                   replace BEGIN
                       SET change=1
                       DELETE_BYTES 0x0 BUFFER_LENGTH
                       INSERT_BYTES 0x0 (STRING_LENGTH "%insert_data%")
                       WRITE_ASCIIE 0x0 "%insert_data%"
                   END
                   return BEGIN
                      READ_ASCII 0x0 object_data (BUFFER_LENGTH)
                   END
                   DEFAULT
                      PATCH_FAIL "internal error in UI_patch_object_master: undefined type %type%"
                   END 
                END
             END
             PATCH_IF change BEGIN
                  READ_ASCII start+1 info_here (end - start - 1)
                  DELETE_BYTES (start+1) ((end - start) - 1)
                  INSERT_BYTES (start+1) (STRING_LENGTH "%data%")
                  WRITE_ASCIIE (start+1) "%data%"
             END
             PATCH_IF change BEGIN
                SET index="-1"
             END ELSE BEGIN
             SET index=start + STRING_LENGTH "%data%"+2
             END
          END
      END
   END
END

/*
document{UI_add_function}
{
Adds the contents of the file 'function' (optionally located at the SFO location given by location/locbase/path) immediately before the first function definition in the current file.
(Use to add functions to UI.menu - but 99% of the time it's better to define them in your own custom lua file.)
}
*/

DEFINE_PATCH_FUNCTION UI_add_function
   STR_VAR function=""
			location=""
			locbase=""
			path=""
BEGIN
   INNER_ACTION BEGIN
      ACTION_IF "%location%%locbase%%path%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR file="%function%" location locbase path RET function=file_path END
	  END
      COPY - "%function%" nowhere EVALUATE_BUFFER
           READ_ASCII 0x0 function_data (BUFFER_LENGTH)
           SPRINT function_data "%WNL%%function_data%%WNL%"
      BUT_ONLY
   END
   SET insert_point = INDEX_BUFFER ("function ")
   INSERT_BYTES insert_point STRING_LENGTH "%function_data%"
   WRITE_ASCIIE insert_point "%function_data%"

END

/*
document{UI_add_string}
{
Add a string to the lua string file appropriate for the current game language (e.g., L_EN_US.lua if you're playing in English). 'string_id' is the lua string ID for the string; you can specify the string either via the INT_VAR tra_entry (an entry in your current .tra file) or directly as the STR_VAR 'string'.)
}
*/

DEFINE_ACTION_FUNCTION UI_add_string
    INT_VAR tra_entry=0
    STR_VAR string_id=""
            string=""
BEGIN
   ACTION_IF "%string%" STRING_EQUAL "" BEGIN
       OUTER_SPRINT string (AT tra_entry)
   END
   COPY_EXISTING "L_%EE_LANGUAGE%.lua" override
        REPLACE_TEXTUALLY ~uiStrings *= *{~ ~uiStrings = {%WNL%    %string_id% = "%string%",~
   BUT_ONLY
END

/*
document{UI_get_coordinates}
{
Look through the current file for the coordinates of an object (specified by four integers separated by spaces) and/or a bam file (specified by 'BAM [whatever]'). Return them in an array with keys bam, xloc, yloc, width, height.
(Use in conjuction with UI_analyze_object).
}
*/

DEFINE_PATCH_FUNCTION UI_get_coordinates
        RET_ARRAY patch_output
BEGIN
              REPLACE_EVALUATE "bam\(%WNL%\|%LNL%\|%MNL%\|%TAB%\| \)+\([^\(%WNL%\|%LNL%\|%MNL%\|%TAB%\| \)]*\)\(%WNL%\|%LNL%\|%MNL%\)" BEGIN
                SPRINT $patch_output("bam") "%MATCH2%"
              END
              "bam %MATCH2%%WNL%"
              REPLACE_EVALUATE "[^0-9]*\([0-9]+\)\( \|%TAB%\)+\([0-9]+\)\( \|%TAB%\)+\([0-9]+\)\( \|%TAB%\)+\([0-9]+\)[^0-9]*"
              BEGIN
                SET $patch_output("xloc")="%MATCH1%"
                SET $patch_output("yloc")="%MATCH3%"
                SET $patch_output("width")="%MATCH5%"
                SET $patch_output("height")="%MATCH7%"
              END
              ""

END

/*
document{UI_alter_function}
{
Find the lua function 'function' in the current file. Extract it, apply the patch function 'patch' to it (you can use the anonymous function construct) and put it back.</p>

<p>Note that the heuristic used to find the function is fairly crude: it assumes that the function finishes at the first 'end' that starts a new line. (This matches most, but not quite all,
functions in ui.menu.)
}
*/

DEFINE_PATCH_FUNCTION UI_alter_function
	STR_VAR function=""
			patch=""//function
BEGIN
		start=INDEX_BUFFER ("function %function%([^)]*)")
		end=INDEX_BUFFER ("[%WNL%%LNL%%MNL%]end" start)
		length_old=end + 4 - start
		PATCH_IF start<0 BEGIN
			PATCH_WARN "Unable to find function %function%() for patching"
		END ELSE BEGIN
			READ_ASCII start data (length_old)
			PATCH_IF INDEX ("[ <>=\+/*{}]" "%patch%")>=0 BEGIN
				 LPF anon_define INT_VAR has_output=1 STR_VAR function="%patch%" RET patch=function SFO_anon_func_count END
			END
			INNER_PATCH_SAVE new_data "%data%" BEGIN
				LPF "%patch%" END
				length_new=BUFFER_LENGTH
			END
			DELETE_BYTES start length_old
			INSERT_BYTES start length_new
			WRITE_ASCIIE start "%new_data%"
		END
END

/*
document{UI_replace_function}
{
Find the lua function 'function' in the current file. Replace it with the contents of the file at 'new_function' (legacy synonym: new_function_path), optionally located at the location specified SFO-style by location/locbase/path (or inline if inline=1.</p>

<p>Note that the heuristic used to find the function is fairly crude: it assumes that the function finishes at the first 'end' that starts a new line. (This matches most, but not quite all,
functions in ui.menu.)
}
*/

DEFINE_PATCH_FUNCTION UI_replace_function
	INT_VAR inline=0//boolean
	STR_VAR function=""
			new_function=""
			new_function_path=""
			location=""
			locbase=""
			path=""
BEGIN
	INNER_ACTION BEGIN
		OUTER_SPRINT new_function "%new_function%%new_function_path%"
		ACTION_IF "%location%%locbase%%path%" STR_CMP "" BEGIN
			LAF sfo_path STR_VAR location locbase path file="%new_function%" RET new_function=file_path END
		END
		ACTION_IF inline || FILE_EXISTS "%new_function%" BEGIN
		  COPY - "%new_function%" nowhere
			READ_ASCII 0x0 new_data (BUFFER_LENGTH)
			SET length_new=STRING_LENGTH "%new_data%"
			SET proceed=1
		  BUT_ONLY
		 END ELSE BEGIN
			WARN "Unable to swap out function %function%: no file found at %new_function%"
			OUTER_SET proceed=0
		 END
	END
	PATCH_IF proceed BEGIN
		start=INDEX_BUFFER ("function %function%([^)]*)")
		end=INDEX_BUFFER ("[%WNL%%LNL%%MNL%]end" start)
		length_old=end + 4 - start
		PATCH_IF start<0 BEGIN
			PATCH_WARN "Unable to find function %function%() for patching"
		END ELSE BEGIN
			READ_ASCII start data (length_old)
			DELETE_BYTES start length_old
			INSERT_BYTES start length_new
			WRITE_ASCIIE start "%new_data%"
		END
	END
END

/*
document{UI_install_function}
{
Add the contents of the file at 'new_function' (legacy synonym: new_function_path), optionally located at the location specified SFO-style by location/locbase/path (or inline if inline=1), to the end of the in-game lua file 'lua_file', creating it if necessary. If 'search_string' is set, only add the function if that string is not present in the lua already.</p>
}
*/

DEFINE_ACTION_FUNCTION UI_install_function 
	INT_VAR inline=0//boolean
	STR_VAR lua_file=""
			new_function=""
			new_function_path=""
			location=""
			locbase=""
			path=""
			search_string=""
BEGIN
	OUTER_SPRINT new_function "%new_function%%new_function_path%"
	ACTION_IF "%location%%locbase%%path%" STR_CMP "" BEGIN
		LAF sfo_path STR_VAR location locbase path file="%new_function%" RET new_function=file_path END
	END
	ACTION_IF inline || FILE_EXISTS "%new_function%" BEGIN
	  COPY - "%new_function%" nowhere
		READ_ASCII 0x0 new_data (BUFFER_LENGTH)
		SET length_new=STRING_LENGTH "%new_data%"
		SET proceed=1
	  BUT_ONLY
	 END ELSE BEGIN
		WARN "Unable to install function at %new_function%: no file found at %new_function%"
		OUTER_SET proceed=0
	 END


	ACTION_IF !FILE_EXISTS_IN_GAME "%lua_file%.lua" BEGIN
		COPY "%new_function%" "override/%lua_file%.lua"
	END ELSE BEGIN
		COPY_EXISTING "%lua_file%.lua" override
		ACTION_IF "%search_string%" STR_EQ "" || !FILE_CONTAINS "override/%lua_file%.lua" "%search_string%" BEGIN
			COPY_EXISTING "%lua_file%.lua" override
				APPEND_FILE TEXT "%new_function%" EVALUATE_BUFFER
		END
	
	END
END



DEFINE_PATCH_FUNCTION find_parenthesis_range_localcopy//internal
     STR_VAR left="{"
             right="}"
             index=0
     RET     start
             end
BEGIN
     SET next_right="-1"
     SET start=INDEX_BUFFER("%left%" index)
     PATCH_IF start>=0 BEGIN
        SET indent=1
        SET loc=start + 1
        WHILE indent>0 BEGIN
           SET next_left = INDEX_BUFFER ("%left%" loc)
           SET next_right = INDEX_BUFFER ("%right%" loc)
           PATCH_IF next_right<0 BEGIN
              SET indent=0
              PATCH_WARN "Failed to properly extract next %left%---%right% section from file %SOURCE_RES%, starting at %index%" 
           END ELSE 
           PATCH_IF next_left<0 BEGIN
              SET indent -=1
              SET loc=next_right + 1
           END ELSE
           PATCH_IF (next_left<next_right && next_left>=0) BEGIN
              SET indent +=1
              SET loc=next_left + 1
           END ELSE BEGIN
              SET indent -=1
              SET loc=next_right + 1
           END
        END
        SET end=next_right
     END ELSE BEGIN
		end="-1"
	 END
END
/*

describe-library{

The anonymous function construct. Functions here should build and apply anonymous functions, and not interact with IE resources.

Functions here should start with 'anon_'.

}

*/








//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
document{anon_define}
{Define the string 'function' as an anonymous patch function (setting its single STR_VAR input to 'input' and its single output to 'output'), and return the name of the function and an integer keeping track of how many anonymous functions have been defined.

The point of the integer is to avoid namespace collisions. By leaving it in scope for other calls of anon_define, we guarantee distinct functions.

We allow the following syntactic sugar for anon_define:

- '__' evaluates to '%input%'
- 'SFO_args' evaluates ro 'input'
- '{' and '}' evaluate to '%'

If 'has_output' is set to 1, but the output string doesn't appear in the function string, we assume it's an expression, and prepend a '[output]='.

}
*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION anon_define
	INT_VAR has_output=0//boolean
			action_function=0//boolean
			return_array=0//boolean
	STR_VAR function=""
			input=arguments
			output=value
			prepend=""
			append=""
	RET	function 
		SFO_anon_func_count
BEGIN
	OUTER_SPRINT percentage "%"
	OUTER_SPRINT function_old "%function%" // keep a copy
	// does it contain 'output'? (We'll check now to avoid collision with syntactic sugar)
	OUTER_SET contains_output=INDEX ("%output%" "%function%")>=0
	// carry out substitutions
	OUTER_PATCH_SAVE function_data "%function%" BEGIN
		SPRINT arg_string "%percentage%"^"arguments"^"%percentage%"
		REPLACE_TEXTUALLY "__" "%arg_string%"
		REPLACE_TEXTUALLY "SFO_args" arguments
		REPLACE_TEXTUALLY "arguments" "%input%"
		REPLACE_TEXTUALLY "value" "%output%"
		LPF sugar_apply INT_VAR patch_only=1 END
	END
	// if we need an output and don't get one, we assume it's an expression
	ACTION_IF has_output AND !contains_output BEGIN
		OUTER_SPRINT function_data "%output%=%function_data%"
		
	END
	// find the next free name
	ACTION_IF !VARIABLE_IS_SET SFO_anon_func_count BEGIN
		OUTER_SET SFO_anon_func_count=0
	END
	OUTER_SPRINT function "SFO_anon_func_%SFO_anon_func_count%"
	OUTER_SET ++ SFO_anon_func_count
	// copy the file and reinclude it
	ACTION_IF return_array BEGIN
		OUTER_SPRINT return_type "RET_ARRAY"
	END ELSE BEGIN
		OUTER_SPRINT return_type "RET"
	END
	ACTION_IF action_function BEGIN
		COPY + ".../strategems_inline/SFO_anon_func_action.tph" "%workspace%/%function%.tph" EVALUATE_BUFFER REPLACE_TEXTUALLY SFO_PERCENTAGE "%"// + so we can debug more easily		
	END ELSE BEGIN
		COPY + ".../strategems_inline/SFO_anon_func.tph" "%workspace%/%function%.tph" EVALUATE_BUFFER REPLACE_TEXTUALLY SFO_PERCENTAGE "%" // + so we can debug more easily
	END
	ACTION_TRY
		SILENT
		REINCLUDE "%workspace%/%function%.tph"
		VERBOSE
	WITH DEFAULT
		WARN "'%function_old%' is not a well-defined anonymous function; aborting."
		OUTER_SPRINT function "undefined"
	END
	// PRINT "%function% is set to %function_data%" // uncomment for telemetry
END


<<<<<<<< .../strategems_inline/SFO_anon_func.tph
DEFINE_PATCH_FUNCTION %function%
	STR_VAR %input%=""
	%return_type% %output%
BEGIN
	%output%=0
	%prepend%
	%function_data%
	%append%
END
>>>>>>>>

<<<<<<<< .../strategems_inline/SFO_anon_func_action.tph
DEFINE_ACTION_FUNCTION %function%
	STR_VAR %input%=""
	%return_type% %output%
BEGIN
	OUTER_SET %output%=0
	%prepend%
	%function_data%
	%append%
END
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

document{anon_check}
{
Check if 'function' is an anonymous function definition, and if so create it and return its name; if not, return 'function' itself.

A string is an anonymous function definition if it contains any of these: [ <>/=+*%curly_left%%curly_right%].  (If you somehow manage to define an anonymous function that doesn't
use any of these, just add a space at the beginning.)

}

*/


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_DIMORPHIC_FUNCTION anon_check
	INT_VAR has_output=0
	STR_VAR function=""
			input=arguments
			output=value
			prepend=""
			append=""
	RET	function 
		SFO_anon_func_count
BEGIN
	ACTION_IF INDEX ("[ <>=\+/*{}]" "%function%")>=0 BEGIN
		LAF anon_define INT_VAR has_output STR_VAR function input output prepend append RET function SFO_anon_func_count END
	END
	ACTION_IF !VARIABLE_IS_SET SFO_anon_func_count BEGIN 
		OUTER_SET SFO_anon_func_count=0
	END


END
	



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*

document{anon_eval}
{
Evaluate 'function' as an anonymous patch function, apply it to 'arguments', and return the result.
NB: anon_eval is not dimorphic. The action version runs on a blank patch. The patch version runs on whatever is
currently being patched.
}


*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION anon_eval
	INT_VAR has_output=0
	STR_VAR arguments=""
			function=""
			append=""
			prepend=""
	RET value
BEGIN
	OUTER_SET value=0
	LAF anon_define INT_VAR has_output STR_VAR function append prepend RET function SFO_anon_func_count END
	ACTION_IF "%function%" STR_CMP "undefined" BEGIN
		OUTER_PATCH "" BEGIN
			LPF "%function%" STR_VAR arguments RET value END	
		END
	END
END

DEFINE_PATCH_FUNCTION anon_eval
	INT_VAR has_output=0
	STR_VAR arguments=""
			function=""
			append=""
			prepend=""
	RET value
BEGIN
	value=0
	LPF anon_define INT_VAR has_output STR_VAR function append prepend RET function SFO_anon_func_count END
	PATCH_IF "%function%" STR_CMP "undefined" BEGIN
		LPF "%function%" STR_VAR arguments RET value END	
	END
END






DEFINE_DIMORPHIC_FUNCTION include INT_VAR inline=0 STR_VAR file="" files="" location="" locbase="" path="" BEGIN

	OUTER_SPRINT file "%file%%files%"
	ACTION_IF "%file%" STR_CMP "" BEGIN
	
		LAF return_first_entry STR_VAR list="%file%" RET file_here=entry file=list END
		ACTION_IF "%location%%locbase%%path%" STR_EQ "" BEGIN
			OUTER_SPRINT file_path "%MOD_FOLDER%/%component_loc%/%file_here%"
		END ELSE BEGIN
			LAF sfo_path STR_VAR file="%file_here%" location locbase path RET file_path END
		END
		COPY + "%file_path%" "%workspace%"
			LPF sugar_apply END
		REINCLUDE "%workspace%/%file_here%"
		
		// recurse
		
		LAF include INT_VAR inline STR_VAR file location locbase path END
		
	END


END

/*
document{run}
{
'file' (synonym: 'files') is a list of tpa files (leave off the suffix), located at the location specified by 'location', 'locbase', and 'path'. (If none are set, assume location is component_loc.) Each is loaded, and then each file's name is run
as an action function, with the STR_VAR argument 'version' fed to it, and with the tra file 'tra' (english and local-language versions) loaded. (So each tpa should conform to the SFO
convention of containing an action function of its own name.

When used outside an extant 'run' instruction (in the intended setup, this should be from your tp2 as the only instruction in the component,
though I can't enforce that), it sets 'component_loc' to 'location', defaults to using 'location' as the name of the tra file, and sets a marker file with 
name '%marker_prefix%%file%'. 'marker_prefix' defaults to 'sfo_marker_prefix', which in normal usage should have been set in your 'always' file.
}
*/

DEFINE_DIMORPHIC_FUNCTION run 
	STR_VAR file="" 
			files=""
			location="" 
			locbase="" 
			path="" 
			version="" 
			tra="" 
BEGIN
	OUTER_SPRINT file "%file%%files%"
	ACTION_IF !VARIABLE_IS_SET SFO_batch_mode BEGIN
		OUTER_SET SFO_batch_mode=0
	END
	ACTION_IF !VARIABLE_IS_SET SFO_reserved_outer_run BEGIN // only the outermost-scope 'run' sets the various variables
		ACTION_IF SFO_batch_mode BEGIN
			LAF append INT_VAR no_log=1 STR_VAR file="%MOD_FOLDER%.bat" path="%batch_loc%" arguments=" %COMPONENT_NUMBER%" END
		END ELSE BEGIN
			OUTER_SET SFO_reserved_outer_run=1
			ACTION_IF VARIABLE_IS_SET sfo_marker_prefix BEGIN
				LAF make_label STR_VAR label="%sfo_marker_prefix%%file%" END
			END
			OUTER_SPRINT component_loc "%location%"
			ACTION_IF "%tra%" STR_EQ "" BEGIN
				OUTER_SPRINT tra "%location%"
			END
			OUTER_SPRINT path "%MOD_FOLDER%/%location%"
		END
	END ELSE BEGIN
		LAF sfo_path STR_VAR path location locbase RET path END
	END
	
	ACTION_IF !SFO_batch_mode BEGIN
		ACTION_IF "%file%" STR_EQ "" BEGIN
			FAIL "The 'run' function requires an argument"
		END ELSE BEGIN
			WITH_TRA "%sfo_tra_loc%/english/%tra%.tra"  "%sfo_tra_loc%/%LANGUAGE%/%tra%.tra" BEGIN 
				PRINT "Including and running function(s) %file%"
				OUTER_WHILE "%file%" STR_CMP "" BEGIN
					LAF return_first_entry STR_VAR list="%file%" RET entry file=list END
					LAF include STR_VAR file="%entry%.tpa" location locbase path END
					ACTION_TIME "%entry%_timer" BEGIN
						ACTION_IF "%version%" STR_EQ "" BEGIN
							LAF "%entry%" END
						END ELSE BEGIN
							LAF "%entry%" STR_VAR version END
						END
					END
				END
		
			END
		END
	END
END
DEFINE_DIMORPHIC_FUNCTION RES_NUM_OF_SPELL_NAME
	INT_VAR silent=0
	STR_VAR spell_name=""
	RET spell_res spell_num success
BEGIN
	OUTER_SET success=0
	OUTER_SPRINT spell_res ""
	OUTER_SET spell_num=IDS_OF_SYMBOL (spell "%spell_name%")
	ACTION_IF spell_num<0 BEGIN
		ACTION_IF !VARIABLE_IS_SET data_loc_shared BEGIN
			OUTER_SPRINT data_loc_shared "weidu_external/data/dw_shared"
		END	
		ACTION_IF FILE_EXISTS "%data_loc_shared%/dw_ext_spell.ids" BEGIN
			COPY - "%data_loc_shared%/dw_ext_spell.ids" nowhere
				READ_2DA_ENTRIES_NOW ext_spell_data 2
				FOR (row=0;row<ext_spell_data;++row) BEGIN
					READ_2DA_ENTRY_FORMER ext_spell_data row 1 name
					PATCH_IF "%name%" STR_EQ "%spell_name%" BEGIN
						READ_2DA_ENTRY_FORMER ext_spell_data row 0 spell_res
					END
				END
			
		END
		ACTION_IF "%spell_res%" STR_EQ "" BEGIN
			CLEAR_IDS_MAP
			OUTER_SET spell_num=IDS_OF_SYMBOL (spell "%spell_res%")
		END
	END
	ACTION_IF spell_num>=0 BEGIN
		OUTER_PATCH_SAVE spell_res "%spell_num%" BEGIN
			REPLACE_TEXTUALLY "^1" "SPPR"
			REPLACE_TEXTUALLY "^2" "SPWI"
			REPLACE_TEXTUALLY "^3" "SPIN"
			REPLACE_TEXTUALLY "^4" "SPCL"
		END
	END
	OUTER_SET success=("%spell_res%" STR_CMP "")
	ACTION_IF !success && !silent BEGIN
		WARN "RES_NUM_OF_SPELL_NAME: cannot find spell %spell_name%"
	END
END	

DEFINE_DIMORPHIC_FUNCTION NAME_NUM_OF_SPELL_RES
	INT_VAR silent=0
	STR_VAR spell_res=""
	RET spell_name spell_num success
BEGIN
	OUTER_SET spell_num="-1"
	OUTER_SET success=0
	OUTER_SPRINT spell_name ""
	OUTER_SPRINT warning ""
	ACTION_TO_UPPER spell_res
	// is spell in standard format? is so get number
	OUTER_PATCH "%spell_res%" BEGIN
		REPLACE_EVALUATE
			"SP\(PR\|WI\|IN\|CL\)\([0-9A-Z][0-9A-Z][0-9A-Z]\)" BEGIN
				success=1
				PATCH_IF IS_AN_INT "%MATCH2%" BEGIN
					PATCH_MATCH "%MATCH1%" WITH
					"PR" BEGIN
						start=1
					END
					"WI" BEGIN
						start=2
					END
					"IN" BEGIN
						start=3
					END
					"CL" BEGIN
						start=4
					END
					DEFAULT
						PATCH_FAIL "shouldn't happen"
					END
					SPRINT spell_num "%start%%MATCH2%"
				END
			END
			""			
	END
	ACTION_IF !success BEGIN
		OUTER_SPRINT warning "NAME_NUM_OF_SPELL_RES: spell %spell_res% is not a legal form"
	END
	ACTION_IF success BEGIN
		OUTER_PATCH "" BEGIN
			// look up number, if it's set
			PATCH_IF spell_num>=0 BEGIN
				LOOKUP_IDS_SYMBOL_OF_INT spell_name spells spell_num
				PATCH_IF IS_AN_INT spell_name BEGIN
					INNER_ACTION BEGIN
						CLEAR_IDS_MAP
					END
					LOOKUP_IDS_SYMBOL_OF_INT spell_name spell spell_num
				
				END
				PATCH_IF IS_AN_INT spell_name BEGIN
					SPRINT spell_name ""
				END
			END
			// if you haven't found it, try dw_ext_spell.ids
			PATCH_IF "%spell_name%" STR_EQ "" BEGIN
				PATCH_IF !VARIABLE_IS_SET data_loc_shared BEGIN
					SPRINT data_loc_shared "weidu_external/data/dw_shared"
				END	
				PATCH_IF FILE_EXISTS "%data_loc_shared%/dw_ext_spell.ids" BEGIN
					INNER_ACTION BEGIN
						COPY - "%data_loc_shared%/dw_ext_spell.ids" nowhere
							READ_2DA_ENTRIES_NOW ext_spell_data 2
							FOR (row=0;row<ext_spell_data;++row) BEGIN
								READ_2DA_ENTRY_FORMER ext_spell_data row 0 res
								PATCH_IF "%res%" STR_EQ "%spell_res%" BEGIN
									READ_2DA_ENTRY_FORMER ext_spell_data row 1 spell_name
								END
							END
					END
				END
			END	
			PATCH_IF "%spell_name%" STR_EQ "" BEGIN
				success=0
				SPRINT warning "NAME_NUM_OF_SPELL_RES: spell %spell_res% is not listed in spell.ids or dw_ext_spell.ids"
			END
		END
	END
	ACTION_IF !silent && "%warning%" STR_CMP "" BEGIN
		WARN "%warning%"
	END
END
/*
describe-library{

This contains SFO's syntactic sugar, used by 'include', 'run', and anonymous functions.

}
*/

/*
document{sugar_apply}
{
Apply SFO's syntactic sugar to the current file. If 'patch_only' is set to 1, don't bother with the action parts.
}
*/

DEFINE_PATCH_FUNCTION sugar_apply 
	INT_VAR patch_only=0
BEGIN
	LPF sugar_remove_inline RET quote_index RET_ARRAY quote_array END
	LPF sugar_remove_quintuple_quotes INT_VAR quote_index RET quote_index RET_ARRAY quote_array END
	LPF sugar_decomment END
	LPF sugar_semicolons END
	PATCH_IF !patch_only BEGIN
		LPF sugar_action END
		LPF sugar_remove_quintuple_quotes INT_VAR quote_index RET_ARRAY quote_array END // do this again because sugar_action adds some ~~~~~ ~~~~~ that we don't want sugared (on pain of mangling the file)
	END
	LPF sugar_patch END
	LPF sugar_comparison END
	LPF sugar_replace_removed_data STR_VAR quote_array END
	

END

/*
document{sugar_decomment}
{
Remove //-style comments.
}
*/

DEFINE_PATCH_FUNCTION sugar_decomment//internal
BEGIN
	REPLACE_TEXTUALLY "//.*" ""
END


/*
document{sugar_semicolons}
{
Replace double semicolons with line breaks. 

}
*/

DEFINE_PATCH_FUNCTION sugar_semicolons BEGIN// internal
	REPLACE_TEXTUALLY ";;" "%WNL%"
END

/*
document{sugar_test}
{
Copy over the inline file 'sugartest.tp2' (at the end of this library) and apply syntactic sugar to it, then INCLUDE it to check it's well-formed.
}
*/
DEFINE_ACTION_FUNCTION sugar_test BEGIN

COPY + ".../stratagems-inline/sugartext.tp2" "%workspace%"
	REPLACE_TEXTUALLY inline_start "<<<<<<<<"
	REPLACE_TEXTUALLY inline_end ">>>>>>>>"
	LPF sugar_apply END
	
INCLUDE "%workspace%/sugartext.tp2"


END

/*
document{sugar_comparison}
{
Swap in simpler versions of string comparison
}
*/

DEFINE_PATCH_FUNCTION sugar_comparison//internal
BEGIN 

	REPLACE_TEXTUALLY ~~~~~\([0-9a-z_%]+\) *!==~~~~~ "\1 STR_CMP " 
	REPLACE_TEXTUALLY ~~~~~\(~[0-9a-z_%]+~\) *!==~~~~~ "\1 STR_CMP " 
	REPLACE_TEXTUALLY ~~~~~\("[0-9a-z_%]+"\) *!==~~~~~ "\1 STR_CMP " 
	REPLACE_TEXTUALLY ~~~~~\([0-9a-z_%]+\) *==~~~~~ "\1 STR_EQ "
	REPLACE_TEXTUALLY ~~~~~\("[0-9a-z_%]+"\) *==~~~~~ "\1 STR_EQ "
	REPLACE_TEXTUALLY ~~~~~\(~[0-9a-z_%]+~\) *==~~~~~ "\1 STR_EQ "

END


/*
document{sugar_action}
{
Handle SFO abbreviations for action functions
}
*/

DEFINE_PATCH_FUNCTION sugar_action//internal
BEGIN
	SPRINT percentage "%"

	// control flow
	
	REPLACE_TEXTUALLY "^[ %TAB%]*IF[ %TAB%]*\[\([^]]*\)\]" "ACTION_IF \1 "

	// change context
	

	REPLACE_TEXTUALLY "^[ %TAB%]*\[\[\[" "%WNL%OUTER_PATCH ~~ BEGIN%WNL%"
	REPLACE_TEXTUALLY "^[ %TAB%]*\]\]\]" "%WNL%END%WNL%"

	// open/close

	// we're going to risk not checking for newline here if there's a preceding space or tab (there are some esoteric regexps this might mess up, e.g. some in this code itself, but I think not anything we'll see outside a library

	REPLACE_TEXTUALLY "\(^\[\[\|[ %TAB%]\[\[\)" "%WNL%BEGIN%WNL%"
	REPLACE_TEXTUALLY "\(^\]\]\|[ %TAB%]\]\]\)" "%WNL%END%WNL%"
	

	// array object specials

	REPLACE_EVALUATE "array\.\(new\|add\) *\[\([^]]+\)\][ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]+\)\]" BEGIN
		SPRINT type "%MATCH1%"
		SPRINT array "%MATCH2%"
		SPRINT contents "%MATCH3%"
		PATCH_IF "%type%" STR_EQ new BEGIN
			SPRINT output "ACTION_CLEAR_ARRAY %array%%WNL%"
		END ELSE BEGIN
			SPRINT output ""
		END
	END
	"%output%ACTION_DEFINE_ASSOCIATIVE_ARRAY %array% BEGIN%WNL%%contents%%WNL%END"

	// id object specials
	
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_]+\)\.\(int\|sym\)[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" BEGIN
		PATCH_IF "%MATCH3%" STR_EQ "int" BEGIN
			SPRINT out "OUTER_SET %MATCH1%=IDS_OF_SYMBOL(%MATCH2% %MATCH4%)"
		END ELSE BEGIN
			SPRINT out ~OUTER_PATCH "" BEGIN LOOKUP_IDS_SYMBOL_OF_INT %MATCH1% %MATCH2% %MATCH4% END~
		END
	END
	"%out%"	

	// strref object special
	
	REPLACE_TEXTUALLY "^[ %TAB%]*strref\.patch[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\][ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" 
	~OUTER_SET SFO_anon_strref=\1
	 ACTION_GET_STRREF SFO_anon_strref SFO_anon_str
	 OUTER_PATCH_SAVE SFO_anon_str "%percentage%SFO_anon_str%percentage%" BEGIN
	 \2
	 END
	 STRING_SET_EVALUATE SFO_anon_strref "%percentage%SFO_anon_str%percentage%"
	 ~
	REPLACE_TEXTUALLY "^[ %TAB%]*strref\.patch[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\][ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" 
	~OUTER_SET SFO_anon_strref=\1
	 ACTION_GET_STRREF SFO_anon_strref SFO_anon_str
	 OUTER_PATCH_SAVE SFO_anon_str "%percentage%SFO_anon_str%percentage%" BEGIN
	 \2
	 END
	 STRING_SET_EVALUATE SFO_anon_strref "%percentage%SFO_anon_str%percentage%"
	 ~



	// str object specials
	
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_]+\)\.\(patch\|print\|strref\)[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" BEGIN
		PATCH_MATCH "%MATCH3%" WITH
		"print" BEGIN
			SPRINT end_command ~PRINT "%percentage%SFO_anon_output%percentage%"%WNL%OUTER_SPRINT %MATCH1% "%percentage%SFO_anon_output%percentage%"%WNL%~
		END
		"strref" BEGIN
			SPRINT end_command ~OUTER_SET %MATCH1%= RESOLVE_STR_REF ("%percentage%SFO_anon_output%percentage%")%WNL%~	
		END
		"patch" BEGIN
			SPRINT end_command ~OUTER_SPRINT %MATCH1% "%percentage%SFO_anon_output%percentage%"%WNL%~	 
		END
		DEFAULT
		END
	END
	~OUTER_PATCH_SAVE SFO_anon_output "%percentage%%MATCH2%%percentage%" BEGIN %MATCH4% END%WNL%%end_command%~


	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)\.\(patch\|print\|strref\)[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" BEGIN
		PATCH_MATCH "%MATCH2%" WITH
		"print" BEGIN
			SPRINT end_command ~PRINT "%percentage%SFO_anon_output%percentage%"%WNL%~
		END
		"strref" BEGIN
			SPRINT end_command ~OUTER_SET SFO_anon_strref= RESOLVE_STR_REF ("%percentage%SFO_anon_output%percentage%")%WNL%~	
		END
		"patch" BEGIN
			SPRINT end_command ""
		END
		DEFAULT
		END
	END
	~OUTER_PATCH_SAVE SFO_anon_output "%percentage%%MATCH1%%percentage%" BEGIN %MATCH3% END%WNL%%end_command%~


	//function definitions
	
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*def\.\([apmd]\)[ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\][ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" BEGIN
		PATCH_MATCH "%MATCH2%" WITH
		a BEGIN
			SPRINT fn "DEFINE_ACTION_FUNCTION"
		END
		p BEGIN
			SPRINT fn "DEFINE_PATCH_FUNCTION"
		END
		m d BEGIN
			SPRINT fn "DEFINE_DIMORPHIC_FUNCTION"
		END
		DEFAULT
			PATCH_FAIL "shouldn't happen"
		END
		LPF sugar_parse_fundef_args STR_VAR args="%MATCH3%" RET ints strs END
		LPF sugar_parse_fundef_rets STR_VAR args="%MATCH4%" RET rets retarrays END
	END
	"%WNL%%fn% %MATCH1%%WNL%%TAB%INT_VAR%WNL%%ints%%TAB%STR_VAR%WNL%%strs%%TAB%%rets%%TAB%%retarrays%"

	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*def\.\([a-z]+\)\[\]" BEGIN
		PATCH_MATCH "%MATCH2%" WITH
		c BEGIN
			SPRINT fn "DEFINE_ACTION_FUNCTION"
			SPRINT strs ~%TAB%%TAB%version=""%WNL%~
			SPRINT rets ""
		END
		s sc BEGIN
			SPRINT fn "DEFINE_ACTION_FUNCTION"
			SPRINT strs ""
			SPRINT rets ""
		END
		sfo BEGIN
			SPRINT fn "DEFINE_PATCH_FUNCTION"
			SPRINT strs ~%TAB%%TAB%arguments=""%WNL%~
			SPRINT rets "%TAB%RET%WNL%%TAB%%TAB%value%WNL%"
		END
		sfoa BEGIN
			SPRINT fn "DEFINE_ACTION_FUNCTION"
			SPRINT strs ~%TAB%%TAB%arguments=""%WNL%~
			SPRINT rets "%TAB%RET%WNL%%TAB%%TAB%value%WNL%"
		END		
		DEFAULT
			PATCH_FAIL "%MATCH2% is an unrecognized function type"
		END
	END
	"%WNL%%fn% %MATCH1%%WNL%%TAB%STR_VAR%WNL%%strs%%TAB%%rets%"

	// functions with return values
	// newline crucial here, we don't want to mangle regexps
	REPLACE_EVALUATE "^[ %TAB%]*\([a-zA-Z0-9_,]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_.]+\)[ %TAB%%WNL%%MNL%%LNL%]*\(\[[^]]*\][ %TAB%%WNL%%MNL%%LNL%]*\[[^]]*\]\|\[[^]]*\]\)" BEGIN
		
		LPF sugar_parse_function STR_VAR function="%MATCH2%" RET input input2 function struct type output output2 output_array END
		SPRINT args "%MATCH3%"
		LPF sugar_parse_action_arguments STR_VAR args="%MATCH3%" input input2 struct type RET ints strs END
		LPF sugar_parse_returns INT_VAR output_array STR_VAR returns="%MATCH1%" output output2 struct RET ret END
	END
	"LAF %function%%WNL%%TAB%INT_VAR%WNL%%ints%%TAB%STR_VAR%WNL%%strs%%ret%END"

	// functions without return values
	// newline crucial here, we don't want to mangle regexps
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_.]+\)[ %TAB%%WNL%%MNL%%LNL%]*\(\[[^]]*\][ %TAB%%WNL%%MNL%%LNL%]*\[[^]]*\]\|\[[^]]*\]\)" BEGIN
		LPF sugar_parse_function STR_VAR function="%MATCH1%" RET input input2 function struct type END
		LPF sugar_parse_action_arguments STR_VAR args="%MATCH2%" input input2 struct type RET ints strs END
		PATCH_IF "%struct%" STR_CMP "" BEGIN
			SPRINT ret "%TAB%RET_ARRAY%WNL%%TAB%%TAB%%struct%=struct%WNL%"
		END ELSE BEGIN
			SPRINT ret ""
		END
	END
	"LAF %function%%WNL%%TAB%INT_VAR%WNL%%ints%%TAB%STR_VAR%WNL%%strs%%ret%END"

// quicker string allocations/comparisons
	REPLACE_TEXTUALLY ~~~~~\([0-9a-z_%]+\) *:==~~~~~ "OUTER_SPRINT \1 "
	REPLACE_TEXTUALLY ~~~~~\(~[0-9a-z_%]+~\) *:==~~~~~ "OUTER_SPRINT \1 "
	REPLACE_TEXTUALLY ~~~~~\("[0-9a-z_%]+"\) *:==~~~~~ "OUTER_SPRINT \1 "

	// legacy
	
	REPLACE_TEXTUALLY PATCH_MAKE_PATCH ~PATCH_CLEAR_ARRAY patch_data PATCH_DEFINE_ASSOCIATIVE_ARRAY patch_data BEGIN~
	REPLACE_TEXTUALLY MAKE_PATCH ~ACTION_CLEAR_ARRAY patch_data ACTION_DEFINE_ASSOCIATIVE_ARRAY patch_data BEGIN~
	REPLACE_TEXTUALLY "PUSH ~\([^ ~]+\)~ " ~SPRINT "\1" "%\1% "^~
	REPLACE_TEXTUALLY "PUSH \([^ ~]+\)" ~SPRINT "\1" "%\1% "^~
	REPLACE_TEXTUALLY "PUSH_RANDOM \([^ ]+\) (\([^)]+\))" ~LPF internal_push_random STR_VAR list="%\1%" to_add="\2" RET \1=list END~


END

/*
document{sugar_patch}
{
Handle SFO abbreviations for patch functions
}
*/

DEFINE_PATCH_FUNCTION sugar_patch//internal
BEGIN
	SPRINT percentage "%"

	// control flow
	
	REPLACE_TEXTUALLY "^[ %TAB%]*IF[ %TAB%]*{\([^}]*\)}" "PATCH_IF \1 "

	// change context
	
	REPLACE_TEXTUALLY "{{{" "%WNL%INNER_ACTION BEGIN%WNL%"
	REPLACE_TEXTUALLY "}}}" "%WNL%END%WNL%"

	// begin/end
	// we're going to risk not checking for newline here 

	REPLACE_TEXTUALLY "{{" "%WNL%BEGIN%WNL%"
	REPLACE_TEXTUALLY "}}" "%WNL%END%WNL%"

	// array object specials

	REPLACE_EVALUATE "array\.\(new\|add\) *{\([^}]+\)}[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]+\)}" BEGIN
		SPRINT type "%MATCH1%"
		SPRINT array "%MATCH2%"
		SPRINT contents "%MATCH3%"
		PATCH_IF "%type%" STR_EQ new BEGIN
			SPRINT output "CLEAR_ARRAY %array%%WNL%"
		END ELSE BEGIN
			SPRINT output ""
		END
	END
	"%output%DEFINE_ASSOCIATIVE_ARRAY %array% BEGIN%WNL%%contents%%WNL%END"

	// id object specials
	
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_]+\)\.\(int\|sym\)[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" BEGIN
		PATCH_IF "%MATCH3%" STR_EQ "int" BEGIN
			SPRINT out "SET %MATCH1%=IDS_OF_SYMBOL(%MATCH2% %MATCH4%)"
		END ELSE BEGIN
			SPRINT out ~LOOKUP_IDS_SYMBOL_OF_INT %MATCH1% %MATCH2% %MATCH4%~
		END
	END
	"%out%"
	

	// strref object special
	
	REPLACE_TEXTUALLY "^[ %TAB%]*strref\.patch[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" 
	~SET SFO_anon_strref=\1
	 GET_STRREF SFO_anon_strref SFO_anon_str
	 INNER_PATCH_SAVE SFO_anon_str "%percentage%SFO_anon_str%percentage%" BEGIN
	 \2
	 END
	 INNER_ACTION BEGIN
		STRING_SET_EVALUATE SFO_anon_strref "%percentage%SFO_anon_str%percentage%"
	END
	 ~

	// str object specials
	
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_]+\)\.\(patch\|print\|strref\)[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" BEGIN
		PATCH_MATCH "%MATCH3%" WITH
		"print" BEGIN
			SPRINT end_command ~PATCH_PRINT "%percentage%SFO_anon_output%percentage%"%WNL%SPRINT %MATCH1% "%percentage%SFO_anon_output%percentage%"%WNL%~
		END
		"strref" BEGIN
			SPRINT end_command ~SET %MATCH1%= RESOLVE_STR_REF ("%percentage%SFO_anon_output%percentage%")%WNL%~	
		END
		"patch" BEGIN
			SPRINT end_command ~SPRINT %MATCH1% "%percentage%SFO_anon_output%percentage%"%WNL%~	 
		END
		DEFAULT
		END
	END
	~INNER_PATCH_SAVE SFO_anon_output "%percentage%%MATCH2%%percentage%" BEGIN %MATCH4% END%WNL%%end_command%~

	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_]+\)\.\(patch\|print\|strref\)[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" BEGIN
		PATCH_MATCH "%MATCH2%" WITH
		"print" BEGIN
			SPRINT end_command ~PATCH_PRINT "%percentage%SFO_anon_output%percentage%"%WNL%~
		END
		"strref" BEGIN
			SPRINT end_command ~SET SFO_anon_strref= RESOLVE_STR_REF ("%percentage%SFO_anon_output%percentage%")%WNL%~	
		END
		"patch" BEGIN
			SPRINT end_command ""
		END
		DEFAULT
		END
	END
	~INNER_PATCH_SAVE SFO_anon_output "%percentage%%MATCH1%%percentage%" BEGIN %MATCH3% END%WNL%%end_command%~

	// functions with return values
	// newline crucial here, we don't want to mangle regexps
	REPLACE_EVALUATE "^[ %TAB%]*\([A-Za-z0-9_,]+\)[ %TAB%%WNL%%MNL%%LNL%]*=[ %TAB%%WNL%%MNL%%LNL%]*\([a-z0-9_.]+\)[ %TAB%%WNL%%MNL%%LNL%]*\({[^}]*}[ %TAB%%WNL%%MNL%%LNL%]*{[^}]*}\|{[^}]*}\)" BEGIN
		
		LPF sugar_parse_function STR_VAR function="%MATCH2%" RET input input2 function struct type output output2 output_array END
		LPF sugar_parse_patch_arguments STR_VAR args="%MATCH3%" input input2 struct type RET ints strs END
		LPF sugar_parse_returns INT_VAR output_array STR_VAR returns="%MATCH1%" output output2 struct RET ret END
	END
	"LPF %function%%WNL%%TAB%INT_VAR%WNL%%ints%%TAB%STR_VAR%WNL%%strs%%ret%END"
	// functions without return values
	// newline crucial here, we don't want to mangle regexps
	REPLACE_EVALUATE "^[ %TAB%]*\([a-z0-9_.]+\)[ %TAB%%WNL%%MNL%%LNL%]*\({[^}]*}[ %TAB%%WNL%%MNL%%LNL%]*{[^}]*}\|{[^}]*}\)" BEGIN
		LPF sugar_parse_function STR_VAR function="%MATCH1%" RET input input2 function struct type END
		LPF sugar_parse_patch_arguments STR_VAR args="%MATCH2%" input input2 struct type RET ints strs END
		PATCH_IF "%struct%" STR_CMP "" BEGIN
			SPRINT ret "%TAB%RET_ARRAY%WNL%%TAB%%TAB%%struct%=struct%WNL%"
		END ELSE BEGIN
			SPRINT ret ""
		END
	END
	"LPF %function%%WNL%%TAB%INT_VAR%WNL%%ints%%TAB%STR_VAR%WNL%%strs%%ret%END"




	REPLACE_TEXTUALLY ~~~~~\([0-9a-z_%]+\) *:=~~~~~ "SPRINT \1 "
	REPLACE_TEXTUALLY ~~~~~\(~[0-9a-z_%]+~\) *:=~~~~~ "SPRINT \1 "
	REPLACE_TEXTUALLY ~~~~~\(~[0-9a-z_%]+~\) *:=~~~~~ "SPRINT \1 "

END

//////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_fundef_args}
{
Parse the function definition for INT_VARs and STR_VARs
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION sugar_parse_fundef_args//internal
	STR_VAR args=""
	RET ints strs 
BEGIN
	SPRINT ints ""
	SPRINT strs ""
	WHILE "%args%" STR_CMP "" BEGIN
		is_int=0
		LPF return_first_entry STR_VAR list="%args%" RET entry args=list END
		PATCH_IF INDEX ("=" "%entry%") >=0 BEGIN
			INNER_PATCH_SAVE entry "%entry%" BEGIN
				REPLACE_TEXTUALLY "[ %TAB%]*=[ %TAB%]*" "="
				REPLACE_TEXTUALLY ":s=" "="
				REPLACE_EVALUATE ":i=" BEGIN
					is_int=1
				END
				"="
			END
		END ELSE BEGIN		
			INNER_PATCH_SAVE entry "%entry%" BEGIN
				REPLACE_TEXTUALLY ":s$" ""
				REPLACE_EVALUATE ":i$" BEGIN
					is_int=1
				END
				""
			END
			PATCH_IF is_int BEGIN
				SPRINT entry "%entry%=0"
			END ELSE BEGIN
				SPRINT entry "%entry%=~~"
			END
		END
		PATCH_IF is_int BEGIN
			SPRINT ints "%ints%%TAB%%TAB%%entry%%WNL%"
		END ELSE BEGIN
			SPRINT strs "%strs%%TAB%%TAB%%entry%%WNL%"		
		END
	
	END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_fundef_args}
{
Parse the function definition for INT_VARs and STR_VARs
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION sugar_parse_fundef_rets//internal
	STR_VAR args=""
	RET rets retarrays
BEGIN
	SPRINT rets ""
	SPRINT retarrays ""
	WHILE "%args%" STR_CMP "" BEGIN
		LPF return_first_entry STR_VAR list="%args%" RET var=entry args=list END
		
		INNER_PATCH_SAVE var "%var%" BEGIN
			is_array=0
			REPLACE_EVALUATE ":a$" BEGIN
				is_array=1
			END
			""
		END
		PATCH_IF is_array && "%val%" STR_EQ "" BEGIN
			val=0
		END
		PATCH_IF is_array BEGIN
			SPRINT rets "%rets%%TAB%%TAB%%var%%WNL%"
		END ELSE BEGIN
			SPRINT retarrays "%retarrays%%TAB%%TAB%%var%%WNL%"		
		END
	
	END
	PATCH_IF "%rets%" STR_CMP "" BEGIN
		SPRINT rets "%TAB%RET%WNL%%rets%"
	END
	PATCH_IF "%retarrays%" STR_CMP "" BEGIN
		SPRINT retarrays "%TAB%RET_ARRAY%WNL%%retarrays%"
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_function}
{
Parse the function for virtual-object data
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION sugar_parse_function//internal
	STR_VAR function=""
	RET input input2 function struct output output2 type output_array 
BEGIN
	output_array=0
	finished=0
	SPRINT struct ""
	SPRINT object ""
	SPRINT type ""
	SPRINT input2 ""
	SPRINT output value
	SPRINT output2 ""
	INNER_PATCH "%function%" BEGIN
		REPLACE_EVALUATE "\([a-z0-9_]+\)\.\([a-z0-9_]+\)\.\(alter\|delete\|clone\|add\)" BEGIN
			finished=1
			SPRINT type "%MATCH2%"
			SPRINT struct "%MATCH1%"
			SPRINT function "struct_%MATCH3%"
			PATCH_MATCH "%MATCH3%" WITH
			alter clone add BEGIN
				SPRINT input patch
			END
			delete BEGIN
				SPRINT input match
			END
			DEFAULT
			END
		END
		""
	END
	PATCH_IF !finished BEGIN
		INNER_PATCH_SAVE function_base "%function%" BEGIN
			REPLACE_EVALUATE "^\(.*\)\." BEGIN
				SPRINT object "%MATCH1%"
			END
			""
		END
		PATCH_IF "%object%" STR_CMP "" BEGIN
			SPRINT function "%object%_%function_base%"
		END
		PATCH_MATCH "%object%" WITH
		struct BEGIN
			output_array=1
			SPRINT input struct
			SPRINT output struct
		END
		2da array BEGIN
			output_array=1
			SPRINT input array
			SPRINT input2 ""
			SPRINT output array
		END
		are cre eff pro itm sto spl BEGIN
			SPRINT input "%object%"
			SPRINT input2 "edits"
			SPRINT output value
			SPRINT output2 scroll
		END
		kit class BEGIN
			PATCH_IF "%function%" STR_EQ "kit_edit_all" BEGIN
				SPRINT input "parent_class"
			END ELSE BEGIN
				SPRINT input "%object%"
			END
			SPRINT input2 "edits"
		END
		"" BEGIN
			SPRINT input "arguments"
			SPRINT input2 ""
		END
		DEFAULT // struct is default		
			SPRINT input "arguments"
			SPRINT input2 ""
			SPRINT output value
			SPRINT struct "%object%"
			SPRINT function "%function_base%"
		END
	END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_returns}
{
Work out the 'RET' and 'RET_ARRAY' section of the function
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_parse_returns//internal 
	INT_VAR output_array=0
	STR_VAR returns=""
			output=""
			output2=""
			struct=""
	RET ret
BEGIN
	// process the input
	LPF return_first_entry STR_VAR list="%returns%" separator="," RET o=entry o2=list END
	SPRINT temp "%TAB%%TAB%%o%=%output%%WNL%"
	PATCH_IF "%o2%" STR_CMP "" BEGIN
		PATCH_IF "%output2%" STR_CMP "" BEGIN
			SPRINT temp "%temp%%TAB%%TAB%%o2%=%output2%%WNL%"
		END ELSE BEGIN
			PATCH_WARN "sugar_parse_returns: second output (%o2%) requested, but this virtual object has no second return type"
		END
	END
	PATCH_IF output_array BEGIN
		SPRINT strs ""
		SPRINT arrs "%temp%"
	END ELSE BEGIN
		SPRINT strs "%temp%"
		SPRINT arrs ""
	END
	// deal with structs
	PATCH_IF "%struct%" STR_CMP "" BEGIN
		SPRINT arrs "%arrs%%TAB%%TAB%%struct%=struct%WNL%"
	END
	// make final return
	SPRINT ret ""
	PATCH_IF "%strs%" STR_CMP "" BEGIN
		SPRINT ret "%ret%%TAB%RET%WNL%%strs%"
	END
	PATCH_IF "%arrs%" STR_CMP "" BEGIN
		SPRINT ret "%ret%%TAB%RET_ARRAY%WNL%%arrs%"
	END
	
END


///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_action_arguments}
{
Preliminary processing: extract the contents of the argument bracket(s)
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_parse_action_arguments//internal
	STR_VAR args=""
			input=""
			input2=""
			struct=""
			type=""
	RET ints strs
BEGIN
	SPRINT ints ""
	SPRINT strs ""
	// get the contents of brackets
	SPRINT args1 ""
	SPRINT args2 ""
	INNER_PATCH "%args%" BEGIN
		REPLACE_EVALUATE "\[\([^]]*\)\][ %TAB%%WNL%%MNL%%LNL%]*\[\([^]]*\)\]" BEGIN
			SPRINT args1 "%MATCH1%"
			SPRINT args2 "%MATCH2%"
		END
		""
		REPLACE_EVALUATE "\[\([^]]*\)\]" BEGIN
			SPRINT args1 "%MATCH1%"
			SPRINT args2 ""
		END	
		""
	END
	PATCH_IF "%input2%" STR_EQ "edits" BEGIN
		INNER_PATCH_SAVE args2 "%args2%" BEGIN
			REPLACE_TEXTUALLY "%" "SFO_PERCENTAGE"
		END
	END
	LPF sugar_parse_arguments STR_VAR input input2 args1 args2 struct RET ints strs END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_patch_arguments}
{
Exactly like sugar_parse_action_arguments, but with curly brackets instead of square brackets
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_parse_patch_arguments//internal
	STR_VAR args=""
			input=""
			input2=""
			struct=""
			type=""
	RET ints strs
BEGIN
	SPRINT ints ""
	SPRINT strs ""
	// get the contents of brackets
	SPRINT args1 ""
	SPRINT args2 ""
	INNER_PATCH "%args%" BEGIN
		REPLACE_EVALUATE "{\([^}]*\)}[ %TAB%%WNL%%MNL%%LNL%]*{\([^}]*\)}" BEGIN
			SPRINT args1 "%MATCH1%"
			SPRINT args2 "%MATCH2%"
		END
		""
		REPLACE_EVALUATE "{\([^}]*\)}" BEGIN
			SPRINT args1 "%MATCH1%"
			SPRINT args2 ""
		END	
		""
	END
	LPF sugar_parse_arguments STR_VAR input input2 args1 args2 struct RET ints strs END
END


///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_parse_arguments}
{
Work out the STR_VAR/INT_VAR part of the function, using info from sugar_parse_[patch|action]_arguments
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_parse_arguments//internal
	STR_VAR args1=""
			args2=""
			input=""
			input2=""
			struct=""
	RET ints strs
BEGIN
	SPRINT strs ""
	SPRINT ints ""
	INNER_PATCH_SAVE args1 "%args1%" BEGIN
		REPLACE_TEXTUALLY "|" " | " // handle {|blah} correctly
	END
	// separate out first argument into default and rest
	PATCH_IF "%args1%" STR_CMP "" BEGIN
		LPF return_first_entry STR_VAR list="%args1%" separator="|" RET default=entry rest=list END
		LPF trim_string STR_VAR string="%default%" RET default=string END
		// default argument
		PATCH_IF "%default%" STR_CMP "" BEGIN
			SPRINT strs "%strs%%TAB%%TAB%%input%=~~~~~%default%~~~~~%WNL%"
		END
	END ELSE BEGIN
		SPRINT rest ""
	END
	// second default
	PATCH_IF "%args2%" STR_CMP "" && "%input2%" STR_CMP "" BEGIN
		SPRINT strs "%strs%%TAB%%TAB%%input2%=~~~~~%args2%~~~~~%WNL%"
	END
	// the struct
	PATCH_IF "%struct%" STR_CMP "" BEGIN
		SPRINT strs "%strs%%TAB%%TAB%struct=%struct%%WNL%"
	END
	// the type
	PATCH_IF "%type%" STR_CMP "" BEGIN
		SPRINT strs "%strs%%TAB%%TAB%type=%type%%WNL%"
	END
	// the rest
	WHILE "%rest%" STR_CMP "" BEGIN
		LPF return_first_entry STR_VAR list="%rest%" RET entry rest=list END
		is_int=0
		INNER_PATCH_SAVE entry "%entry%" BEGIN
			REPLACE_EVALUATE ":i *=" BEGIN
				is_int=1
			END
			"="
			REPLACE_EVALUATE ":i *$" BEGIN
				is_int=1
			END
			""
		END
		PATCH_IF is_int BEGIN
			SPRINT ints "%ints%%TAB%%TAB%%entry%%WNL%"
		END ELSE BEGIN
			SPRINT strs "%strs%%TAB%%TAB%%entry%%WNL%"
		END
	END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_remove_inline}
{
Extract inlined files (so we don't sugar them - main concern: LUA) and store them for later
restoration in the format [unique integer]=string. quote_array tracks how many quotes so far, 
so that sugar_remove_inline and sugar_remove_quintuple_quotes can share. 
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_remove_inline//internal
	INT_VAR quote_index=0
	RET quote_index
	RET_ARRAY quote_array
BEGIN
	index=0
	WHILE index>=0 BEGIN
		LPF find_parenthesis_range STR_VAR left="<<<<<<<<" right=">>>>>>>>" RET start end END
		PATCH_IF start>=0 BEGIN
			READ_ASCII start data (end +8 - start)
			DELETE_BYTES start (end +8 - start)
			SPRINT id_string "SFO_QUOTE_PLACEHOLDER_%quote_index%_"
			len=STRING_LENGTH "%id_string%"
			INSERT_BYTES start len
			WRITE_ASCII start "%id_string%"
			SPRINT $quote_array("%quote_index%") "%data%"
			++quote_index
			index=start
		END ELSE BEGIN
			index="-1"
		END
	END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_remove_quintuple_quotes}
{
Extract the contents of ~~~~~ - ~~~~~ -quoted data (so we don't sugar it - main concern: mangling 
the file when we sugar an anonymous function input to an action function that's itself sugared, e.g.
the cre.edit interface) and store them for later restoration in the format [unique integer]=string. 
quote_array tracks how many quotes so far, so that sugar_remove_inline and sugar_remove_quintuple_quotes can share. 

Incidentally, we don't do single-quoted or tilde-quoted data because in a few cases - e.g
SPRINT var "~" - it will mangle the file.
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_remove_quintuple_quotes//internal
	INT_VAR quote_index=0
	RET quote_index
	RET_ARRAY quote_array
BEGIN
	index=0
	WHILE index>=0 BEGIN
		LPF find_parenthesis_range STR_VAR left="~~~~~" right="~~~~~" RET start end END
		PATCH_IF start>=0 BEGIN
			READ_ASCII start data (end +5 - start)
			DELETE_BYTES start (end +5 - start)
			SPRINT id_string "SFO_QUOTE_PLACEHOLDER_%quote_index%_"
			len=STRING_LENGTH "%id_string%"
			INSERT_BYTES start len
			WRITE_ASCII start "%id_string%"
			SPRINT $quote_array("%quote_index%") "%data%"
			++quote_index
			index=start
		END ELSE BEGIN
			index="-1"
		END
	END
END

///////////////////////////////////////////////////////////////////////////////////////////////

/*
document{sugar_replace_removed_data}
{
Put back data sequestered by sugar_remove_[whatever]
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION sugar_replace_removed_data//internal
	STR_VAR quote_array=""
BEGIN
	PHP_EACH "%quote_array%" AS quote_index=>string BEGIN
		REPLACE_TEXTUALLY "SFO_QUOTE_PLACEHOLDER_%quote_index%_" "%string%"
	END
END

//////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////


/*
document{test_sugar_helper}
{Doesn't actually exist: contained in the inline 'sugartext.tp2' (and is well-formed but doesn't work)}



*/

<<<<<<<<.../stratagems-inline/sugartext.tp2





DEFINE_ACTION_FUNCTION test_sugar_helper//internal
BEGIN

strref.patch[1000][REPLACE_TEXTUALLY "this" "that"]

n=class.int[fighter]

lab=class.sym[1]



newfunc=def.a[arg1=cat arg2:i=7 arg3:i arg4:s][val1 val2:a]
[[
	val1:=="dog"
	val2:=="mongoose"
]]
newfunc=def.p[arg1=cat arg2:i=7 arg3:i arg4:s][val1 val2:a]
[[
	val1:="dog"
	val2:="mongoose"
]]



comp=def.c[]
[[
// a component
]]

subcomp=def.sc[]
[[
// a component
]]
stdfn=def.sfo[]
[[PATCH_PRINT "a cat"
]]

[[[
m=class.int{thief}
lab2=class.sym{3}
str:="Minsc is awesome"
str.print{}
m=str.patch{ INSERT_BYTES 0x0 3}
n=m.strref{}

]]]

COPY_EXISTING "minsc.cre" override

{{{
PRINT "blook"
}}}


BUT_ONLY

OUTER_SPRINT desc "Some data"

desc.echo[]

desc.patch
[

READ_ASCII 0x0 firstword (4)

]

desc2=desc.patch[REPLACE_TEXTUALLY "Some" "All"]
str=desc.strref[REPLACE_TEXTUALLY "Some" "Most"]

array.new[testarray]
[
ranger=>Minsc
fighter=>Sarevok
]

array.add[testarray]
[
mage=>Nalia
]

array.clear[testarray]

var1:==Anomen
var2:=="Sir Anomen"
var3:==~Anomen the Annoying~

OUTER_SET value="%cat%" STRING_MATCHES_REGEXP "\[[a]ab[0-9]+\]" // make sure we don't mangle this

run_this[]
run_that[blook]
run_the_other[blook|parameter1:i=6 parameter2="wodget"]

m=struct.read[|file=minsc.cre]
m.cre_enforce_thac0[]
m.cre_enforce_class[fighter]
struct.write[m|file=minsc.cre]

spell,scroll=spl.make[WIZARD_SOMETHING_AWESOME]
[
blah
]

testarray=array.map[testarray|map=fn]



COPY_EXISTING "jaheir.cre" override
	m=struct.read{}
	m.fx.alter{opcode=12}
	m_str=10
	m_alignment:=neutral_good
	PATCH_IF this==that BEGIN
	
	array.new{myarray}
	{
		Anomen=>annoying
		Sarevok=>treacherous
	}
	
	array.add{myarray}
	{
		Aerie=>overpowered
	}
	struct.write{m}
	END
BUT_ONLY

cre.edit[minsc minsc2 minsc4 minsc6]
[
	// this shouldn't be sugared
	
	m_both_names:="Minsc the awesome"
	m.add_fx{opcode=324}
	m.clone_fx{opcode=123|match="opcode=142" number:i=2}
	m.cre_strip_scripts{}
	m.cre_do_something{awesome}
	

]

// test program should swap 'inline_start' and 'inline_end' appropriately

inline_start .../stratagems-inline/lua_1.lua
-- some inline text that shouldn't be sugared

array={}
array[cat]="dog"

inline_end

OUTER_SPRINT text1
~~~~~ 
some quintuple-quoted text that shouldn't be sugared

array.add[blook]
[this=>that]

m.cre.alter{blah}

~~~~~

OUTER_SPRINT text2
~~~~~ 
some more quintuple-quoted text that shouldn't be sugared

array.add[blook]
[this=>that]

m.cre.alter{blah}

~~~~~
END

>>>>>>>>
// Detectable Spells v 4.02
// July 2022 - DavidW
//
// Changes: 
//	- we now have a 'skip_legacy' option in the main detectable_spells function. Set it to 1 and CLERIC_CHAOTIC_COMMANDS, WIZARD_FIRE_SHIELD, and WIZARD_SPELL_IMMUNITY
//    are skipped. (All are redundant given splstates.)

// Detectable Spells v 4.01
// August 2020 - DavidW
//
// Changes:
//	- we now keep our own local copy of stats.ids and splstate.ids data, to avoid having to run CLEAR_IDS_MAP a bazillion times
//  - removed the need for AUTO_EVAL_STRINGS
//  - restored this text!
//	- rather belatedly started a v4.xx chain (really 3.96 ought to have been 4.0, since it was rewritten pretty much from scratch, but I don't want to rewrite history by changing it now)

// Detectable Spells v3.96
//  January 2019 - David Wallace ('DavidW')
//
//  Changes:
//  - Now incorporate flexible handling of TOBEX stats using BGEE splstate baseline
//  - if filename has no .spl suffix, try looking it up in SPELL.ids (and skip if not found)
//  - general revamp of the interface to apply detection
//  - added function to apply it directly to an individual spell
//  - use new 'ds_sort_ids' (exported from SCS's function library 'sort_ids') to sort stats.ids, rather than native ds_sort_stats_ids.
//    (sort_ids preserves duplicates, inter alia helpful with CDTweaks proficiencies)

// Detectable Spells v3.95
// February 3rd, 2016 - Yaroslav "Ardanis/GeN1e" Kalyuzhnyy


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// The main function
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION detectable_spells 
   INT_VAR fix_khelben=1
			skip_legacy=0
BEGIN
	// make sure stats.ids is properly set
   LAF ds_stat_entries END
   // load current contents of stats.ids and splstate.ids
 	LAF ds_load_ids STR_VAR ids=stats RET_ARRAY ds_ids_map_stats=ids_map END
	LAF ds_load_ids STR_VAR ids=splstate RET_ARRAY ds_ids_map_splstate=ids_map END
   // process main tables
   ACTION_FOR_EACH table_name IN ds_simple ds_142_variable ds_other_clone buff_misc special BEGIN
      LAF ds_process_table INT_VAR complain=0 STR_VAR table=EVAL ".../ds-inline/%table_name%.2da" RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
   END
   ACTION_IF !skip_legacy BEGIN
	   ACTION_FOR_EACH table_name IN ds_simple_legacy ds_142_variable_legacy ds_other_clone_legacy BEGIN
		  LAF ds_process_table INT_VAR complain=0 STR_VAR table=EVAL ".../ds-inline/%table_name%.2da" RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
	   END
   
   END
   ACTION_FOR_EACH table_name IN BUFF_PRO_WEAPONS BUFF_PRO_DAMAGE BUFF_PRO_SPELLS BUFF_PRO_EFFECTS BUFF_ENHANCEMENT STATE_ENRAGED BEGIN
      LAF ds_process_table INT_VAR complain=0 STR_VAR table=EVAL ".../ds-inline/%table_name%.2da" default_stat=EVAL "%table_name%" RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
   END

   ACTION_IF fix_khelben BEGIN
      LAF ds_fix_khelben END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// The data
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// The bulk of entries are simple 142-clones
//////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< .../ds-inline/ds_simple_legacy.2da
resource                                stat
CLERIC_CHAOTIC_COMMANDS                 CLERIC_CHAOTIC_COMMANDS
>>>>>>>>

<<<<<<<< .../ds-inline/ds_simple.2da
resource                                stat
CLERIC_ARMOR_OF_FAITH                   ARMOR_OF_FAITH
CLERIC_CHAOTIC_COMMANDS                 CHAOTIC_COMMANDS
BARBARIAN_RAGE                          BARBARIAN_RAGE
BERSERKER_RAGE                          BERSERKER_RAGE
MINSC_BERSERK                           MINSC_BERSERK
ASSASSIN_POISON                         POISON_WEAPON
KENSAI_KIA                              KENSAI_KIA
SPDWD02                                 DEFENSIVE_STANCE
ARCHER_CALL_SHOT                        ARCHER_CALL_SHOT
WIZARD_CHAOS_SHIELD                     SPLSTATE:CHAOS_SHIELD
WIZARD_IMPROVED_CHAOS_SHIELD            IMPROVED_CHAOS_SHIELD
SPCL542A                                SKALD_SONG
SPCL751A                                JESTER_SONG
POTN21                                  POTION_OF_CLARITY
POTN33                                  POTION_OF_MAGIC_BLOCKING
SCRL07                                  SCROLL_OF_PROTECTION_FROM_MAGIC
SCRL09                                  SCROLL_OF_PROTECTION_FROM_UNDEAD
WIZARD_PROTECTION_FROM_PETRIFICATION    PROTECTION_FROM_PETRIFICATION
POTN38                                  PROTECTION_FROM_PETRIFICATION
CAVALIER_REMOVE_FEAR                    RESIST_FEAR
CLERIC_REMOVE_FEAR                      RESIST_FEAR
WIZARD_RESIST_FEAR                      RESIST_FEAR
SPRA303                                 PROTECTION_FROM_NORMAL_MISSILES
WIZARD_PROTECTION_FROM_NORMAL_MISSILES  PROTECTION_FROM_NORMAL_MISSILES
WIZARD_PROTECTION_FROM_NORMAL_WEAPONS   PROTECTION_FROM_NORMAL_WEAPONS
WIZARD_TENSERS_TRANSFORMATION           TENSERS_TRANSFORMATION
SUN_SOUL_GREATER_SUN                    RED_FIRESHIELD
TALOS_STORMSHIELD                       STORM_SHELL
CLERIC_DOOM                             DOOM
CLERIC_FAERIE_FIRE                      FAERIE_FIRE
CLERIC_BARKSKIN                         BARKSKIN
CLERIC_MISCAST_MAGIC                    MISCAST_MAGIC
CLERIC_DEATH_WARD                       DEATH_WARD
CLERIC_DEATH_WARD                       SPLSTATE:DEATH_WARD
CLERIC_HOLY_POWER                       HOLY_POWER
WIZARD_GLITTERDUST                      GLITTERDUST
WIZARD_FIRE_SHIELD_BLUE                 BLUE_FIRESHIELD
WIZARD_EMOTION_HOPELESSNESS             HOPELESSNESS
WIZARD_GREATER_MALISON                  MALISON
SPWI413A                                OTILUKES_RESILIENT_SPHERE
WIZARD_FIRE_SHIELD_RED                  RED_FIRESHIELD
WIZARD_PROTECTION_FROM_THE_ELEMENTS     WIZARD_PROTECTION_FROM_THE_ELEMENTS
WARRIOR_HARDINESS                       HARDINESS
WIZARD_PROTECTION_FROM_MAGIC_ENERGY     WIZARD_PROTECTION_FROM_MAGIC_ENERGY
WIZARD_SPELL_IMMUNITY_ABJURATION        SI_ABJURATION
WIZARD_SPELL_IMMUNITY_CONJURATION       SI_CONJURATION
WIZARD_SPELL_IMMUNITY_DIVINATION        SI_DIVINATION
WIZARD_SPELL_IMMUNITY_ENCHANTMENT       SI_ENCHANTMENT
WIZARD_SPELL_IMMUNITY_ILLUSIONIST       SI_ILLUSION
WIZARD_SPELL_IMMUNITY_INVOCATION        SI_EVOCATION
WIZARD_SPELL_IMMUNITY_NECROMANCY        SI_NECROMANCY
WIZARD_SPELL_IMMUNITY_ALTERATION        SI_TRANSMUTATION
CLERIC_FREE_ACTION                      CLERIC_FREE_ACTION
POTN45                                  CLERIC_FREE_ACTION
CLERIC_DEFENSIVE_HARMONY                CLERIC_DEFENSIVE_HARMONY
CLERIC_PROTECTION_FROM_EVIL_10_FOOT     PROTECTION_FROM_EVIL
CLERIC_PROTECT_FROM_EVIL                PROTECTION_FROM_EVIL
WIZARD_PROTECTION_FROM_EVIL             PROTECTION_FROM_EVIL
PALADIN_PROTECTION_FROM_EVIL            PROTECTION_FROM_EVIL
SPCL233                                 PROTECTION_FROM_EVIL
CLERIC_REGENERATE                       CLERIC_REGENERATION
BHAAL1B                                 CLERIC_REGENERATION
CLERIC_TRUE_SIGHT                       TRUE_SIGHT
WIZARD_TRUE_SIGHT                       TRUE_SIGHT
KOA_TRUE_SIGHT_NO_VIS                   TRUE_SIGHT
INQUIS_TRUE_SIGHT                       TRUE_SIGHT
HELM_TRUE_SIGHT                         TRUE_SIGHT
LATHANDER_BOON                          LEVEL_DRAIN_IMMUNITY
WIZARD_PROTECTION_FROM_ENERGY           WIZARD_PROTECTION_FROM_ENERGY
WIZARD_IMPROVED_ALUCRITY                WIZARD_IMPROVED_ALACRITY
SPWISH17                                WIZARD_IMPROVED_ALACRITY
WIZARD_GLITTERDUST                      CANNOT_TURN_INVISIBLE
WIZARD_SHIELD                           WIZARD_SHIELD
>>>>>>>>


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// These all use opcode 142, but have variable values. Many are legacy.
////
//// The protection_from_weapons spells, being mutually incompatible, can share slots
//// The Fire Shield effects have a legacy detection that shares WIZARD_FIRE_SHIELD
//// The SI spells have a legacy detection that shares WIZARD_SPELL_IMMUNITY
//// Many offensive powers share a (partly legacy) opcode; so do many strength powers; so do many defensive
//// powers
//////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< .../ds-inline/ds_142_variable_legacy.2da
resource                                stat                                 stat_value
WIZARD_FIRE_SHIELD_RED                  WIZARD_FIRE_SHIELD                   1
WIZARD_FIRE_SHIELD_BLUE                 WIZARD_FIRE_SHIELD                   2
CLERIC_AURA_OF_FLAMING_DEATH            WIZARD_FIRE_SHIELD                   1
SUN_SOUL_GREATER_SUN                    WIZARD_FIRE_SHIELD                   1
WIZARD_SPELL_IMMUNITY_ABJURATION        WIZARD_SPELL_IMMUNITY                1
WIZARD_SPELL_IMMUNITY_CONJURATION       WIZARD_SPELL_IMMUNITY                2
WIZARD_SPELL_IMMUNITY_DIVINATION        WIZARD_SPELL_IMMUNITY                3
WIZARD_SPELL_IMMUNITY_ENCHANTMENT       WIZARD_SPELL_IMMUNITY                4
WIZARD_SPELL_IMMUNITY_ILLUSIONIST       WIZARD_SPELL_IMMUNITY                5
WIZARD_SPELL_IMMUNITY_INVOCATION        WIZARD_SPELL_IMMUNITY                6
WIZARD_SPELL_IMMUNITY_NECROMANCY        WIZARD_SPELL_IMMUNITY                7
WIZARD_SPELL_IMMUNITY_ALTERATION        WIZARD_SPELL_IMMUNITY                8
>>>>>>>>

<<<<<<<< .../ds-inline/ds_142_variable.2da
resource                                stat                                 stat_value
WIZARD_MANTLE                           WIZARD_PROTECTION_FROM_MAGIC_WEAPONS 1
WIZARD_IMPROVED_MANTLE                  WIZARD_PROTECTION_FROM_MAGIC_WEAPONS 2
WIZARD_ABSOLUTE_IMMUNITY                WIZARD_PROTECTION_FROM_MAGIC_WEAPONS 3
WIZARD_PROTECTION_FROM_MAGIC_WEAPONS    WIZARD_PROTECTION_FROM_MAGIC_WEAPONS 4
PROTECTION_MAGIC_WEAPON_NOEFF           WIZARD_PROTECTION_FROM_MAGIC_WEAPONS 4
WIZARD_TENSERS_TRANSFORMATION           OFFENSIVE_MODIFIER                   1
CLERIC_CHAMPIONS_STRENGTH               OFFENSIVE_MODIFIER                   1
BARBARIAN_RAGE                          OFFENSIVE_MODIFIER                   1
BERSERKER_RAGE                          OFFENSIVE_MODIFIER                   1
MINSC_BERSERK                           OFFENSIVE_MODIFIER                   1
LATHANDER_BOON                          OFFENSIVE_MODIFIER                   1
MONK_STUNNING_BLOW                      OFFENSIVE_MODIFIER                   2
WARRIOR_DEATHBLOW                       OFFENSIVE_MODIFIER                   2
WARRIOR_POWER_ATTACK                    OFFENSIVE_MODIFIER                   2
BLADE_OFFENSIVE_SPIN                    OFFENSIVE_MODIFIER                   2
BLADE_DEFENSIVE_SPIN                    OFFENSIVE_MODIFIER                   2
KENSAI_KIA                              OFFENSIVE_MODIFIER                   2
INVOKE_COURAGE                          OFFENSIVE_MODIFIER                   3
WARRIOR_GREATER_DEATHBLOW               OFFENSIVE_MODIFIER                   3
WARRIOR_CRITICAL_STRIKE                 OFFENSIVE_MODIFIER                   3
ROGUE_ASSASINATION                      OFFENSIVE_MODIFIER                   4
ASSASSIN_POISON                         OFFENSIVE_MODIFIER                   4
WARRIOR_WHIRLWIND                       OFFENSIVE_MODIFIER                   4
WARRIOR_GREATER_WHIRLWIND               OFFENSIVE_MODIFIER                   5
WARRIOR_SMITE                           OFFENSIVE_MODIFIER                   5
MONK_QUIVERING_PALM                     OFFENSIVE_MODIFIER                   5
WIZARD_TENSERS_TRANSFORMATION           OFFENSIVE_MODIFIER                   1
WIZARD_STRENGTH                         STRENGTH_MODIFIER                    2
CLERIC_STRENGTH_OF_ONE                  STRENGTH_MODIFIER                    2
CLERIC_HOLY_POWER                       STRENGTH_MODIFIER                    3
CLERIC_CHAMPIONS_STRENGTH               STRENGTH_MODIFIER                    3
CLERIC_DRAW_UPON_HOLY_MIGHT             STRENGTH_MODIFIER                    4
INNATE_DRAW_UPON_HOLY_MIGHT             STRENGTH_MODIFIER                    4
CLERIC_RIGHTEOUS_MAGIC                  STRENGTH_MODIFIER                    6
BHAAL2A                                 STRENGTH_MODIFIER                    4
DGRIGHT                                 STRENGTH_MODIFIER                    6
CLERIC_BARKSKIN                         DEFENSIVE_MODIFIER                   1
WIZARD_ARMOR                            DEFENSIVE_MODIFIER                   3
WIZARD_SHIELD                           DEFENSIVE_MODIFIER                   2
WIZARD_GHOST_ARMOR                      DEFENSIVE_MODIFIER                   4
WIZARD_SPIRIT_ARMOR                     DEFENSIVE_MODIFIER                   5
CLERIC_GLOBE_OF_BLADES                  CLERIC_BLADE_BARRIER                 1
NPC_BLADE_BARRIER                       CLERIC_BLADE_BARRIER                 1
CLERIC_BLADE_BARRIER                    CLERIC_BLADE_BARRIER                 2
MELIS02                                 CLERIC_BLADE_BARRIER                 2
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// These work better associated to other opcodes
////
//// Insect plague is better attached to the insect overlay
//// Spell Deflection/Turning/Trap/SpellShield and Physical Mirror are best indexed to the actual effects
//// Also true for Mislead etc - though these are dangerous to detect this way and maintained only on
//// legacy grounds
//// Some NPC fire shield effects also need detection directly on the condition
//////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<<.../ds-inline/ds_other_clone_legacy.2da
resource                           stat                           stat_value           match_opcode
BALSHLD                            WIZARD_FIRE_SHIELD             1                    232
>>>>>>>>

<<<<<<<< .../ds-inline/ds_other_clone.2da
resource                           stat                           stat_value           match_opcode
BALSHLD                            RED_FIRESHIELD                 1                    232
CLERIC_SUMMON_INSECTS              CLERIC_INSECT_PLAGUE           1                    215
CLERIC_INSECT_PLAGUE               CLERIC_INSECT_PLAGUE           2                    215
CLERIC_CREEPING_DOOM               CLERIC_INSECT_PLAGUE           3                    215
WIZARD_MINOR_SPELL_DEFLECTION      WIZARD_SPELL_DEFLECTION        1                    201
SPRA302                            WIZARD_SPELL_DEFLECTION        1                    201
SPELL_DEFLECTION_NO_VISUAL         WIZARD_SPELL_DEFLECTION        2                    201
WIZARD_SPELL_DEFLECTION            WIZARD_SPELL_DEFLECTION        2                    201
CLERIC_SHIELD_OF_THE_ARCHONS       CLERIC_SHIELD_OF_THE_ARCHONS   1                    201
DGARCHON                           CLERIC_SHIELD_OF_THE_ARCHONS   1                    201
WIZARD_SPELL_TURNING               WIZARD_SPELL_TURNING           2                    200
BEHOLDER_SPELL_TURNING             WIZARD_SPELL_TURNING           1                    200
WIZARD_MINOR_SPELL_TURNING         WIZARD_SPELL_TURNING           1                    200
WIZARD_SPELL_TRAP                  WIZARD_SPELL_TRAP              1                    259
WIZARD_SPELL_SHIELD                SPELL_SHIELD                   1                    226
CLERIC_PHYSICAL_MIRROR             CLERIC_PHYSICAL_MIRROR         1                    197
WIZARD_MISLEAD                     WIZARD_MISLEAD                 1                    236
WIZARD_PROJECT_IMAGE               WIZARD_MISLEAD                 2                    236
WIZARD_SIMULACRUM                  WIZARD_MISLEAD                 3                    236
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// These are standard markups (from SoD, with DW amendments for IWD) of combat buffs
////
//// Most are just straightforward 142s
//////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< .../ds-inline/BUFF_PRO_DAMAGE.2da
resource
SUN_SOUL_GREATER_SUN
TALOS_STORMSHIELD
CLERIC_AURA_OF_FLAMING_DEATH
CLERIC_RESIST_FIRE
CLERIC_PROTECTION_FROM_FIRE
CLERIC_PROTECTION_FROM_LIGHTNING
WIZARD_PROTECTION_FROM_FIRE
WIZARD_PROTECTION_FROM_COLD
WIZARD_FIRE_SHIELD_BLUE
WIZARD_FIRE_SHIELD_RED
WIZARD_PROTECTION_FROM_ELECTRICITY
WIZARD_PROTECTION_FROM_ACID
WIZARD_PROTECTION_FROM_MAGIC_ENERGY
WIZARD_PROTECTION_FROM_THE_ELEMENTS
WIZARD_PROTECTION_FROM_ENERGY
POTN02
POTN18
POTN22
POTN31
POTN35
>>>>>>>>

<<<<<<<< .../ds-inline/BUFF_PRO_WEAPONS.2da
resource
SPRA303
WIZARD_PROTECTION_FROM_NORMAL_MISSILES
WIZARD_PROTECTION_FROM_NORMAL_WEAPONS
WIZARD_PROTECTION_FROM_MAGIC_WEAPONS
WIZARD_MANTLE
WIZARD_IMPROVED_MANTLE
WIZARD_ABSOLUTE_IMMUNITY
>>>>>>>>

<<<<<<<< .../ds-inline/BUFF_PRO_SPELLS.2da
resource
WIZARD_SPELL_IMMUNITY_ABJURATION
WIZARD_SPELL_IMMUNITY_CONJURATION
WIZARD_SPELL_IMMUNITY_DIVINATION
WIZARD_SPELL_IMMUNITY_ENCHANTMENT
WIZARD_SPELL_IMMUNITY_ILLUSIONIST
WIZARD_SPELL_IMMUNITY_INVOCATION
WIZARD_SPELL_IMMUNITY_NECROMANCY
WIZARD_SPELL_IMMUNITY_ALTERATION
WIZARD_GLOBE_OF_INVULNERABILITY
WIZARD_MINOR_GLOBE_OF_INVULNERABILITY
>>>>>>>>

<<<<<<<< .../ds-inline/BUFF_PRO_EFFECTS.2da
resource
CLERIC_REMOVE_FEAR
CLERIC_FREE_ACTION
CLERIC_DEATH_WARD
CLERIC_CHAOTIC_COMMANDS
WIZARD_RESIST_FEAR
POTN21
POTN45
>>>>>>>>

<<<<<<<< .../ds-inline/BUFF_ENHANCEMENT.2da
resource
BHAAL2A
CLERIC_DRAW_UPON_HOLY_MIGHT
CLERIC_STRENGTH_OF_ONE
CLERIC_HOLY_POWER
CLERIC_CHAMPIONS_STRENGTH
CLERIC_CHAOTIC_COMMANDS
CLERIC_RIGHTEOUS_MAGIC
CLERIC_BLADE_BARRIER
NPC_BLADE_BARRIER
CLERIC_AURA_OF_FLAMING_DEATH
WIZARD_STRENGTH
WIZARD_FIRE_SHIELD_BLUE
WIZARD_FIRE_SHIELD_RED
WIZARD_TENSERS_TRANSFORMATION
POTN03
POTN04
POTN05
POTN06
POTN07
POTN09
POTN12
POTN41
>>>>>>>>

<<<<<<<< .../ds-inline/STATE_ENRAGED.2da
resource
BARBARIAN_RAGE
BERSERKER_RAGE
MINSC_BERSERK
OHRRAGE
>>>>>>>>

<<<<<<<< .../ds-inline/buff_misc.2da
resource                      stat                          match_opcode
CLERIC_SHIELD_OF_THE_ARCHONS  BUFF_PRO_SPELLS               201
SPRA302                       BUFF_PRO_SPELLS               201
WIZARD_MINOR_SPELL_DEFLECTION BUFF_PRO_SPELLS               201
WIZARD_SPELL_DEFLECTION       BUFF_PRO_SPELLS               201
WIZARD_SPELL_SHIELD           BUFF_PRO_SPELLS               226
WIZARD_MINOR_SPELL_TURNING    BUFF_PRO_SPELLS               200
WIZARD_SPELL_TURNING          BUFF_PRO_SPELLS               200
WIZARD_SPELL_TRAP             BUFF_PRO_SPELLS               259
WIZARD_MINOR_SPELL_TURNING    BUFF_PRO_SPELLS               201 // these are for SR
WIZARD_SPELL_TURNING          BUFF_PRO_SPELLS               201 //
WIZARD_SPELL_TRAP             BUFF_PRO_SPELLS               201 //
POTN33                        BUFF_PRO_SPELLS               102
CLERIC_PHYSICAL_MIRROR        BUFF_PRO_WEAPONS              197
WIZARD_DETECT_INVISIBILITY    DETECT_INVISIBILITY           193 // SR only
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// These are special cases where the duration needs to override the clone
//////////////////////////////////////////////////////////////////////////////////////////////////////////

<<<<<<<< .../ds-inline/special.2da
resource                     stat                           match_opcode              duration
WIZARD_WARDING_WHIP          WIZARD_KHELBENS_WARDING_WHIP   215                       7
INQUIS_TRUE_SIGHT            CANNOT_TURN_INVISIBLE          221                       7
SPCL232D                     CANNOT_TURN_INVISIBLE          221                       7
CLERIC_TRUE_SIGHT            CANNOT_TURN_INVISIBLE          221                       7
SPPR505D                     CANNOT_TURN_INVISIBLE          221                       7
SPPR950                      CANNOT_TURN_INVISIBLE          221                       7
WIZARD_TRUE_SIGHT            CANNOT_TURN_INVISIBLE          221                       7
SPWI609D                     CANNOT_TURN_INVISIBLE          221                       7
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// The functions
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// Process a table of DS instructions
//// possible columns are:
//// - resource (the thing being patched; compulsory; can be a spell.ids ref, a full resource name, or the
////   resref of a spell or item. If the latter, and if both resref.spl and resref.itm exist, spl is default)
//// - stat (the stat being assigned; defaults to the default_stat variable)
//// - stat_value (the value assigned to the stat; defaults to 1)
//// - match_opcode (the opcode to clone; defaults to 142)
//// - match_parameter2 (a restriction on which opcode is cloned; defaults to -1, clone all)
//// - match_resource (a restriction on which opcode is cloned; defaults to SAME, clone all)
//// columns can be in any order, but first row must be column headers. Other columns are ignored
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_process_table
   INT_VAR complain=0
           default_opcode=142
   STR_VAR table=""
           default_stat=""
   RET_ARRAY ds_ids_map_stats ds_ids_map_splstate
BEGIN
	// load IDS, if not already done
	ACTION_IF !VARIABLE_IS_SET $ds_ids_map_stats("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=stats RET_ARRAY ds_ids_map_stats=ids_map END
	END
	ACTION_IF !VARIABLE_IS_SET $ds_ids_map_splstate("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=splstate RET_ARRAY ds_ids_map_splstate=ids_map END
	END

   COPY - "%table%" override
        // remove comments
        REPLACE_TEXTUALLY "//.*" ""
        // read in the data
        PATCH_FOR_EACH column IN resource stat stat_value match_opcode match_parameter2 match_resource duration BEGIN
           SET EVAL "%column%_col"=0 - 1
        END
        COUNT_2DA_COLS colcount
        READ_2DA_ENTRIES_NOW ds_table_data colcount
        // get the column entries
        FOR (this_col=0;this_col<colcount;this_col +=1) BEGIN
           READ_2DA_ENTRY_FORMER ds_table_data 0 this_col colname
           PATCH_MATCH "%colname%" WITH
           resource stat stat_value match_opcode match_parameter2 match_resource duration BEGIN
              SET EVAL "%colname%_col" = this_col
           END
           DEFAULT
           END
        END
        PATCH_IF (resource_col>=0) BEGIN
           // go through the table
           FOR (this_row=1;this_row<ds_table_data;this_row +=1) BEGIN
              READ_2DA_ENTRY_FORMER ds_table_data this_row resource_col resource
              SET match_opcode=default_opcode
              SET match_parameter2="-1"
              SET stat_value=1
              SPRINT stat "%default_stat%"
              SPRINT match_resource "SAME"
              SET duration="-1"
              PATCH_FOR_EACH entry IN stat stat_value match_opcode match_parameter2 match_resource duration BEGIN
                 PATCH_IF (EVAL "%entry%_col")>=0 BEGIN
                    READ_2DA_ENTRY_FORMER ds_table_data this_row EVAL "%entry%_col" temp
                    SPRINT EVAL "%entry%" "%temp%"
                 END
              END
              INNER_ACTION BEGIN
                 LAF ds_make_detectable INT_VAR complain match_opcode match_parameter2 stat_value STR_VAR id=EVAL "%stat%" resource match_resource RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
              END
           END
        END ELSE BEGIN
           PATCH_WARN "DS warning: %table% lacks a 'resource' column"
        END
   BUT_ONLY
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
/// The core function
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_make_detectable
   INT_VAR match_opcode="142"
           match_parameter2="-1"
           stat_value=1
           complain=1
   STR_VAR id=""
           resource=""
           match_resource="SAME"
   RET_ARRAY ds_ids_map_stats
			 ds_ids_map_splstate
BEGIN
  	  // load IDS, if not already done
	  ACTION_IF !VARIABLE_IS_SET $ds_ids_map_stats("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=stats RET_ARRAY ds_ids_map_stats=ids_map END
	  END
	  ACTION_IF !VARIABLE_IS_SET $ds_ids_map_splstate("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=splstate RET_ARRAY ds_ids_map_splstate=ids_map END
	  END


   // identify the resource
   ACTION_IF !"%resource%" STRING_CONTAINS_REGEXP  "\." BEGIN // it's a full resource
      OUTER_SPRINT filespec "%resource%"
   END ELSE BEGIN
   // check for a suffix
      OUTER_SPRINT suffix ""
      OUTER_INNER_PATCH_SAVE resource "%resource%" BEGIN
         REPLACE_EVALUATE "^\(.*\):\(.*\)$" BEGIN
          SPRINT suffix "%MATCH2%"
         END
         "%MATCH1%"
      END
      OUTER_SET spell_num=IDS_OF_SYMBOL (spell "%resource%")
      ACTION_IF spell_num>=0 BEGIN
         LAF RES_NAME_OF_SPELL_NUM INT_VAR spell_num RET spell_res END
         ACTION_IF FILE_EXISTS_IN_GAME "%spell_res%%suffix%.spl" BEGIN
             OUTER_SPRINT filespec "%spell_res%%suffix%.spl"
         END
      END ELSE BEGIN
         ACTION_IF FILE_EXISTS_IN_GAME "%resource%%suffix%.spl" BEGIN
            OUTER_SPRINT filespec "%resource%%suffix%.spl"
         END ELSE
         ACTION_IF FILE_EXISTS_IN_GAME "%resource%%suffix%.itm" BEGIN
            OUTER_SPRINT filespec "%resource%%suffix%.itm"
         END
      END
   END
   // if we succeeded in finding filespec...
   ACTION_IF VARIABLE_IS_SET filespec BEGIN
   // get the data for the stat
      LAF ds_resolve_stat STR_VAR id RET stat_param stat_opcode RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
   // patch
      ACTION_IF stat_opcode>=0 BEGIN // return value of -1 means we can't patch this (probably because TOBEX is missing)
        COPY_EXISTING "%filespec%" override
              LPF DELETE_EFFECT INT_VAR match_opcode=stat_opcode match_parameter2=stat_param END // clear out any previous version
              LPF CLONE_EFFECT INT_VAR silent=!complain multi_match=1 match_opcode match_parameter2 opcode=stat_opcode parameter1=stat_value parameter2=stat_param special=(opcode=328) STR_VAR match_resource END
        BUT_ONLY
      END

   END ELSE BEGIN
          ACTION_IF complain BEGIN
            WARN "DS tried to add detectable data to %resource%%suffix%, but there is no such resource"
          END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_set_vars RET is_tobex enhanced_edition BEGIN
   OUTER_SET is_tobex=FILE_EXISTS "tobex.dll"
   OUTER_SET enhanced_edition=GAME_IS "BGEE BG2EE EET IWDEE"
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// having already checked it's not, add an entry to a 2da

DEFINE_ACTION_FUNCTION ds_add_entry
  INT_VAR min=0
  STR_VAR id="" file=""
  RET stat_ind
BEGIN
 ACTION_CLEAR_ARRAY ds_2da_array
 COPY_EXISTING "%file%.ids" override
  READ_2DA_ENTRIES_NOW ds_2da_array 2
  FOR (i=0;i<ds_2da_array;i+=1) BEGIN
      READ_2DA_ENTRY_FORMER ds_2da_array i 0 this_val
      SET $ds_2da_array("%this_val%")=1
  END
 BUT_ONLY
 OUTER_SET stat_ind=min
 OUTER_WHILE VARIABLE_IS_SET $ds_2da_array("%stat_ind%") BEGIN
    OUTER_SET stat_ind +=1
 END
 APPEND "%file%.ids" "%stat_ind% %id%"
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ds_add_entry
  INT_VAR min=0
  STR_VAR id="" file=""
  RET stat_ind
BEGIN
   INNER_ACTION BEGIN
      LAF ds_add_entry INT_VAR min STR_VAR id file RET stat_ind END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION ds_resolve_stat STR_VAR id="" RET stat_ind stat_param stat_opcode stat_type RET_ARRAY ds_ids_map_stats ds_ids_map_splstate
BEGIN
   // initialise
   INNER_ACTION BEGIN
      LAF ds_set_vars RET is_tobex enhanced_edition END
  	  // load IDS, if not already done
	  ACTION_IF !VARIABLE_IS_SET $ds_ids_map_stats("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=stats RET_ARRAY ds_ids_map_stats=ids_map END
	  END
	  ACTION_IF !VARIABLE_IS_SET $ds_ids_map_splstate("DS_IDS_MAP_LOADED") BEGIN
		LAF ds_load_ids STR_VAR ids=splstate RET_ARRAY ds_ids_map_splstate=ids_map END
	  END

   END
   
   // see if it's forced
   SET enforce_splstate=0

   INNER_PATCH "%id%" BEGIN
      REPLACE_EVALUATE "^\(.*\):\(.*\)$" BEGIN
         PATCH_IF "%MATCH1%" STRING_EQUAL_CASE "splstate" BEGIN
            SPRINT id "%MATCH2%"
            SET enforce_splstate=1
         END ELSE BEGIN
            SET enforce_splstate=0
            PATCH_WARN "unrecognised naming convention for state '%id%' in DS"
         END
      END
      ""
   END
   // first, see if it's in stats.ids
   TO_UPPER id
   PATCH_IF VARIABLE_IS_SET $ds_ids_map_stats("%id%") BEGIN
    SET check_stats=$ds_ids_map_stats("%id%")
   END ELSE BEGIN
	SET check_stats="-1"
   END
   PATCH_IF (!enforce_splstate && ( check_stats >=89 && (check_stats<=134 || check_stats>=156) && ( check_stats<256 || is_tobex ) )) BEGIN
       SET stat_ind=check_stats
       SPRINT stat_type stats
       PATCH_IF stat_ind>387 BEGIN
             SET stat_opcode=318
             SET stat_param=stat_ind + 0x10000
       END ELSE
       PATCH_IF stat_ind<=134 && stat_ind>=89 BEGIN
             SET stat_opcode=233
             SET stat_param=stat_ind
       END ELSE
       PATCH_IF stat_ind>=156 BEGIN
             SET stat_opcode=282
             SET stat_param=stat_ind - 156
       END ELSE BEGIN // you shouldn't be able to get here
             SET stat_opcode=0 - 1
             SET stat_param = 0 - 1
       END
   END ELSE BEGIN
   // if it's not in stats.ids, check if we're EE or not
       PATCH_IF enhanced_edition BEGIN
           // is it in SPLSTATE?
           PATCH_IF VARIABLE_IS_SET $ds_ids_map_splstate("%id%") BEGIN
			   // if it's there already, just use it
			   SET stat_ind = $ds_ids_map_splstate("%id%")
           END ELSE BEGIN
               // get a new value
               LPF ds_add_entry STR_VAR id file=splstate RET stat_ind END
			   SET $ds_ids_map_splstate("%id%")=stat_ind
           END
           SPRINT stat_type splstate
           SET stat_opcode=328
           SET stat_param=stat_ind
       END ELSE BEGIN
          // if we're not ToBEx, quit
          PATCH_IF is_tobex BEGIN
             // get a new value
             LPF ds_add_entry INT_VAR min=401 STR_VAR id file=stats RET stat_ind END
             SET $ds_ids_map_stats("%id%")=stat_ind
			 SPRINT stat_type stats
             SET stat_opcode=318
             SET stat_param=stat_ind + 0x10000
          END ELSE BEGIN
             SPRINT stat_type null
             SET stat_opcode="-1"
             SET stat_param="-1"
             SET stat_ind="-1"
          END
       END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_resolve_stat STR_VAR id=""
RET stat_ind stat_param stat_opcode stat_type
RET_ARRAY ds_ids_map_stats ds_ids_map_splstate
BEGIN
   OUTER_INNER_PATCH "" BEGIN
      LPF ds_resolve_stat STR_VAR id RET stat_ind stat_param stat_opcode stat_type RET_ARRAY ds_ids_map_stats ds_ids_map_splstate END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//// make sure the required entries in stats.ids are present
//////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_stat_entries BEGIN

LAF ds_set_vars RET is_tobex enhanced_edition END
// first, fix issue with Paladin_protection_from_evil

COPY_EXISTING spell.ids override
ACTION_IF !FILE_CONTAINS_EVALUATED ("override/spell.ids" "4213[ %TAB%]+PALADIN_PROTECTION_FROM_EVIL") BEGIN
         APPEND "spell.ids" "4213 PALADIN_PROTECTION_FROM_EVIL"
      END

ACTION_CLEAR_ARRAY stats_array
ACTION_DEFINE_ASSOCIATIVE_ARRAY stats_array BEGIN
WEAPON_ENCHANTMENT => 109
CLERIC_ARMOR_OF_FAITH => 110
WIZARD_SPELL_DEFLECTION => 116
PROTECTION_FROM_EVIL => 117
TRUE_SIGHT => 118
CLERIC_CHAOTIC_COMMANDS => 119
CLERIC_INSECT_PLAGUE => 120
CLERIC_BLADE_BARRIER => 121
CLERIC_PHYSICAL_MIRROR => 122
CLERIC_SHIELD_OF_THE_ARCHONS => 123
CLERIC_REGENERATION => 124
WIZARD_FIRE_SHIELD => 125
WIZARD_PROTECTION_FROM_MAGIC_ENERGY => 126
WIZARD_MISLEAD => 127
WIZARD_PROTECTION_FROM_MAGIC_WEAPONS => 128
WIZARD_SPELL_TURNING => 129
WIZARD_PROTECTION_FROM_THE_ELEMENTS => 130
CLERIC_FREE_ACTION => 131
WIZARD_KHELBENS_WARDING_WHIP => 132
CLERIC_DEFENSIVE_HARMONY => 133
EXTRAPROFICIENCY20 => 134
SCRIPTINGSTATE1 => 156
WING_BUFFET => 156
SCRIPTINGSTATE2 => 157
DEATH_WARD => 157
SCRIPTINGSTATE3 => 158
LEVEL_DRAIN_IMMUNITY =>158
SCRIPTINGSTATE4 => 159
OFFENSIVE_MODIFIER => 159
SCRIPTINGSTATE5 => 160
DEFENSIVE_MODIFIER =>  160
SCRIPTINGSTATE6 => 161
STRENGTH_MODIFIER => 161
WIZARD_SPELL_IMMUNITY => 162
WIZARD_PROTECTION_FROM_ENERGY => 163
WIZARD_SPELL_TRAP => 164
WIZARD_IMPROVED_ALACRITY => 165
MELEE_THACO_BONUS => 166
MELEE_DAMAGE_BONUS => 167
MISSILE_DAMAGE_BONUS => 168
DISABLE_CIRCLE => 169
FIST_THACO_BONUS => 170
FIST_DAMAGE_BONUS => 171
CLASS_STRING_OVERRIDE_MIXED => 172
CLASS_STRING_OVERRIDE_LOWER => 173
PREVENT_SPELL_PROTECTION_EFFECTS => 174
IMMUNITY_TO_BACKSTAB => 175
LOCKPICKINGMTPBONUS => 176
MOVESILENTLYMTPBONUS => 177
TRAPSMTPBONUS => 178
PICKPOCKETMTPBONUS => 179
HIDEINSHADOWSMTPBONUS => 180
DETECTILLUSIONSMTPBONUS => 181
SETTRAPSMTPBONUS => 182
PREVENT_AI_SLOWDOWN => 183
EXISTANCE_DELAY_OVERRIDE => 184
ANIMATION_ONLY_HASTE => 185
NO_PERMANENT_DEATH => 186
IMMUNE_TO_TURN_UNDEAD => 187
LEVELDRAIN => 200
WING_BUFFET => 156
LEVEL_DRAIN_IMMUNITY => 158
OFFENSIVE_MODIFIER => 159
DEFENSIVE_MODIFIER => 160
STRENGTH_MODIFIER => 161
WIZARD_PROTECTION_FROM_PETRIFICATION => 176
WIZARD_SPELL_SHIELD => 177
WIZARD_RESIST_FEAR => 178
WIZARD_PROTECTION_FROM_NORMAL_MISSILES => 179
WIZARD_GREATER_MALISON => 180
WIZARD_PROTECTION_FROM_NORMAL_WEAPONS => 181
WIZARD_TENSERS_TRANSFORMATION => 182
END

// handle the problematic 176-182 stats

ACTION_IF !enhanced_edition && !is_tobex BEGIN
    // on non-ToBEx, non-EE installs, give them duplicate
    // names to match EE usage (this facilitates automated
    // hot-swapping of code)
       ACTION_DEFINE_ASSOCIATIVE_ARRAY stats_array BEGIN
           PROTECTION_FROM_PETRIFICATION => 176
           SPELL_SHIELD => 177
           RESIST_FEAR => 178
           PROTECTION_FROM_NORMAL_MISSILES => 179
           MALISON => 180
           PROTECTION_FROM_NORMAL_WEAPONS => 181
           TENSERS_TRANSFORMATION => 182
       END
END ELSE BEGIN
    // on EE/ToBEx installs, add markers to show they are problematic
    // (else I look at stats.ids and make the mistake of trusting it)
       ACTION_DEFINE_ASSOCIATIVE_ARRAY stats_array BEGIN
           PROTECTION_FROM_PETRIFICATION_DONOTUSE => 176
           SPELL_SHIELD_DONOTUSE => 177
           RESIST_FEAR_DONOTUSE => 178
           PROTECTION_FROM_NORMAL_MISSILES_DONOTUSE => 179
           MALISON_DONOTUSE => 180
           PROTECTION_FROM_NORMAL_WEAPONS_DONOTUSE => 181
           TENSERS_TRANSFORMATION_DONOTUSE => 182
       END
END

COPY_EXISTING "stats.ids" override
   REPLACE_TEXTUALLY "[0-9]+ +DMWW_SLOT_[0-9]+\(%WNL%\|%LNL%\|%MNL%\)" "\1"
ACTION_PHP_EACH stats_array AS name => code BEGIN
      ACTION_IF !FILE_CONTAINS_EVALUATED ("override/stats.ids" "%code%[ %TAB%]+%name%") BEGIN
         APPEND "stats.ids" "%code% %name%"
      END
END

 LAF ds_sort_ids STR_VAR ids=stats END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////  Sort an IDS file into numerical order (copy of function in stratagems/sfo/general/lib_general.tpa, with new ds-localised helper function
/////  and some EVALs to function in a non-AUTO_EVAL_STRINGS environment)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_sort_ids STR_VAR ids="" BEGIN
   ACTION_CLEAR_ARRAY ids_entries
   OUTER_SET max=0
   COPY_EXISTING "%ids%.ids" override
       READ_2DA_ENTRIES_NOW ids_array 2
       // top row is either 'IDS V1.0', or a single row entry, or blank
       PATCH_IF INDEX_BUFFER ("IDS *V1.0")>=0 BEGIN
          SPRINT top_row "IDS V1.0"
       END ELSE BEGIN
          COUNT_2DA_ROWS 1 rowcount_1
          PATCH_IF rowcount_1=ids_array BEGIN
             SPRINT top_row " "
          END ELSE BEGIN
             READ_2DA_ENTRY 0 0 1 top_row
          END
       END
       FOR (i=0;i<ids_array;i+=1) BEGIN
          READ_2DA_ENTRY_FORMER ids_array i 0 num
          PATCH_IF IS_AN_INT num BEGIN
             SET max= num>max ? num : max
             READ_2DA_ENTRY_FORMER ids_array i 1 val
             PATCH_IF "%val%" STRING_COMPARE_CASE DMWW_UNUSED_FOR_DELETION BEGIN
               PATCH_IF VARIABLE_IS_SET $ids_entries("%num%") BEGIN
                SPRINT temp $ids_entries("%num%")
                SPRINT $ids_entries("%num%") "%temp% %val%"
               END ELSE BEGIN
                SPRINT $ids_entries("%num%") "%val%"
               END
             END
          END
       END
   BUT_ONLY
   COPY ".../ds-inline/blank" "override/%ids%.ids"
       INSERT_2DA_ROW 0 2 "DW_SORT_IDS_PLACEHOLDER"
       SET rowcount=0
       FOR (num=0;num<=max;num+=1) BEGIN
          PATCH_IF VARIABLE_IS_SET $ids_entries("%num%") BEGIN
             SPRINT list $ids_entries("%num%")
             WHILE "%list%" STRING_COMPARE "" BEGIN
                LPF ds_return_first_entry STR_VAR list RET entry list END
                SPRINT check "%num%--%entry%"
                PATCH_IF !VARIABLE_IS_SET EVAL "%check%" BEGIN
                  INSERT_2DA_ROW rowcount 2 "%num% %entry%"
                  SET rowcount+=1
                  SPRINT EVAL "%check%" ""
                END
             END
          END
       END
       REPLACE_TEXTUALLY "DW_SORT_IDS_PLACEHOLDER" "%top_row%"
END

DEFINE_PATCH_FUNCTION ds_return_first_entry
   STR_VAR list=""
   RET entry
       list
BEGIN
   PATCH_IF "%list%" STRING_EQUAL "" BEGIN // return nothing if list is empty
      SPRINT list ""
      SPRINT entry ""
   END ELSE
   PATCH_IF INDEX (" " "%list%")<0 BEGIN // only one entry
      SPRINT entry "%list%"
      SPRINT list ""
   END ELSE BEGIN
    INNER_PATCH_SAVE list "%list%" BEGIN
      REPLACE_EVALUATE "\([^ ]*\) \(.*\)"
      BEGIN
         SPRINT entry "%MATCH1%"
      END
      "%MATCH2%"
    END
   END
END

<<<<<<<< .../ds-inline/blank
>>>>>>>>



//////////////////////////////////////////////////////////////////////////////////////
//  Legacy code (adapted from Ardanis DS v3)                                     //////////////
//////////////////////////////////////////////////////////////////////////////////////

// Warding Whip can be broken by older versions of DS. Check it up.
//
// If broken, but in a recognizable shape, we try to fix it first, before resorting to replacement with a backup file.
//
// While it likely is possible to write sufficiently sophisticated code to reanimate the file even if it has
// suffered the most dire kind of abuse, I feel that's rather excessive to do so.

DEFINE_ACTION_FUNCTION ds_fix_khelben BEGIN

COPY_EXISTING ~spwi705.spl~ override
  READ_LONG  0x64 ab_off
  READ_SHORT 0x68 ab_num
  READ_LONG  0x6a ef_off
  fubar=0

  // check if the file is ok
  repair=0
  total=0
  FOR (i=0;i<ab_num;i+=1) BEGIN
    READ_SHORT ab_off+i*0x28+0x1e ef_num
    total+=ef_num
  END
  total+=SHORT_AT 0x70
  PATCH_IF SOURCE_SIZE != ef_off+total*0x30 BEGIN
    repair=1
    PATCH_PRINT ~Detectable Spells: SPWI705.SPL is broken, attempting to repair the file~
  END

  PATCH_IF repair BEGIN

    // calculate the number of effects
    total=0
    size = SOURCE_SIZE - ef_off
    WHILE (size - 0x30) >= 0 BEGIN
      total +=1
      size -=0x30
    END
    PATCH_IF size > 0 && size < 0x30 BEGIN
      fubar=1
      PATCH_PRINT ~Detectable Spells: SPWI705.SPL is broken in unknown manner, restoring from a backup~
    END

    // check if the first effect in each header is the expected 233/1/132
    PATCH_IF fubar=0 BEGIN
      FOR (i=0;i<ab_num;i+=1) BEGIN
        READ_SHORT ab_off+i*0x28+0x20 ef_ind
        READ_SHORT ef_off+ef_ind*0x30 opcode
        READ_LONG ef_off+ef_ind*0x30+4 par1
        READ_LONG ef_off+ef_ind*0x30+8 par2
        PATCH_IF (opcode!=233 || par1!=1 || par2!=132) // 
              && (opcode!=233 || par1!=0 || par2!=116) // 
              && (opcode!=233 || par1!=0 || par2!=129) // 
              && (opcode!=282 || par1!=0 || par2!=5)   // 
              && (opcode!=282 || par1!=0 || par2!=7)   // 
              && (opcode!=282 || par1!=0 || par2!=21)  // 
        BEGIN
          fubar=1
          PATCH_PRINT ~Detectable Spells: SPWI705.SPL is broken in unknown manner, restoring from a backup~
        END
      END
    END

    // write the real number of effects per header
    PATCH_IF fubar=0 BEGIN
      FOR (i=0;i<ab_num;i+=1) BEGIN
        READ_SHORT ab_off+i*0x28+0x20 ef_ind
        PATCH_IF i+1 < ab_num BEGIN // if not the last header
          READ_SHORT ab_off+i*0x28+0x48 next_ind
          number = next_ind - ef_ind
          total -= number
        END ELSE BEGIN // if the last
          number = total
        END
        WRITE_SHORT ab_off+i*0x28+0x1e number
      END
    END

    // now kill off the shit
    PATCH_IF fubar=0 BEGIN
      delta=0
      FOR (i=0;i<ab_num;i+=1) BEGIN
        READ_SHORT ab_off+i*0x28+0x1e ef_num
        READ_SHORT ab_off+i*0x28+0x20 ef_ind
        ef_ind +=delta
        WRITE_SHORT ab_off+i*0x28+0x20 ef_ind
        local_delta=0
        FOR (k=0;k<ef_num;k+=1) BEGIN
          READ_SHORT ef_off+(k+ef_ind+local_delta)*0x30 opcode
          READ_LONG ef_off+(k+ef_ind+local_delta)*0x30+4 par1
          READ_LONG ef_off+(k+ef_ind+local_delta)*0x30+8 par2
          PATCH_IF (opcode=233 && par1=1 && par2=132) // 
                || (opcode=233 && par1=0 && par2=116) // 
                || (opcode=233 && par1=0 && par2=129) // 
                || (opcode=282 && par1=0 && par2=5)   // 
                || (opcode=282 && par1=0 && par2=7)   // 
                || (opcode=282 && par1=0 && par2=21)  // 
          BEGIN
            DELETE_BYTES ef_off+(k+ef_ind+local_delta)*0x30 0x30
            delta -=1
            local_delta -=1
          END
        END
        WRITE_SHORT ab_off+i*0x28+0x1e ef_num+local_delta
      END
      PATCH_PRINT ~Detectable Spells: SPWI705.SPL has been successfully repaired~
    END

  END // PATCH_IF repair=1
BUT_ONLY

ACTION_IF fubar BEGIN
  COPY_EXISTING ~spwi705.spl~ override
    READ_ASCII 0x0 data (0x64)
  BUT_ONLY
  
  CREATE SPL "spwi705"
    WRITE_ASCIIE 0x0 "%data%"
    WRITE_SHORT 0x68 1
    WRITE_LONG 0x6a 0x9a
    INSERT_BYTES 0x72 0x28
    WRITE_SHORT 0x72 2
    WRITE_SHORT (0x72+2) 2
    WRITE_ASCII (0x72+4) "SPWI705B"
    WRITE_BYTE (0x72 + 0xc) 1
    WRITE_SHORT (0x72 + 0x10) 1
    WRITE_SHORT (0x72 + 0x12) 7
    WRITE_SHORT (0x72 + 0x22) 1
    WRITE_SHORT (0x72 + 0x24) 1
    WRITE_SHORT (0x72 + 0x26) 221
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=230 parameter1=8 parameter2=1 timing=1 duration=0 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=215 parameter1=0 parameter2=1 timing=0 duration=3 target=2 power=7 resist_dispel=2
                           STR_VAR resource=~spattck1~ END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=139 parameter1=40690 parameter2=0 timing=1 duration=0 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=240 parameter1=0 parameter2=28 timing=1 duration=0 target=2 power=7 resist_dispel=2 END
    
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=230 parameter1=8 parameter2=1 timing=4 duration=7 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=177 parameter1=0 parameter2=2 timing=3 duration=7 target=2 power=7 resist_dispel=2
                           STR_VAR resource=~spattck1~ END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=139 parameter1=40690 parameter2=0 timing=4 duration=7 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=240 parameter1=0 parameter2=28 timing=4 duration=7 target=2 power=7 resist_dispel=2 END

    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=230 parameter1=8 parameter2=1 timing=4 duration=13 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=177 parameter1=0 parameter2=2 timing=3 duration=13 target=2 power=7 resist_dispel=2
                           STR_VAR resource=~spattck1~ END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=139 parameter1=40690 parameter2=0 timing=4 duration=13 target=2 power=7 resist_dispel=2 END
    LPF ~ADD_SPELL_EFFECT~ INT_VAR opcode=240 parameter1=0 parameter2=28 timing=4 duration=13 target=2 power=7 resist_dispel=2 END


END

END // end of function

//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////

// Since SCS occupies one of DS slots for weapons, I see no reason not to include it

DEFINE_ACTION_FUNCTION ds_detectable_weapon_enchantment BEGIN

LAF ds_resolve_stat STR_VAR id=~WEAPON_ENCHANTMENT~ END

COPY_EXISTING_REGEXP GLOB ~.*\.itm~ override 
PATCH_TRY
PATCH_IF SOURCE_SIZE>0x71 BEGIN 
 LPF ~FJ_SPL_ITM_REINDEX~ END

  
  READ_LONG  0x64 ab_off
  READ_SHORT 0x68 ab_num

  weapon=0
  FOR (i=0;i<ab_num;i+=1) BEGIN
    READ_BYTE ab_off+i*0x38 typ
    READ_BYTE ab_off+i*0x38+2 loc
    PATCH_IF (typ=1 || typ=2) && loc=1 BEGIN
      weapon=1
    END
  END

  PATCH_IF weapon BEGIN
    READ_LONG  0x60 ench
    READ_LONG  0x6a ef_off
    READ_SHORT 0x70 global
    exists=0
    FOR (i=0;i<global;i+=1) BEGIN
      READ_SHORT ef_off+i*0x30 opc
      READ_LONG ef_off+i*0x30+4 p1
      READ_LONG ef_off+i*0x30+8 p2
      PATCH_IF opc=233 && p2=109 BEGIN
        PATCH_IF p1 !=ench BEGIN
          WRITE_LONG ef_off+i*0x30+4 ench
        END
        i=global
        exists=1
      END
    END

    PATCH_IF exists=0 BEGIN
      INSERT_BYTES ef_off 0x30
      WRITE_SHORT ef_off 233
      WRITE_BYTE ef_off+2 1
      WRITE_LONG ef_off+4 ench
      WRITE_LONG ef_off+8 109
      WRITE_BYTE ef_off+0xc 2
      WRITE_LONG ef_off+0x12 100

      FOR (i=0;i<ab_num;i+=1) BEGIN
        WRITE_SHORT ab_off+i*0x38+0x20 THIS+1
      END

      WRITE_SHORT 0x70 global+1
    END

  END // PATCH_IF weapon=1
END
WITH DEFAULT
	PATCH_WARN "Detectable Spells has had to skip file %SOURCE_FILE% (error message was: %ERROR_MESSAGE%). Installation will continue, but there may be instabilities."
END
BUT_ONLY

END // end of function


//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////

// Tightly based on Nythrun's ~fj_spl_itm_reindex~ patch 

DEFINE_PATCH_FUNCTION ~FJ_SPL_ITM_REINDEX~ BEGIN

PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.spl~) BEGIN
  hs = 0x28
  WRITE_LONG 0xc ~-1~ //Identified name
  WRITE_LONG 0x54 ~-1~ //Identified description
  PATCH_FOR_EACH tz IN 0x44 0x48 0x58 0x5c BEGIN
    WRITE_LONG tz 0
  END
END ELSE PATCH_IF !(~%SOURCE_FILE%~ STRING_MATCHES_REGEXP ~^.+\.itm~) BEGIN
  hs = 0x38
END
READ_LONG 0x64 hf //Extended header offset
READ_SHORT 0x68 hc //Extended header count
READ_LONG 0x6a fb //Feature block table offset
READ_SHORT 0x70 fc //Feature block count
PATCH_IF ((hf > fb) AND (hc > 0)) BEGIN
  READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
  PATCH_IF (~%eh%~ STRING_EQUAL ~fail~) BEGIN
    WHILE ((~%eh%~ STRING_EQUAL ~fail~) AND (hc > 0)) BEGIN
      READ_ASCII hf ~eh~ ELSE ~fail~ (hs * hc)
      hc -= 1
    END
  END
  DELETE_BYTES hf (hs * hc)
  hf = 0x72
  WRITE_LONG 0x64 hf
  WRITE_SHORT 0x68 hc
  fb = (0x72 + (hs * hc))
  WRITE_LONG 0x6a fb
  PATCH_IF !(~%eh%~ STRING_EQUAL ~fail~) BEGIN
    INSERT_BYTES hf (hs * hc)
    WRITE_ASCIIE hf ~%eh%~
  END
END ELSE PATCH_IF ((hf != 0x72) AND (hc = 0)) BEGIN
  hf = 0x72
  WRITE_LONG 0x64 hf
END
FOR (i1 = 0; i1 < (hs * hc); i1 += hs) BEGIN
  WRITE_SHORT (hf + i1 + 0x20) fc
  READ_SHORT (hf + i1 + 0x1e) cx
  fc += cx
END
PATCH_IF (SOURCE_SIZE > (0x72 + (hs * hc) + (0x30 * fc))) BEGIN
  DELETE_BYTES (0x72 + (hs * hc) + (0x30 * fc)) (SOURCE_SIZE - (0x72 + (hs * hc) + (0x30 * fc)))
END

// added by Ardanis
WRITE_SHORT 0x6e 0

END // end of function

//////////////////////////////////////////////////////////////////////////////////////
//// Softcoded version of WEIDU LOOKUP_IDS, because we don't want to have to keep clearing
//// the IDS map
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ds_load_ids
	STR_VAR ids=""
	RET_ARRAY ids_map
BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%ids%.ids" BEGIN
	COPY_EXISTING "%ids%.ids" "override"
		READ_2DA_ENTRIES_NOW _ds_ids_entries 2
		FOR (row=0;row<_ds_ids_entries;++row) BEGIN
			READ_2DA_ENTRY_FORMER _ds_ids_entries row 0 val
			PATCH_IF IS_AN_INT val BEGIN
				READ_2DA_ENTRY_FORMER _ds_ids_entries row 1 var
				SET $ids_map("%var%")=val
			END
		END
	BUT_ONLY
  END
  OUTER_SET $ids_map("DS_IDS_MAP_LOADED")=1
END
<<<<<<<<.../stratagems-inline/bg1_area_list.2da
2DA V1.0
*
										default bgt 
NBaldursGate_TempleofHelm             AR0002 ARA002
NBaldursGate_BherensHouse_L1          AR0004 ARA004
NBaldursGate_BherensHouse_L2          AR0005 ARA005
NBaldursGate_RinniesHouse_L1          AR0006 ARA006
NBaldursGate_RinniesHouse_L2          AR0007 ARA007
NBaldursGate_House1_L1                AR0008 ARA008
NBaldursGate_House1_L2                AR0009 ARA009
NBaldursGate_JardaksHouse_L1          AR0010 ARA010
NBaldursGate_JardaksHouse_L2          AR0011 ARA011
NBaldursGate_House2_L1                AR0012 ARA012
NBaldursGate_House2_L2                AR0013 ARA013
NBaldursGate_House3_L1                AR0014 ARA014
NBaldursGate_House3_L2                AR0015 ARA015
NBaldursGate_House4_L1                AR0016 ARA016
NBaldursGate_House4_L2                AR0017 ARA017
NBaldursGate_House5_L1                AR0018 ARA018
NBaldursGate_House5_L2                AR0019 ARA019
NBaldursGate_House6_L1                AR0020 ARA020
NBaldursGate_House6_L2                AR0021 ARA021
NWBaldursGate                         AR0100 AR7200
NWBaldursGate_SilvershieldEstate_L1   AR0101 AR7201
NWBaldursGate_SilvershieldEstate_L2   AR0102 AR7202
NEBaldursGate_SplurgingSturgeon_L1    AR0103 AR7203
NEBaldursGate_SplurgingSturgeon_L2    AR0104 AR7204
SEBaldursGate_Blade&Stars_L1          AR0105 AR7205
SEBaldursGate_Blade&Stars_L2          AR0106 AR7206
SEBaldursGate_Blade&Stars_L3          AR0107 AR7207
NBaldursGate_DucalPalace_L1           AR0108 AR7208
NBaldursGate_DucalPalace_L2           AR0109 AR7209
NBaldursGate_DucalPalace_L3           AR0110 AR7210
NBaldursGate_DucalPalace_Cellar       AR0111 AR7211
BaldursGate_Undercellars              AR0112 AR7212
NEBaldursGate_BlushingMermaid_L1      AR0114 AR7214
NEBaldursGate_BlushingMermaid_L2      AR0115 AR7215
NWBaldursGate_Helm&Cloak_L1           AR0116 AR7216
NWBaldursGate_Helm&Cloak_L2           AR0117 AR7217
NWBaldursGate_Helm&Cloak_L3           AR0118 AR7218
NBaldursGate_ThreeOldKegs_L1          AR0119 AR7219
NBaldursGate_ThreeOldKegs_L2          AR0120 AR7220
NBaldursGate_ThreeOldKegs_L3          AR0121 AR7221
Undercity                             AR0123 AR7223
Undercity_TempleofBhaal               AR0125 AR7225
WBaldursGate_RagefastsHouse           AR0126 AR7226
SWBaldursGate_MerchantLeague_L1       AR0127 AR7227
SWBaldursGate_MerchantLeague_L2       AR0128 AR7228
SWBaldursGate_MerchantLeague_L3       AR0129 AR7229
WBaldursGate_HallofWonders            AR0130 AR7230
WBaldursGate_HighHouseofWonders       AR0131 AR7231
WBaldursGate_LadysHouse               AR0132 AR7232
BaldursGate_DocksLowLantern_D1        AR0133 AR7233
BaldursGate_DocksLowLantern_D2        AR0134 AR7234
BaldursGate_DocksLowLantern_D3        AR0135 AR7235
BaldursGate_DocksLowLantern_D4        AR0136 AR7236
NBaldursGate_RamazithsTower_L1        AR0137 AR7237
NBaldursGate_RamazithsTower_L6        AR0138 AR7238
NBaldursGate_RamazithsTower_L2        AR0139 AR7239
NBaldursGate_RamazithsTower_L3        AR0140 AR7240
NBaldursGate_RamazithsTower_L4        AR0141 AR7241
NBaldursGate_RamazithsTower_L5        AR0142 AR7242
CentralBaldursGate_OberonsEstate_L1   AR0143 AR7243
CentralBaldursGate_OberonsEstate_L2   AR0144 AR7244
CentralBaldursGate_OberonsEstate_L3   AR0145 AR7245
ThievesMaze                           AR0146 AR7246
EBaldursGate_House5                   AR0148 AR7248
NEBaldursGate_IlmatersShrine          AR0149 AR7249
EBaldursGate_House2                   AR0150 AR7250
EBaldursGate_House3                   AR0151 AR7251
EBaldursGate_House4                   AR0152 AR7252
EBaldursGate_ThievesGuild             AR0153 AR7253
EBaldursGate_KeexieTavern_L1          AR0154 AR7254
NWBaldursGate_House3_L1               AR0155 AR7255
NWBaldursGate_House3_L2               AR0156 AR7256
NWBaldursGate_QuinnsHouse_L1          AR0157 AR7257
NWBaldursGate_QuinnsHouse_L2          AR0158 AR7258
NWBaldursGate_House1_L1               AR0159 AR7259
NWBaldursGate_House1_L2               AR0160 AR7260
NWBaldursGate_DegrodelsHouse          AR0161 AR7261
NWBaldursGate_LaertasHouse_L1         AR0162 AR7262
NWBaldursGate_House2_L1               AR0163 AR7263
NWBaldursGate_House2_L2               AR0164 AR7264
NWBaldursGate_Tavern_L1               AR0165 AR7265
NWBaldursGate_Tavern_L2               AR0166 AR7266
NWBaldursGate_PheirkasHouse_L1        AR0167 AR7267
NWBaldursGate_PheirkasHouse_L2        AR0168 AR7268
NWBaldursGate_House4_L1               AR0169 AR7269
NWBaldursGate_House4_L2               AR0170 AR7270
EBaldursGate_KeexieTavern_L2          AR0171 AR7271
NBaldursGate                          AR0200 AR7300
WSewers                               AR0224 AR7324
CentralSewers                         AR0225 AR7325
ESewers                               AR0226 AR7326
NEBaldursGate                         AR0300 AR7400
NEBaldursGate_House2_L1               AR0302 AR7402
NEBaldursGate_House2_L2               AR0303 AR7403
NEBaldursGate_Store                   AR0304 AR7404
NEBaldursGate_House1_L1               AR0305 AR7405
NEBaldursGate_House1_L2               AR0306 AR7406
NEBaldursGate_CountingHouse_L1        AR0307 AR7407
NEBaldursGate_CountingHouse_L2        AR0308 AR7408
WBaldursGate                          AR0600 AR7600
SWBaldursGate_SevenSuns_L1            AR0601 AR7601
SWBaldursGate_SevenSuns_L2            AR0602 AR7602
SWBaldursGate_SevenSuns_Cellar        AR0603 AR7603
SWBaldursGate_FlamingFistHQ_Cellar    AR0606 AR7606
SWBaldursGate_FlamingFistHQ_L1        AR0607 AR7607
SWBaldursGate_FlamingFistHQ_L2        AR0608 AR7608
BaldursGateDocks_WaterQueensHouse     AR0609 AR7609
BaldursGateDocks_IronThrone_Cellar    AR0611 AR7611
BaldursGateDocks_IronThrone_L2        AR0612 AR7612
BaldursGateDocks_IronThrone_L3        AR0613 AR7613
BaldursGateDocks_IronThrone_L4        AR0614 AR7614
BaldursGateDocks_IronThrone_L5        AR0615 AR7615
BaldursGateDocks_IronThrone_L1        AR0616 AR7616
WBaldursGate_TremainsHouse_L1         AR0617 AR7617
WBaldursGate_TremainsHouse_L2         AR0618 AR7618
WBaldursGate_FentensHouse_L1          AR0619 AR7619
WBaldursGate_FentensHouse_L2          AR0620 AR7620
BaldursGateDocks_IronThroneRoof       AR0621 AR7621
CentralBaldursGate                    AR0700 AR7700
BaldursGateDocks_Harbormaster         AR0702 AR7702
EBaldursGate_SorcerousSundries_L1     AR0703 AR7703
EBaldursGate_SorcerousSundries_L2     AR0704 AR7704
EBaldursGate_ElfsongTavern_L1         AR0705 AR7705
EBaldursGate_ElfsongTavern_L2         AR0706 AR7706
CentralBaldursGate_House3_L1          AR0707 AR7707
CentralBaldursGate_House3_L2          AR0708 AR7708
CentralBaldursGate_House2_L1          AR0709 AR7709
CentralBaldursGate_House2_L2          AR0710 AR7710
CentralBaldursGate_House1_L1          AR0711 AR7711
CentralBaldursGate_House1_L2          AR0712 AR7712
CentralBaldursGate_House5_L1          AR0713 AR7713
CentralBaldursGate_House5_L2          AR0714 AR7714
CentralBaldursGate_NadinesHouse_L1    AR0715 AR7715
CentralBaldursGate_NadinesHouse_L2    AR0716 AR7716
CentralBaldursGate_House6_L1          AR0717 AR7717
CentralBaldursGate_House6_L2          AR0718 AR7718
CentralBaldursGate_FeloniusManor      AR0719 AR7719
CentralBaldursGate_DrakonTavern       AR0720 AR7720
CentralBaldursGate_PoultryStore       AR0721 AR7721
CentralBaldursGate_House4_L1          AR0722 AR7722
CentralBaldursGate_House4_L2          AR0723 AR7723
CentralBaldursGate_GamblingTent1      AR0724 AR7724
CentralBaldursGate_GamblingTent2      AR0725 AR7725
CentralBaldursGate_DivinersTent       AR0726 AR7726
EBaldursGate                          AR0800 AR7800
EBaldursGate_House6_L1                AR0801 AR7801
EBaldursGate_House6_L2                AR0802 AR7802
EBaldursGate_MaltzWeaponShop_L1       AR0803 AR7803
EBaldursGate_MaltzWeaponShop_L2       AR0804 AR7804
EBaldursGate_ArkionsHouse_L1          AR0805 AR7805
EBaldursGate_ArkionsHouse_L2          AR0806 AR7806
EBaldursGate_Inn_L1                   AR0807 AR7807
EBaldursGate_Inn_L2                   AR0808 AR7808
EBaldursGate_SilencesShop             AR0809 AR7809
EBaldursGate_LuckyAellos              AR0810 AR7810
EBaldursGate_House1_L1                AR0811 AR7811
EBaldursGate_House1_L2                AR0812 AR7812
SEBaldursGate_NemphresHouse_L1        AR0813 AR7813
SEBaldursGate_NemphresHouse_L2        AR0814 AR7814
WyrmsCrossing                         AR0900 AR7900
WyrmsCrossingTenyasHouse              AR0901 AR7901
SWBaldursGate                         AR1100 AR8000
SWBaldursGate_WivensHouse_L1          AR1101 AR8001
SWBaldursGate_WivensHouse_L2          AR1102 AR8002
SWBaldursGate_House3_L1               AR1103 AR8003
SWBaldursGate_House3_L2               AR1104 AR8004
SWBaldursGate_House1_L1               AR1105 AR8005
SWBaldursGate_House1_L2               AR1106 AR8006
SWBaldursGate_House2_L1               AR1107 AR8007
SWBaldursGate_House2_L2               AR1108 AR8008
SWBaldursGate_Tavern_L1               AR1109 AR8009
SWBaldursGate_Tavern_L2               AR1110 AR8010
SWBaldursGate_SuninsHouse             AR1111 AR8011
SWBaldursGate_WeaponsStore1           AR1112 AR8012
SWBaldursGate_YeOldeInn_L1            AR1113 AR8013
SWBaldursGate_YeOldeInn_L2            AR1114 AR8014
SWBaldursGate_PotionsStore2           AR1115 AR8015
SWBaldursGate_WeaponsStore2           AR1116 AR8016
SWBaldursGate_PotionsStore1           AR1117 AR8017
BaldursGateDocks                      AR1200 AR8100
BaldursGateDocks_OgreMagiHouse_L1     AR1201 AR8101
BaldursGateDocks_OgreMagiHouse_L2     AR1202 AR8102
BaldursGateDocks_House2_L1            AR1203 AR8103
BaldursGateDocks_House2_L2            AR1204 AR8104
BaldursGateDocks_House1_L1            AR1205 AR8105
BaldursGateDocks_House1_L2            AR1206 AR8106
BaldursGateDocks_BasiliskWarehouse    AR1207 AR8107
BaldursGateDocks_NoraleesWarehouse    AR1208 AR8108
BaldursGateDocks_LarriazHouse_L1      AR1209 AR8109
BaldursGateDocks_LarriazHouse_L2      AR1210 AR8110
BaldursGateDocks_GhoraksHouse_L1      AR1211 AR8111
BaldursGateDocks_GhoraksHouse_L2      AR1212 AR8112
BaldursGateDocks_CordyrsHouse_L1      AR1213 AR8113
BaldursGateDocks_CordyrsHouse_L2      AR1214 AR8114
BaldursGateDocks_JopalinsTavern       AR1215 AR8115
SEBaldursGate                         AR1300 AR8200
SEBaldursGate_Warehouse               AR1301 AR8201
SEBaldursGate_GeneralStore2           AR1302 AR8202
SEBaldursGate_NadarinsWarehouse       AR1303 AR8203
SEBaldursGate_House3_L1               AR1304 AR8204
SEBaldursGate_House3_L2               AR1305 AR8205
SEBaldursGate_Inn_L1                  AR1306 AR8206
SEBaldursGate_Inn_L2                  AR1307 AR8207
SEBaldursGate_House4_L1               AR1308 AR8208
SEBaldursGate_House4_L2               AR1309 AR8209
SEBaldursGate_House2_L1               AR1310 AR8210
SEBaldursGate_House2_L2               AR1311 AR8211
SEBaldursGate_GantolandansHouse_L1    AR1312 AR8212
SEBaldursGate_GantolandansHouse_L2    AR1313 AR8213
SEBaldursGate_House1_L1               AR1314 AR8214
SEBaldursGate_House1_L2               AR1315 AR8215
SEBaldursGate_TaxeksHouse_L1          AR1316 AR8216
SEBaldursGate_TaxeksHouse_L2          AR1317 AR8217
SEBaldursGate_GeneralStore1           AR1320 AR8220
FishingVillage                        AR1400 AR8300
FishingVillage_AnkhegPit              AR1401 AR8301
FishingVillage_House1                 AR1402 AR8302
FishingVillage_House2                 AR1403 AR8303
FishingVillage_FarmerBrunsHouse       AR1404 AR8304
CloakwoodDruids                       AR1600 AR8400
CloakwoodDruids_Treehouse_L1          AR1601 AR8401
CloakwoodDruids_Treehouse_L2          AR1602 AR8402
CloakwoodDruids_PetersCave            AR1603 AR8403
CloakwoodWyverns                      AR1700 AR8500
CloakwoodMines                        AR1800 AR8600
CloakwoodMines_L1                     AR1801 AR8601
CloakwoodMines_L3                     AR1802 AR8602
CloakwoodMines_L4                     AR1803 AR8603
CloakwoodMines_L2                     AR1804 AR8604
CloakwoodMines_Barracks_L1            AR1805 AR8605
CloakwoodMines_Barracks_L2            AR1806 AR8606
CloakwoodMines_MineLift               AR1807 AR8607
CloakwoodMines_Storehouse             AR1808 AR8608
CloakwoodMines_MineShed               AR1809 AR8609
BanditCamp                            AR1900 AR8700
BanditCamp_RaemonsTent                AR1901 AR8701
BanditCamp_Tent2                      AR1902 AR8702
BanditCamp_GnollCave                  AR1903 AR8703
BanditCamp_TersusTent                 AR1904 AR8704
BanditCamp_Tent1                      AR1905 AR8705
BanditCamp_Tent3                      AR1906 AR8706
BanditCamp_Tent4                      AR1907 AR8707
CloakwoodNest                         AR2100 AR8800
CloakwoodNestSpiderNest               AR2101 AR8801
CloakwoodLodge                        AR2200 AR7000
CloakwoodLodgeHuntingLodge            AR2215 AR7015
FriendlyArmInn                        AR2300 AR6800
FriendlyArmInn_L1                     AR2301 AR6801
FriendlyArmInn_L2                     AR2302 AR6802
FriendlyArmInn_L3                     AR2303 AR6803
FriendlyArmInn_TempleofWisdom         AR2304 AR6804
FriendlyArmInn_House                  AR2305 AR6805
FriendlyArmInn_JoiasHouse             AR2306 AR6806
Peldvale                              AR2400 AR8900
Candlekeep                            AR2600 AR0015
Candlekeep_PriestsQuarters            AR2602 AR6502
Candlekeep_Infirmary                  AR2605 AR6505
Candlekeep_Storehouse                 AR2606 AR6506
Candlekeep_Bunkhouse                  AR2607 AR6507
Candlekeep_Library_L1                 AR2608 AR6508
Candlekeep_Library_L2                 AR2609 AR6509
Candlekeep_Library_L3                 AR2610 AR6510
Candlekeep_Library_L4                 AR2611 AR6511
Candlekeep_Library_L5                 AR2612 AR6512
Candlekeep_Catacombs_L1Antechamber    AR2613 AR6513
Candlekeep_Library_L6                 AR2614 AR6514
Candlekeep_Catacombs_L1               AR2615 AR6515
Candlekeep_Inn_L1                     AR2616 AR6516
Candlekeep_Inn_L2                     AR2617 AR6517
Candlekeep_Barracks                   AR2618 AR6518
Candlekeep_Catacombs_L2               AR2619 AR6519
Candlekeep_Ch6                        AR2626 AR6526
Candlekeep_Ch6_PriestsQuarters        AR2627 AR6527
Candlekeep_Ch6_Workhouse              AR2628 AR6528
Candlekeep_Ch6_Inn_L1                 AR2629 AR6529
Candlekeep_Ch6_Inn_L2                 AR2630 AR6530
Candlekeep_Ch6_Barracks               AR2631 AR6531
Candlekeep_Ch6_Bunkhouse              AR2632 AR6532
Candlekeep_Ch6_Infirmary              AR2633 AR6533
Candlekeep_ObesCellar                 AR2643 AR6543
LionsWay                              AR2700 AR6600
CoastWay                              AR2800 AR6900
Larswood                              AR2900 AR9000
SpiderWood                            AR3000 AR9100
ShipwrecksCoast                       AR3100 AR9200
HighHedge                             AR3200 AR7100
HighHedge_House                       AR3201 AR7101
HighHedge_ThalanthyrsAbode            AR3202 AR7102
Beregost                              AR3300 AR6700
Beregost_ThunderhammerSmithy          AR3301 AR6701
Beregost_House19                      AR3302 AR6702
Beregost_RedSheaf_L2                  AR3303 AR6703
Beregost_JovialJuggler_L1             AR3304 AR6704
Beregost_JovialJuggler_L2F            AR3305 AR6705
Beregost_JovialJuggler_L2R            AR3306 AR6706
Beregost_BurningWizard_L1             AR3307 AR6707
Beregost_BurningWizard_L2             AR3308 AR6708
Beregost_House13_L1                   AR3309 AR6709
Beregost_House13_L2                   AR3310 AR6710
Beregost_House12_L1                   AR3311 AR6711
Beregost_House12_L2                   AR3312 AR6712
Beregost_MiriannesHouse_L1            AR3313 AR6713
Beregost_MiriannesHouse_L2            AR3314 AR6714
Beregost_LandrinsHouse                AR3315 AR6715
Beregost_House18                      AR3316 AR6716
Beregost_House17                      AR3317 AR6717
Beregost_House15                      AR3318 AR6718
Beregost_House16                      AR3319 AR6719
Beregost_TravenhurstManor_L1          AR3320 AR6720
Beregost_TravenhurstManor_L2          AR3321 AR6721
Beregost_ServantsQuarters             AR3322 AR6722
Beregost_House20_L1                   AR3323 AR6723
Beregost_House20_L2                   AR3324 AR6724
Beregost_House23_L1                   AR3325 AR6725
Beregost_House23_L2                   AR3326 AR6726
Beregost_House14_L1                   AR3327 AR6727
Beregost_House14_L2                   AR3328 AR6728
Beregost_House21_L1                   AR3329 AR6729
Beregost_House21_L2                   AR3330 AR6730
Beregost_House11_L1                   AR3331 AR6731
Beregost_House11_L2                   AR3332 AR6732
Beregost_FirebeadsHouse_L1            AR3333 AR6733
Beregost_FirebeadsHouse_L2            AR3334 AR6734
Beregost_House10_L1                   AR3335 AR6735
Beregost_House10_L2                   AR3336 AR6736
Beregost_House22_L1                   AR3337 AR6737
Beregost_House22_L2                   AR3338 AR6738
Beregost_House01_L1                   AR3339 AR6739
Beregost_House01_L2                   AR3340 AR6740
Beregost_House02_L1                   AR3341 AR6741
Beregost_House02_L2                   AR3342 AR6742
Beregost_House03                      AR3343 AR6743
Beregost_House07                      AR3344 AR6744
Beregost_House04_L1                   AR3345 AR6745
Beregost_House04_L2                   AR3346 AR6746
Beregost_House05_L1                   AR3347 AR6747
Beregost_House05_L2                   AR3348 AR6748
Beregost_House06_L1                   AR3349 AR6749
Beregost_House06_L2                   AR3350 AR6750
Beregost_FeldepostsInn_L1             AR3351 AR6751
Beregost_FeldepostsInn_L2             AR3352 AR6752
Beregost_KagainsStore                 AR3353 AR6753
Beregost_House09                      AR3354 AR6754
Beregost_House08                      AR3356 AR6756
Beregost_RedSheaf_L1                  AR3357 AR6757
Temple                                AR3400 AR9300
Temple_Vestibule                      AR3401 AR9301
Temple_SongoftheMorning               AR3402 AR9302
MutaminsGarden                        AR3500 AR9400
Lighthouse                            AR3600 AR9500
Lighthouse_BlackAlaricsCave           AR3601 AR9501
RedCanyons                            AR3700 AR9600
SouthBeregostRoad                     AR3800 AR9700
SouthBeregostRoad_Cave                AR3802 AR9702
Ulcaster                              AR3900 AR9799
UlcasterRuins                         AR3901 AR9798
Gullykin                              AR4000 AR9900
Gullykin_JenkalsHouse_L1              AR4001 AR9901
Gullykin_JenkalsHouse_Cellar          AR4002 AR9902
Gullykin_Winery_L1                    AR4003 AR9903
Gullykin_Winery_Cellar                AR4004 AR9904
Gullykin_House1_L1                    AR4005 AR9905
Gullykin_House1_Cellar                AR4006 AR9906
Gullykin_House3_L1                    AR4007 AR9907
Gullykin_House3_Cellar                AR4008 AR9908
Gullykin_House4_L1                    AR4009 AR9909
Gullykin_House4_Cellar                AR4010 AR9910
Gullykin_House5_L1                    AR4011 AR9911
Gullykin_House5_Cellar                AR4012 AR9912
Gullykin_House2_L1                    AR4013 AR9913
Gullykin_House2_Cellar                AR4014 AR9914
ArchaeologicalSite                    AR4100 ARA100
ArchaeologicalSite_Tomb               AR4101 ARA101
FishermansLake                        AR4200 AR3100
NorthNashkelRoad                      AR4300 AR3200
LonelyPeaks                           AR4400 AR3300
LonelyPeaks_Cave                      AR4401 AR3301
FirewineBridge                        AR4500 AR3400
CloakwoodWyverns_WyvernCave           AR4501 AR8501
BearRiver                             AR4600 AR3499
XvartVillage                          AR4700 AR3498
XvartVillage_Cave                     AR4701 AR3497
Nashkel                               AR4800 AR3700
Nashkel_Inn                           AR4801 AR3701
Nashkel_TempleofHelm                  AR4802 AR3702
Nashkel_Store                         AR4803 AR3703
Nashkel_ManorHouse_L1                 AR4804 AR3704
Nashkel_ManorHouse_L2                 AR4805 AR3705
Nashkel_JosephsHouse                  AR4806 AR3706
Nashkel_House1                        AR4807 AR3707
Nashkel_House2                        AR4808 AR3708
Nashkel_BelchingDragonTavern          AR4809 AR3709
Nashkel_Garrison                      AR4810 AR3710
NashkelCarnival                       AR4900 AR3800
NashkelCarnival_ArmorTent             AR4901 AR3801
NashkelCarnival_LotusTent             AR4902 AR3802
NashkelCarnival_VitiaresTent          AR4903 AR3803
NashkelCarnival_GamblingTent          AR4904 AR3804
NashkelCarnival_PotionTent            AR4905 AR3805
NashkelCarnival_ZordralsTent          AR4906 AR3806
NashkelCarnival_MagicItemsTent        AR4907 AR3807
NashkelCarnival_MeleeWeaponsTent      AR4908 AR3808
NashkelCarnival_RangedWeaponsTent     AR4909 AR3809
ValleyoftheTombs                      AR5000 AR3900
ValleyoftheTombs_Tomb                 AR5001 AR3901
GnollStronghold                       AR5100 AR4100
GnollStronghold_XvartCave             AR5101 AR4101
GnollStronghold_TomeCave              AR5102 AR4102
GnollStronghold_CrawlerCave           AR5103 AR4103
DryadFalls                            AR5200 AR4200
FirewineRuins                         AR5201 AR3401
DryadFalls_Cave                       AR5202 AR4199
FireLeafForest                        AR5300 AR4300
NashkelMines                          AR5400 AR4400
NashkelMines_L1                       AR5401 AR4401
NashkelMines_L2                       AR5402 AR4402
NashkelMines_L3                       AR5403 AR4403
NashkelMines_L4                       AR5404 AR4404
NashkelMines_MulaheysCave             AR5405 AR4405
NashkelMines_Cabin                    AR5406 AR4406
GibberlingMountains                   AR5500 AR4600
CandlekeepCaves                       AR5506 AR6560
Encounter_Plains1                     AR5600 AR4700
Encounter_Plains2                     AR5601 AR4701
Encounter_Canyon1                     AR5700 AR4800
Encounter_Canyon2                     AR5701 AR4801
Encounter_Cliff1                      AR5800 AR4900
Encounter_Cliff2                      AR5801 AR4901
Encounter_Grassland1                  AR5900 AR5100
Encounter_Grassland2                  AR5901 AR5101
Encounter_Forest1                     AR6000 AR5300
Encounter_Forest2                     AR6001 AR5301
Encounter_Road                        AR6100 AR5400
Farmlands                             AR0400 AR7500
FarmlandsFarmhouse                    AR0401 AR7501
DurlagsTower                          AR0500 ARD000
DurlagsTower_Cellar                   AR0501 ARD001
DurlagsTower_L1                       AR0502 ARD002
DurlagsTower_L2                       AR0503 ARD003
DurlagsTower_L3                       AR0504 ARD004
DurlagsTower_L4                       AR0505 ARD005
DurlagsTower_Chessboard               AR0506 ARD006
DurlagsTower_IceChamber               AR0507 ARD007
DurlagsTower_FireChamber              AR0508 ARD008
DurlagsTower_AirChamber               AR0509 ARD009
DurlagsTower_EarthChamber             AR0510 ARD010
DurlagsTower_D1                       AR0511 ARD011
DurlagsTower_D2                       AR0512 ARD012
DurlagsTower_D3                       AR0513 ARD013
DurlagsTower_D4                       AR0514 ARD014
DurlagsTower_CompassRoom              AR0515 ARD015
DurlagsTower_DemonknightsChamber      AR0516 ARD016
IsleofBalduranN                       AR1500 ARW500
IsleofBalduranNShip_D1                AR1501 ARW501
IsleofBalduranNShip_D2                AR1502 ARW502
IsleofBalduranNShip_D3                AR1503 ARW503
IsleofBalduranNShip_D4                AR1504 ARW504
IsleofBalduranNDradeelsHouse          AR1505 ARW505
IsleofBalduranS                       AR2000 ARW000
IsleofBalduranS_GreatHut              AR2001 ARW001
IsleofBalduranS_KaishasHut            AR2002 ARW002
IsleofBalduranS_LargeHut3             AR2003 ARW003
IsleofBalduranS_LargeHut2             AR2004 ARW004
IsleofBalduranS_LargeHut4             AR2005 ARW005
IsleofBalduranS_LargeHut1             AR2006 ARW006
IsleofBalduranS_HarborHut             AR2007 ARW007
IsleofBalduranS_StoreHut2             AR2008 ARW008
IsleofBalduranS_StoreHut1             AR2009 ARW009
IsleofBalduranS_StoreHut4             AR2010 ARW010
IsleofBalduranS_StoreHut3             AR2011 ARW011
WerewolfCaverns                       AR2012 ARW012
UlgothsBeard                          AR1000 ARU000
UlgothsBeard_Inn                      AR1001 ARU001
UlgothsBeard_DemonsChamber            AR1002 ARU002
UlgothsBeard_Storehouse               AR1003 ARU003
UlgothsBeard_MendasHouse              AR1004 ARU004
UlgothsBeard_TherellasHouse           AR1005 ARU005
UlgothsBeard_House2                   AR1006 ARU006
UlgothsBeard_House1                   AR1007 ARU007
IceIsland                             AR1008 ARU008
IceIslandMaze_L1                      AR1009 ARU009
IceIslandMaze_L2                      AR1010 ARU010

>>>>>>>>
<<<<<<<<.../stratagems-inline/bg1_file_names.2da
					  bgee         tutu           bgt           eet
IMOEN_DV              imoen        imoen          imoen2        imoen2
BG1_IMOEN6            imoen6       _imoen6        imoen61       imoen6_
BG1_VICONI6           viconi6      _viconi6       viconi61      viconi6_
bg1_skeleton_warrior  skelwa       _skelwa        bgskelwa      skelwa_
bg1_skeleton_warrior2 skelwa02     _kelwa02       bgskel02      bgskel02
bg1_skeleton_warrior3 skelwa03     _kelwa03       bgskel03      bgskel03
tutu_scriptbg         null         _              bg            null
AJANTIS_BCS           AJANTIS      _AJANTIS       AJANTIS       AJANTIS
ALORA_BCS             ALORA        _ALORA         ALORA         ALORA
BRANWEN_BCS           BRANWE       _BRANWE        BGBRANW       BRANWEN_
CORAN_BCS             CORAN        _CORAN         CORAN         CORAN
DYNAHEIR_BCS          YNAHEIR      _YNAHEIR       DYNAHEIR      DYNAHEIR
EDWIN_BCS             EDWIN        _EDWIN         BGEDWIN       EDWIN_
ELDOTH_BCS            ELDOTH       _ELDOTH        ELDOTH        ELDOTH
FALDORN_BCS           FALDO        _FALDO         BGFALDRN      FALDORN_
GARRICK_BCS           GARRI        _GARRI         BGGARRIK      GARRICK_
IMOEN_BCS             IMOEN        _IMOEN         IMOEN2        IMOEN_
JAHEIRA_BCS           JAHEIRA      _JAHEIRA       BGJHEIRA      JAHEIRA_
KAGAIN_BCS            KAGAIN       _KAGAIN        KAGAIN        KAGAIN
KHALID_BCS            KHALID       _KHALID        KHALID        KHALID
KIVAN_BCS             KIVAN        _KIVAN         KIVAN         KIVAN
MINSC_BCS             MINSC        _MINSC         BGMINSC       MINSC_
MONTARON_BCS          MONTARON     _ONTARON       MONTARON      MONTARON
QUAYLE_BCS            QUAYLE       _QUAYLE        QUAYLE        QUAYLE
SAFANA_BCS            SAFANA       _SAFANA        SAFANA        SAFANA
SHARTEEL_BCS          SHARTEEL     _HARTEEL       SHARTEEL      SHARTEEL
SKIE_BCS              SKIE         _SKIE          BGSKIE        SKIE_
TIAX_BCS              TIAX         _TIAX          TIAX          TIAX
VICONIA_BCS           VICONIA      _VICONIA       BGVICNIA      VICONIA_
XAN_BCS               XAN          _XAN           XAN           XAN
XZAR_BCS              XZAR         _XZAR          XZAR          XZAR
YESLICK_BCS           YESLICK      _YESLICK       YESLICK       YESLICK
SAREVOK_SCRIPT        SAREVOK      _SAREVOK       BGSARVOK      SAREVOK_
greater_basilisk_script GBASILSK   _8_GBASI       GBASILSK      GBASILSK
BGT_VAR               null         null           !Global("ENDOFBG1","GLOBAL",2) GlobalLT("ENDOFBG1","GLOBAL",2)  
>>>>>>>>
<<<<<<<<.../stratagems-inline/extra_spell_ids.txt
ids						resref
DARK_MOON_BLINDNESS 				SPDM101 
DARK_MOON_BLUR					SPDM102
DARK_MOON_FROZEN_FIST   			SPDM105 
DARK_MOON_MIRROR_IMAGE  			SPDM106 
DARK_MOON_VAMPIRIC_TOUCH  			SPDM108 
DWARVEN_DEFENDER_DEFENSIVE_STANCE 		SPDWD02 
CLERIC_CHROMATIC_ORB           			SPDR101
CLERIC_WEB                     			SPDR201
CLERIC_LIGHTNING_BOLT          			SPDR301
CLERIC_IMPROVED_INVISIBILITY   			SPDR401
CLERIC_CHAOS                  			SPDR501
CLERIC_CHAIN_LIGHTNING         			SPDR601
PSIONIC_SUPERIOR_INVISIBILITY  			SPIN544
>>>>>>>>






















//////////////////////////////////////////////
///  LIVE CODE!
//////////////////////////////////////////////

ACTION_IF !VARIABLE_IS_SET sfo_library_path BEGIN
	OUTER_SPRINT sfo_library_path sfo
END

//////////////////////////////////////////
// set SFO directories, variables etc
//////////////////////////////////////////

LAM sfo_setup

////////////////////////////////////////////////////////////////////////////
// load ini file
////////////////////////////////////////////////////////////////////////////

ACTION_TIME sfo_setup_ini BEGIN
	ACTION_IF !VARIABLE_IS_SET SFO_ini_loaded BEGIN
		OUTER_SET SFO_ini_loaded=1
		ACTION_IF !VARIABLE_IS_SET SFO_ini_file BEGIN
			OUTER_SPRINT SFO_ini_file "%MOD_FOLDER%.ini"
		END
		ACTION_IF !VARIABLE_IS_SET SFO_ini_file_location BEGIN
			OUTER_SPRINT SFO_ini_file_location "%MOD_FOLDER%"
		END
		ACTION_IF FILE_EXISTS "%SFO_ini_file_location%/%SFO_ini_file%" BEGIN
			LAF ini_read INT_VAR flat=1 STR_VAR file="%SFO_ini_file%" path="%SFO_ini_file_location%" RET_ARRAY SFO_reserved_ini_hash=array END
			LAF ini_read INT_VAR flat=0 STR_VAR file="%SFO_ini_file%" path="%SFO_ini_file_location%" RET_ARRAY SFO_reserved_ini_hash_2d=array END
		END
	END	
END

//////////////////////////////////////////////////////////////////////////////
// handle crossplatform (this actually only happens once)
//////////////////////////////////////////////////////////////////////////////

ACTION_TIME sfo_setup_crossplatform BEGIN
	LAM sfo_crossplatform
END

//////////////////////////////////////////////////////////////////////////////
// do sfo's fixes (to spell.ids, dir.ids, etc)
//////////////////////////////////////////////////////////////////////////////

ACTION_TIME sfo_setup_fix BEGIN
	LAF sfo_fix END
END

////////////////////////////////////////////////////////////////////////////
// load data (this isn't immutable, safest to do it for every component)
// at the moment we're only loading spell data and NPC dvs
////////////////////////////////////////////////////////////////////////////

ACTION_TIME sfo_setup_data BEGIN
	/// spells and scrolls
	LAM data_spell_resrefs
	LAM data_joinable_dvs
END

///// mark that it's installed

OUTER_SET sfo_is_installed=1
