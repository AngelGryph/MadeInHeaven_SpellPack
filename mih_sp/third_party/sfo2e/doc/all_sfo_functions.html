<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>All SFO functions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../../doc/files/g3readme_cam_022916_dwedit.css" type="text/css" />
<link href="../../doc/files/g3icon.ico" rel="icon" type="image/bmp" />
</head>
<body>
<div id="container">
<div class="ribbon_bubble">
    <div class="ribbon_rectangle">
<h1>All SFO functions</h1>
</div>
    <div class="ribbon_triangle-l"></div>
    <div class="ribbon_triangle-r"></div>

<div class="section">

</div>

<div class="ribbon_rectangle_h2"><h2>Description</h2> </div>
    <div class="ribbon_triangle_h2-l"></div>
    <div class="ribbon_triangle_h2-r"></div>

<div class="section">

</div>

<div class="ribbon_rectangle_h2"><h2>Functions</h2> </div>
    <div class="ribbon_triangle_h2-l"></div>
    <div class="ribbon_triangle_h2-r"></div>

<div class="section">
<p><strong>2da_clone_column(silent:b, array:a, clone_to:s, location:s, clone_from:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, a column label 'clone_from', and a new column label 'clone_to', insert a copy of the clone_from
column with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).
</p>
<p><strong>2da_clone_row(silent:b, array:a, clone_to:s, location:s, clone_from:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, a row label 'clone_from', and a new row label 'clone_to', insert a copy of the clone_from
row with the clone_to label, in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).
</p>
<p><strong>2da_column_to_array(silent:b, column:s, array:a)=(array_out:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array and column label 'column', extract that column as a 1d array indexed by the 
row labels. </p><p>If we can't find the column label, we return an empty array (and whine about it unless silent=1).
</p>
<p><strong>2da_delete_column(array:a, column:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>Given a 2d array, and column label 'column', delete that column.
</p>
<p><strong>2da_delete_row(array:a, row:s, lookup_column:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>Given a 2d array, and row label 'row', delete that row.
</p>
<p><strong>2da_extract_array(silent:b, domain:s, range:s, array:a, keymap:f, map:f, case:[upper|lower|mixed])=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>Given a 2d array, and column labels 'domain' and 'range' for that array, return a 1d
array whose keys are the elements of the 'domain' column and whose values are the elements
of the 'range' column.</p><p>If you leave either 'domain' or 'range' empty, the row headers are used instead. If we can't
find domain or range, we return an empty array (and whine unless silent=1).</p><p>Optionally, you can specify functions 'keymap' and/or 'map', which are applied to the keys
and values respectively before being put into the output array. You can use the anonymous
function construct.
</p>
<p><strong>2da_find_default()=(value:s)</strong> patch (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
In the current file, return the default 2da entry, or "NOT_2DA" if the file is not a 2da file.</p><p>
</p>
<p><strong>2da_fix(apply_to_file:b=1)=(legal:s, fixed_file:s)</strong> patch (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Turns the current file (assumed to be a 2da file) into a legal 2da file with no incomplete entries, by
<ol>
<li>forcing the first line to be '2DA V1.0'</li>
<li>removing any entry beyond the first on the second line</li>
<li>truncating any entries that lie beyond the range defined by the columns on the third line</li>
<li>filling in any incomplete entries with the array's default character.</li>
</ol>
Returns 'legal', which is 1 or 0, and 'fixed_file', which is just a 
string containing the full contents of the file. Optional argument: 'apply_to_file' 
(can be 1 or 0, default is 1); if set to 1, the changes are actually carried out on the file being patched; if set to 0, they're discarded</p><p></p>
<p><strong>2da_inject_array(silent:b, force_uppercase:b=1, array:a, array_in:a, column:s, row:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, a column header of that array, and a k=>v array whose keys are row headers in the 2d array, 
inject the array elements into the 2d array, as (k=>v) goes to (k,col,v).</p><p>If force_uppercase=1 (default), array_in's keys are uppercased.
</p>
<p><strong>2da_insert_column(silent:b, array:a, column:s, location:s, entry:s="-1")=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, and a column label, insert a new column with that column label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before column_label' or 'after column_label'.
If we can't find the column label, we default to 'last' (and whine about it unless silent=1).</p><p>The new rows are filled with 'entry'.
</p>
<p><strong>2da_insert_row(silent:b, array:a, row:s, location:s, entry:s="-1")=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, and a row label, insert a new row with that row label in the position specified by
'location'. 'location' can be 'first' (or 'start'), 'last' (or 'end'), 'before row_label' or 'after row_label'.
If we can't find the row label, we default to 'last' (and whine about it unless silent=1).</p><p>The new rows are filled with 'entry'.
</p>
<p><strong>2da_make(rows:a, columns:a, fill:s="*")=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given two arrays in k=>_ format, make a 2da with each character filled with some fixed data
</p>
<p><strong>2da_prettier_print()=()</strong> patch (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Like PRETTY_PRINT_2DA, but checks the file has >2 rows and doesn't treat "2DA V1.0" as two columns</p><p>
</p>
<p><strong>2da_process_table(inline:i, 2da:i, table:s, path:s, location:s, locbase:s, function:s)=()</strong> action (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
'table' should be a header table whose headers are the arguments of the action function 'function'.
(INT_VAR arguments should be indicated with ':i'.) Each row of the table is fed to the function.</p><p>Alternately, if INT_VAR 2da is set to 1, 'table' can be a 2da. It is treated the same way, except
that each row name is fed to the function as the STR_VAR 'rowname'</p><p></p>
<p><strong>2da_read(silent:b, reflect:b, remove_comments:b=1, type:[2da|ids|table_header|table_no_header], rowmap:f, colmap:f, rowname_column:s, case:[upper|lower|mixed])=(default:s, columns:a, rows:a, array:a)</strong> patch (<a href="lib_2da.html">lib_2da</a>)<br><strong>2da_read(silent:b, inline:b, reflect:b, file:s, case:[upper|lower|mixed], path:s, type:s, location:s, locbase:s, rowmap:f, colmap:f, rowname_column:s)=(value:s, columns:a, rows:a, array:a)</strong> action (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Read a 2da file (or, in patch context, the current 2da file) into a 2d array. Also return an array of uppercased row headers and
column headers, in the format row_label=>row_number. ('case' controls the case of the
row and column headers; it's uppercase by default on genuine 2das, mixed by default otherwise).
The default value is also returned, as 'default'. (On non-2da files, * is returned)</p><p>If you don't specify a path for the 2da file, it's assumed to be a game file.</p><p>In action context, if the file doesn't exist return 0; otherwise, return 1. Also
whine if it doesn't exist, unless silent=1.</p><p>If the file is a 2da, and 'reflect' is set, reverse rows and columns.  If it's a 2da, and "rowname_column" is set, use that column
(if it's present) for the row names instead of the usual entries. In the latter case, we add a new 'ROWNUMBER' column
containing column zero. (This is not compatible with 'reflect'.)s</p><p>If 'rowmap' and/or 'colmap' are set, they get applied to the row and column entries before the array is constructed.</p><p>If the file contains WEIDU-style // comments, they are removed. (You can override this by setting remove_comments to 0.)
</p>
<p><strong>2da_renumber(start_at:i, array:a)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array, replace its row labels with sequential integers starting at 'start_at' (i.e. 0 by default)
</p>
<p><strong>2da_row_to_array(silent:b, row:s, array:a)=(array_out:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array and row label 'row', extract that row as a 1d array indexed by the 
column labels. </p><p>If we can't find the row label, we return an empty array (and whine about it unless silent=1).
</p>
<p><strong>2da_sort(rows:s, columns:s, array:s)=(array:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Takes a 2da, sorts rows and/or columns.
Set "rows" and/or "columns" to "lexicographically" or "numerically" (case-insensitive), or else feed it a function to use in array_sort. Can use 'l' or 'n' as synonyms</p><p></p>
<p><strong>2da_to_3da(column1:s, column2:s, array:a)=(array_out:a)</strong> dimorphic (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Given a 2d array and two column headers, extract a 3d array where the first two keys are the
values in the new columns and the third is the old column header.</p><p>e.g. if row 14 has col1=x, col2=y, then 3da(x,y,z)=2da(14,z).
</p>
<p><strong>2da_to_ini(2da:s, ini:s, path:s, location:s, locbase:s, ini_path:s, default:s="*", ignores:s, section_key:s)=()</strong> action (<a href="lib_2da.html">lib_2da</a>)<br></p>
<p><strong>2da_write(reflect:b, number_rows:b, array:a, type:[2da|ids|table_header|table_noheader], default:s, case:[m="mixed"ixed|upper|lower])=()</strong> patch (<a href="lib_2da.html">lib_2da</a>)<br><strong>2da_write(number_rows:b, reflect:b, file:s, path:s, location:s, locbase:s, type:[2da|ids|table_header|table_noheader], array:a, default:s="*")=()</strong> action (<a href="lib_2da.html">lib_2da</a>)<br></p><p>
Write a 2d array into a 2da file (or, in patch context, the current 2da file). </p><p>If you don't specify a path for the 2da file, it's assumed to be a game file.</p><p>If 'number_rows' is set to 1, the row names are replaced by integers, counting upwards from 0.
If 'reflect' is set to 1, rows and columns are swapped.</p><p>If you don't specify the default element, we try to read it from the current file
</p>
<p><strong>2daq_copy_column(data_read:b, column:s, column_new:s="%column%")=(value:s)</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Copies a column in the current 2da file to the right-hand side of the table, with new column name 'column_new'. Returns 1 if copy is successful. Stoically silent if it isn't.</p><p></p>
<p><strong>2daq_copy_row(rowname_column:i, data_read:b, row:s, row_new:s="%row%")=(value:s)</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Copies a row in the current 2da file to the bottom of the table, with new row name 'row_new'. Returns 1 if copy is successful. Stoically silent if it isn't.</p><p>If 'rowname_column' is set, the row id is looked up in that column, and column 0 is assumed to be numbered sequentially.
(This is the convention for kitlist.2da.)</p><p></p>
<p><strong>2daq_extract(rowname_column:i, data_read:i, row:s, column:s, case:[m=mixedixed|upper|lower])=(value:s, rownum:s, array:a)</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br><strong>2daq_extract(rowname_column:i, data_read:b, resref:s, row:s, column:s, case:s)=(value:s, array:a)</strong> action (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Given a column header and/or a row header, and a 2da file resref, (or, in patch context, the current 2da file), extract the column or row as k=>v array using the row or column headers, as appropriate, as keys.</p><p>If both row and column are set, instead return the element (if any) at (row,column) as 'value', as well as its row as 'rownum'.
</p>
<p><strong>2daq_has_column(data_read:b, column:s)=(value:s)</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Return 1 iff the current 2da file has 'column' as a column id. 
</p>
<p><strong>2daq_has_row(rowname_column:i, data_read:b, row:s)=(value:s)</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Return 1 iff the current 2da file has 'row' as a row id. (Check rowname_column).
</p>
<p><strong>2daq_inject(reflect:b, rowname_column:i, data_read:b, array:a)=()</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br><strong>2daq_inject(reflect:b, rowname_column:i, data_read:b, array:a, resref:s)=()</strong> action (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Given a 2D struct 'array' and a 2da file resref, (or, in patch context, the current 2da file) insert the elements of the struct into the 2da. (i.e. if the struct contains "array_x_y" and x and y are row and column entries in the 2da, insert the value of array_x_y at (x,y).</p><p>If reflect=1, swap rows and columns. If rowname_column is nonzero, look up the row names in that column.
</p>
<p><strong>2daq_insert_column(column:s, insert_loc:[l="last"ast|before_last])=()</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Adds a new column, with header 'column', as the last column, or the second-to-last column if insert_loc is 'before_last'. All entries are filled with the 2da default value. </p>
<p><strong>2daq_insert_row(rowname_column:i, row:s)=()</strong> patch (<a href="lib_2daq.html">lib_2daq</a>)<br></p><p>
Adds a new row, with header 'row', as the last row. All entries are filled with the 2da default value. If rowname_column>0, we put the header in this column, and assume column 0 should be numbered sequentially from 0.
</p>
<p><strong>3p_kit()=()</strong> action (<a href="lib_3p.html">lib_3p</a>)<br></p><p>
Goes through the array 'sfo_3p_kit', and for each cre=>kit assigns the kit 'kit' (from kit.ids), if it exists, to the cre file 'cre'.cre</p><p>The kit is not enforced but can be picked up by other mods (e.g. SCS) and will apply normally to joinables.
</p>
<p><strong>3p_kit_bonus_spells()=()</strong> action (<a href="lib_3p.html">lib_3p</a>)<br></p><p>
Goes through the array 'sfo_3p_kit_spheres', and for each kit=>spheres assigns those spheres to the kit. 
Input can be either,
(i) a comma-separated list of spheres 
(ii) a comma-separated list of spheres prepended by + or -.</p><p>In case (ii), the list is applied as modifiers to the class default.
</p>
<p><strong>3p_kit_sphere()=()</strong> action (<a href="lib_3p.html">lib_3p</a>)<br></p><p>
Goes through the array 'sfo_3p_kit', and for each (kit,'spheres')=>spheres assigns those spheres to the kit. 
Input can be either,
(i) a comma-separated list of spheres 
(ii) a comma-separated list of spheres prepended by + or -.</p><p>In case (ii), the list is applied as modifiers to the class default.
</p>
<p><strong>3p_load_data</strong> action_macro (<a href="lib_3p.html">lib_3p</a>)<br></p><p>
Loads all the inis in the folders 'MOD_FOLDER/sfo_3p_folder_internal' (by default 'MOD_FOLDER/3p') and 'weidu_external/data/dw_shared/sfo_3p_folder' (by default weidu_external/data/dw_shared/MOD_FOLDER3p), with the latter overriding the former.
Returns them as a series of arrays, labelled by ini sections - so all the entries in [sphere], across all the
inis, get returned in $sfo_3p_sphere. If the key has the form firstbit:secondbit, instead we return a 2D array
using secondbit as a key: so entries in [kit:dw_cleric_mask] would get returned as values of $sfo_3p_kit("dw_cleric_mask" [whatever])
</p>
<p><strong>add_basic_spell_ability()=()</strong> patch (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Add a standard (innate) ability to the currently-being-patched spell, assumed to be a blank
freshly-created v1 spell from WEIDU's CREATE command. (For lightweight spell-creation.)
</p>
<p><strong>add_chargen_bio_onopen()=()</strong> patch (<a href="ui_on_open.html">ui_on_open</a>)<br></p>
<p><strong>add_dual_class_kit_option(kit:s, oldclass:s, oldkit:s, newclass:s)=()</strong> action (<a href="ui_dual_class_kits.html">ui_dual_class_kits</a>)<br></p><p>
Enable dual-classing from kit 'oldkit' of old class 'oldclass', into kit 'kit' of class 'newclass'. Class entries should be IDS entries like 'FIGHTER'. Kit entries should 
be kitlist.2da rownames.
</p>
<p><strong>add_dwHideAbility()=()</strong> patch (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>add_elem_spell_desc(elem_string:s, spell:s)=()</strong> action (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>add_generic_onopen()=()</strong> patch (<a href="ui_on_open.html">ui_on_open</a>)<br></p>
<p><strong>add_ini_func()=()</strong> patch (<a href="ui_set_ini_globals.html">ui_set_ini_globals</a>)<br></p>
<p><strong>add_kit_menu(name:i, desc:i, title:i, trueclass_desc:i, name_strref:i, desc_strref:i, title_strref:i, trueclass_desc_strref:i, id:s, kits:s, class:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This creates a kit-selection menu for a given class. All kits in the space-separated list 'kits' (identified by kitlist.2da rownames) for the class 'class' (identified by a class.ids entry) are grouped into their own menu. 'id' is some unique identifier for this menu (use a modder prefix).</p>
<p> 'name', 'desc' and 'title' should be the numbers of entries in the currently-loaded tra file. 'name' is the name of the menu itself (displayed in place of a kit name on the parent class's kit menu). 'title' is the name for the submenu (replacing 'Choose Kit'). 'desc' is the description
displayed when you click or mouse over the submenu on the main kit-selection screen.</p></p><p><p>For instance, if you want to gather several dragon disciple kits together, 'name' might be 'Dragon Disciple', 'desc' might be the general description for Dragon Disciples, and 'title' might be 'Choose Dragon' or similar.
</p>
<p><strong>add_pseudorace(NAME:s="-1", DESC:s="-1", REAL_RACE:s="-1")=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Add a single race to SFO's master table of pseudoraces. (This only updates the <b>tables</b>; the game itself is not updated.)
</p>
<p><strong>add_race(race:s, NAME:s, DESCSTR:s, UPPERCASE:s, BIOGRAPHY:s)=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Add a single race to SFO's master table of races. (This only updates the <b>tables</b>; the game itself is not updated.)
</p>
<p><strong>add_silent_sectype(sectype:s, arguments:s)=(sectype_value:s, value:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Add a sectype with no associated string. The sectype to be added is specified by the STR_VAR 'sectype'
(synonym: 'arguments') and its numerical value is returned as 'sectype_value' (synonym: 'value').</p><p>OBSOLETE: use resolve_sectype instead
</p>
<p><strong>ADD_SPELL_EFFECT(opcode:i, target:i, timing:i, parameter1:i, parameter2:i, parameter2a:i, parameter2b:i, power:i, resist_dispel:i, duration:i, probability1:i=100, probability2:i, dicenumber:i, dicesize:i, savingthrow:i, savebonus:i, header:i, insert_point:i="-1", special:i, ___#special:i=special, save_vs_spell:i="-1", save_vs_breath:i="-1", save_vs_poison:i="-1", save_vs_wand:i="-1", save_vs_polymorph:i="-1", ignore_primary:i="-1", ignore_secondary:i="-1", bypass_mirror_image:i="-1", ignore_difficulty:i="-1", drain_hp_to_caster:i="-1", transfer_hp_to_target:i="-1", fist_damage_only:i="-1", drain_to_max_hp:i="-1", suppress_feedback:i="-1", save_for_half:i="-1", made_save:i="-1", does_not_wake:i="-1", resource:s)=()</strong> patch (<a href="alter_effect.html">alter_effect</a>)<br></p>
<p><strong>add_subrace(COLOR_SKIN:i="-1", COLOR_HAIR:i="-1", COLOR_MAJOR:i="-1", COLOR_MINOR:i="-1", STR:i, DEX:i, CON:i, INT:i, WIS:i, CHA:i, EXTRA_PROF:i, PP:i, OL:i, FT:i, MS:i, HS:i, DI:i, ST:i, subrace:s, NAME:s, DESC:s, PARENT:s, FINAL_RACE:s="*", ICON:s="-1", ICON_STRREF:s="-1", BIO_OLD:s="-1", BIO_NEW:s="-1", SPL_INIT:s, SPL_RECUR:s)=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Add a single subrace to SFO's master table of subraces. (This only updates the <b>tables</b>; the game itself is not updated.)
</p>
<p><strong>add_to_clab_level_1(clab:s, spell:s)=()</strong> dimorphic (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p><p>
Lightweight adder that just adds the spell to a CLAB file
</p>
<p><strong>add_to_lua_lang(array:a)=()</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given a k=>v array 'array' with entries like MY_TEXT_STRING=>1234, go through each 
entry, and for each, get the string with tra ref 1234 in the current tra file and
set TEXT_STRING equal to it in the current EE language file (e.g., en_us.lua).</p></p><p><p>Exits with a warning if not on EE.</p><p></p>
<p><strong>add_to_subrace_tables(subrace_table:s, race_table:s, pseudorace_table:s, disabled:s, table_path:s)=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Take a bunch of tables defining race, subrace and pseudorace and add them to SFO's master tables. 
(This only updates the <b>tables</b>; the game itself is not updated.)
</p>
<p><strong>add_virtual_class(multiclass:b, name:i, desc:i, name_strref:i, desc_strref:i, ident:s, parent:s, human:s, dwarf:s, elf:s, gnome:s, halfling:s, half_elf:s, halforc:s, all_races:s="true")=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p></p><p>This adds a new virtual class to the class-selection menu (to the single-class bit unless multiclass is set to 1). You need to specify a unique string 'ident' to identify the class, and a real class ('parent', an entry in class.ids) as its parent.</p></p><p><p>You also need a name and description, specifiable either as a tra ref ('name', 'desc') or directly as a strref ('name_strref', 'desc_strref').</p></p><p><p>By default, the class will be available to all races. To restrict it, set 'all_races' to 'false' and then set each of 'human', 'dwarf' etc to 'true' if you want it available.
</p>
<p><strong>adjust_multischool_spells()=()</strong> action (<a href="ui_spell_system_schools.html">ui_spell_system_schools</a>)<br></p>
<p><strong>adjust_priest_casting_description(class:s)=()</strong> action (<a href="ui_spell_system_spheres.html">ui_spell_system_spheres</a>)<br></p>
<p><strong>adjust_this_multischool_spell(old_desc:i, new_desc:i, ids:s)=()</strong> action (<a href="ui_spell_system_schools.html">ui_spell_system_schools</a>)<br></p>
<p><strong>all_to_utf8(permanent:b, tra_path:s="MOD_FOLDER/lang")=()</strong> action (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given the (full) path to your tra files (default: MOD_FOLDER/lang), convert
all the files in all languages to (lowercased) UTF-8, leaving no detritus (no
fl#utf files). If permanent=1, will persist through uninstall.
</p>
<p><strong>ALTER_EFFECT(check_globals:i=1, check_headers:i=1, header:i="-1", header_type:i="-1", multi_match:i=999, verbose:i, silent:i, match_opcode:i="-1", match_target:i="-1", match_power:i="-1", match_parameter1:i="-1", match_parameter2:i="-1", match_timing:i="-1", match_resist_dispel:i="-1", match_duration:i="-1", match_duration_high:i="-1", match_probability1:i="-1", match_probability2:i="-1", match_dicenumber:i="-1", match_dicesize:i="-1", match_savingthrow:i="-1", match_savebonus:i="-11", match_special:i="-1", match_save_vs_spell:i="-1", match_save_vs_breath:i="-1", match_save_vs_poison:i="-1", match_save_vs_wand:i="-1", match_save_vs_polymorph:i="-1", match_ignore_primary:i="-1", match_ignore_secondary:i="-1", match_bypass_mirror_image:i="-1", match_ignore_difficulty:i="-1", match_drain_hp_to_caster:i="-1", match_transfer_hp_to_target:i="-1", match_fist_damage_only:i="-1", match_drain_to_max_hp:i="-1", match_suppress_feedback:i="-1", match_save_for_half:i="-1", match_made_save:i="-1", match_does_not_wake:i="-1", opcode:i="-1", target:i="-1", power:i="-1", parameter1:i="-11", parameter2:i="-11", timing:i="-1", resist_dispel:i="-1", duration:i="-1", duration_high:i="-1", probability1:i="-1", probability2:i="-1", dicenumber:i="-1", dicesize:i="-1", savingthrow:i="-1", savebonus:i="-11", special:i="-1", save_vs_spell:i="-1", save_vs_breath:i="-1", save_vs_poison:i="-1", save_vs_wand:i="-1", save_vs_polymorph:i="-1", ignore_primary:i="-1", ignore_secondary:i="-1", bypass_mirror_image:i="-1", ignore_difficulty:i="-1", drain_hp_to_caster:i="-1", transfer_hp_to_target:i="-1", fist_damage_only:i="-1", drain_to_max_hp:i="-1", suppress_feedback:i="-1", save_for_half:i="-1", made_save:i="-1", does_not_wake:i="-1", match_resource:s="SAME", resource:s="SAME", match_function:s, function:s)=()</strong> patch (<a href="alter_effect.html">alter_effect</a>)<br></p>
<p><strong>ALTER_SCRIPT_BLOCK(only_once:b, recompile:b=1, script:s, patch:f, function:f, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, swap_out:s, swap_out1:s, swap_out2:s, swap_out3:s, swap_out4:s, swap_out5:s, swap_in:s, swap_in1:s, swap_in2:s, swap_in3:s, swap_in4:s, swap_in5:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p>
<p><strong>analyse_elemental_type(earth:i, air:i, water:i, fire:i)=(earth:s, air:s, fire:s, water:s)</strong> patch (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>analyse_elemental_type_core(opcode:i, resource_offset:i, earth:i, air:i, water:i, fire:i)=(earth:s, air:s, fire:s, water:s)</strong> patch (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>anim_collect(no_log_record:b, animation:s, resource_loc:s, ini_file:s, path:s, location:s, locbase:s, resref_original:s)=()</strong> action (<a href="lib_anim.html">lib_anim</a>)<br></p><p>
Collects the resources used by an animation (i.e. the bam and wav files), according
to its EE ini file. Files are saved in 'resource_loc'/'animation'. </p><p>The animation is specified by an EE-format animate.ids entry. (We check a stashed copy 
of animate.ids in %sfo_library_file%/resource).</p><p>You can supply a local copy of the ini file, using path/location/locbase. If ini_file is
not set, we assume the one inferred from animate.ids.</p><p>You can override the ini-specified resref with 'resref_original'.</p><p>If no_log_record=1, the resources are copied over irreversibly and will not be undone if you uninstall.
</p>
<p><strong>anim_install(overwrite:i, resource_loc:s, animation:s)=()</strong> action (<a href="lib_anim.html">lib_anim</a>)<br></p><p>
Given an animation packaged by anim_collect, install it. If overwrite=1, overwrite existing files; otherwise, don't.
</p>
<p><strong>anon_check(has_output:i, function:s, input:s=arguments, output:s=value, prepend:s, append:s)=(function:s, SFO_anon_func_count:s)</strong> dimorphic (<a href="lib_anon.html">lib_anon</a>)<br></p><p>
Check if 'function' is an anonymous function definition, and if so create it and return its name; if not, return 'function' itself.</p><p>A string is an anonymous function definition if it contains any of these: [ <>/=+*{}].  (If you somehow manage to define an anonymous function that doesn't
use any of these, just add a space at the beginning.)</p><p></p>
<p><strong>anon_define(has_output:b, action_function:b, return_array:b, function:s, input:s=arguments, output:s=value, prepend:s, append:s)=(function:s, SFO_anon_func_count:s)</strong> dimorphic (<a href="lib_anon.html">lib_anon</a>)<br></p><p>Define the string 'function' as an anonymous patch function (setting its single STR_VAR input to 'input' and its single output to 'output'), and return the name of the function and an integer keeping track of how many anonymous functions have been defined.</p><p>The point of the integer is to avoid namespace collisions. By leaving it in scope for other calls of anon_define, we guarantee distinct functions.</p><p>We allow the following syntactic sugar for anon_define:</p><p>- '__' evaluates to '%input%'
- 'SFO_args' evaluates to 'input'
- '{' and '</p>
<p><strong>anon_eval(has_output:i, arguments:s, function:s, append:s, prepend:s)=(value:s)</strong> action (<a href="lib_anon.html">lib_anon</a>)<br><strong>anon_eval(has_output:i, arguments:s, function:s, append:s, prepend:s)=(value:s)</strong> patch (<a href="lib_anon.html">lib_anon</a>)<br></p><p>
Evaluate 'function' as an anonymous patch function, apply it to 'arguments', and return the result.
NB: anon_eval is not dimorphic. The action version runs on a blank patch. The patch version runs on whatever is
currently being patched.
</p>
<p><strong>append(arguments:s)=()</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br><strong>append(no_log:i, arguments:s, file:s, location:s, locbase:s, path:s)=()</strong> action (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
Append the string 'arguments' at the end of the file 'file' at locations given by location/locbase/path (only use 'path' if you want to run self-contained), or, in patch context, at the end of the current file, with no spacing or line breaks
</p>
<p><strong>are_copy(allow_missing:i, debug:i=1, are:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_are.html">lib_are</a>)<br></p>
<p><strong>are_edit(allow_missing:i, debug:i=1, edit_strrefs_in_place:i, are:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_are.html">lib_are</a>)<br></p>
<p><strong>are_make(debug:i=1, are:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_are.html">lib_are</a>)<br></p>
<p><strong>array_2d_to_list(sort:b=1, array:a, separator:s=" ", require_value:s)=(list:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a 2d array (k1,k2)->v. Return a 1d array with the k1 as keys and a list of the k2 as values. Optionally, require that v=require_value. 
If sort=1, sort entries lexicographically.
</p>
<p><strong>array_contains(array:a, key:s, val:s)=(value:s)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Depending on which of 'key' and 'val' are set, return true if (i) array 'array' contains 'key' as a key; (ii) array 'array' contains 
'val' as a value; (iii) array 'array' contains the pair 'key'=>'val', or I suppose (iv) array 'array' is non-empty.</p></p><p><p>This is intentionally case-sensitive (since a common use-case is going to be pulling an array element out by its key if it's in
the array).</p>
<p><strong>array_copy(array:s)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Copy an array.</p>
<p><strong>array_echo(single_line:i, array:a)=()</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Print an array to the screen (good for debugging). If single_line=1, returns a single string with comma-separated entries;
otherwise returns one k=>v per line.</p>
<p><strong>array_fill(array:a, fill:s="*")=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Given an array of keys, set each to the value 'fill'.</p>
<p><strong>array_from_string(string:s)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a string of k=>v pairs separated by spaces. Read them into an array. </p>
<p><strong>array_invert(array:a)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Input an array of k->v; output an array of v->k.</p>
<p><strong>array_join(array1:a, array2:a)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take two arrays and combine them, so that key k is in the new array iff it is in one or other of the old arrays. If there's a clash
of key allocations, array2 gets priority.
</p>
<p><strong>array_keys(array:a)=(keys1:a, keys2:a, keys3:a, keys4:a, keys5:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Given an array, return arrays k=>_ of the first five levels of its keys.</p>
<p><strong>array_keys_from_string(separator:s=" ", string:s)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a string of strings separated by 'separator' (a character). Read them in as the keys of an array. (Values are blank.)</p>
<p><strong>array_length(array:a)=(value:s, length:s)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Returns the number of elements in the array. ('value' and 'length' are synonyms.)</p>
<p><strong>array_log(new:b, permanent:b, path:s="weidu_external/data/MOD_FOLDER", file:s, array:s)=()</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Output an array as a 2-column table. If 'new' is set, overwrite any existing file by the same name; if not, append. If 'permanent' is
set, the table will persist even if the component is uninstalled. (This automatically sets 'new'.)</p>
<p><strong>array_map(array:a, map:f, keymap:f)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a k->v array is input; return keymap(k)->map(v). (Either function can be absent, in which case it's treated as the identity.) 
You can use the anonymous function construct.</p>
<p><strong>array_read(firstrow:i, backwards:b, case:[u=mixedpper|lower|mixed])=(array:a)</strong> patch (<a href="lib_array.html">lib_array</a>)<br><strong>array_read(firstrow:i, silent:i, backwards:b, inline:b, file:s, path:s, location:s, locbase:s, case:[u=mixedpper|lower|mixed])=(value:s, array:a)</strong> action (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a file (or, for the patch version, the current file), which should be a table, (not necessarily a 2da) and read in the first two
columns into a k->v array. (If there's only one column, read it into a k->_ array.)</p><p>Start at row firstrow.</p><p>In action context, return value=1 if the file exists, value=0 if it doesn't, and whine if it doesn't unless silent=1.</p><p>If backwards=1, swap the order of key and value.
</p>
<p><strong>array_sort(depth:i=1, array:s, function:s)=(array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>
Given a patch function (of argument->value type) with domain the keys of an array, sort that array alphabetically
by the values of the function. The function doesn't have to be 1:1. You can use the anonymous function construct.
</p>
<p><strong>array_split(array:a, match_key:f, match_value:f)=(split:a, rest:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>Take a k->v array as input, along with functions 'match_key' and/or 'match_value'; return an array 'split' of all elements with keys that match 'kmatch'
and values that match 'vmatch', and an array 'match' of all that don't. You can use the anonymous function construct.
</p>
<p><strong>array_values_from_string(quick:i, string:s, separator:s=" ")=(array_length:s, array:a)</strong> dimorphic (<a href="lib_array.html">lib_array</a>)<br></p><p>
Given a string of strings separated by 'separator' (a character), return an [int]=>v array of those strings, labelled by sequential integers. If 'quick' is set, 
assume no entries are quoted. 'quick' only works for a ' ' or tab separator. 
</p>
<p><strong>assign_bonus_spells(update_description:b=1, skip_clab:b, class:s, kit:s, spells:s, spell_array:s, tra:s="sfo_lua", tra_path:s="DEFAULT")=()</strong> action (<a href="ui_bonus_spells.html">ui_bonus_spells</a>)<br></p><p>
Given kit 'kit, and a space-separated list of spells 'spells' and/or a k=>_ array of spells 'spell_array', grant those spells as bonus
learned spells at the appropriate level, making appropriate LUA and CLAB changes to do so.</p></p><p><p>Spells can be given as bare resrefs, or as spell.ids entries, or as dw_ext_spell.ids entries, or as abbreviated entries (i.e., with the 'WIZARD_' or 'CLERIC_' 
preamble stripped (if ambiguous, we assume WIZARD). Spells of the wrong type (i.e. cleric spells for wizards, or vice versa) are autoconverted to the appropriate type using the lib_splconv
library.</p></p><p><p>Multiclass kits can be handled, but only if they're in SFO format and only on a full sfo install (we use lib_kit functionality). The parent class can normally be inferred; if
you are adding bonus spells to a cleric/mage, you need to specify 'class' explicitly as cleric or mage.</p></p><p><p>The function will attempt to update the kit description (you can tell it not to by setting update_description=0). It needs to be given a tra file and a tra path; the defaults
point to lua/lang and to sfo-lua's default tra file. (Look at that file for format if you want to do your own.) The same tra file is also passed to the splconv function to make
any cleric->wizard and wizard->cleric conversion descriptions.</p><p>If you set skip_clab to 1, the new spells are added to the LUA and the kit description, but not to the CLAB. (This is useful if you're cloning an existing kit.)
</p>
<p><strong>assign_kit_to_virtual_class(kit:s, class:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
The kit 'kit' (a rowname from kitlist.2da) is added to the virtual class 'class' (the unique ID for the class, specified in add_virtual_class). The kit needs to be a legal kit for the parent class of the virtual class, and will now be displayed in the virtual class's kit menu rather than the real class's menu.
</p>
<p><strong>assign_spheres(update_scroll_usability:i=1, update_scrolls_later:i=1, update_description:i=1, class:s, kit:s, kit_clastext:s, spheres:s, default:s, add:s, subtract:s, block:s, base_tra:s=sfo_lua, base_tra_path:s="DEFAULT")=()</strong> action (<a href="ui_spell_system_spheres.html">ui_spell_system_spheres</a>)<br></p>
<p><strong>bam_install_v2(lowest_mos_index:i, bam_name:s, path:s, location:s, locbase:s, pvrz_path:s="MOD_FOLDER/sfo", pvrz_location:s="%location%", pvrz_locbase:s="%locbase%")=()</strong> action (<a href="lib_bam.html">lib_bam</a>)<br></p><p>Installer for v2 BAMs. Feed it the lowest mos index you want to try, the name and location of the bam file to be installed (given by path/location/locbase),
and the location of all the pvrz files associated with the bam (given by pvrz_path,pvrz_location,pvrz_locbase, but defaulting to the bam version in each case)</p>
<p><strong>bam_legal_byte(input:i)=(output:s)</strong> patch (<a href="lib_bam.html">lib_bam</a>)<br></p>
<p><strong>bam_patch_colors(suppress_warning:b, condition:f, action:f, bam:s)=()</strong> action (<a href="lib_bam.html">lib_bam</a>)<br><strong>bam_patch_colors(condition:f, action:f)=()</strong> patch (<a href="lib_bam.html">lib_bam</a>)<br></p>
<p><strong>baseline_lua()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>bg2_hla_menu()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>bg2_hla_menu_edit()=()</strong> patch (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>bg_hla_menu()=()</strong> action (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>blank_luas()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>bonus_spells_from_list(skip_clab:b, update_description:i=1, kit:s, path:s, class:s)=()</strong> action (<a href="ui_bonus_spells.html">ui_bonus_spells</a>)<br></p><p>
Loads the file in 'path' (which should be a 2-column table - the first column is conventionally a level, but need not be).
Go through the entries in the second column. Each is a |-separated list of spell ids entries (possibly including extended-namespace
ids). Assign the first entry in each column that actually exists as an installed spell as a bonus spell to the kit 'kit'. </p><p></p>
<p><strong>build_favored_enemy_applicator_spells()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>build_favored_enemy_menu()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>build_subraces(tlk_signal_start:i=900000, delay_mode:b)=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Operate on the subrace tables to actually construct the subraces
if delay_mode=1, introduce a 1-second delay into the spells (for experimental HoW compatibility, though we haven't got this stable yet).
</p>
<p><strong>charset_wrapper(from_utf8:b=1, set, to, 0, if, your, tra, files, aren't, in, UTF8, overwrite:b, set, to, 1, if, you, want, to, regenerate, the, converted, files, every, run, verbose:b, set, to, 1, to, get, more, feedback, from, HANDLE_CHARSETS, silent:b, set, to, 1, if, you, don't, want, to, be, warned, when, tra, files, from, a, folder, in, the, extra_tra_folders, list, overlap, with, the, main, list, tra_path:s, set, to, where, your, tra, files, are, (with, or, without, 'MOD_FOLDER', iconv_path:s, set, to, wherever, your, iconv.exe, file, is, (with, or, without, 'MOD_FOLDER'), setup_tra:s="setup", set, to, whatever, you're, keeping, your, WEIDU, installation, strings, in, load:s, set, to, a, space-separated, list, of, any, tra, files, you, want, loaded, default_language:s="english", set, to, whatever, language, you, wrote, the, mod, in, extra_tra_folders:s, set, to, a, space-separated, list, of, any, additional, folders, (relative, to, MOD_FOLDER), containing, TRA, files)=(out_path:s)</strong> action (<a href="charset_wrapper.html">charset_wrapper</a>)<br></p><p>
Wrapper for HANDLE_CHARSETS. Copies files over to weidu_external/lang/MOD_FOLDER, whether or not conversion is required. Makes sure all tra are present by using 
default-language ones if preferred-language ones aren't available.</p>
<p>Set from_utf8=0 if tra files are in non-EE format. Set overwrite=1 to have all files copied every time it's run (instead of only the first time) Set verbose=1 to
get more feedback from HANDLE_CHARSETS. Set tra_path to the location of your tra files if it's not 'lang' or 'tra'. Set setup_tra to the tra file you keep component names
in, if it's not setup.tra. Set load to a space-separated list of tra files you want always to load (the .tra is optional). Set 'default_language' to the language the 
mod is written in, if it's not English.</p>
<p>The returned variable out_path is where the language files are copied to (hardcoded to weidu_external/lang/MOD_FOLDER).</p>
<p>Because I want to share this, it needs to have no dependencies and to run without AUTO_EVAL_STRINGS.
</p>
<p><strong>check_ini(silent:i, ini:s, arguments:s, section:s)=(value:s)</strong> dimorphic (<a href="lib_ini.html">lib_ini</a>)<br></p><p>
Legacy name for ini_check.
</p>
<p><strong>check_label(label:s, prefix:s)=(value:s)</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Check for a marker file, which can be set by make_label.</p></p><p><p>Do not use make_label or check_label in your base tp2 to decide whether to install a component, as they are invisible to Project Infinity and the like.
</p>
<p><strong>class_edit(edit_strrefs_in_place:i, class:s, edits:s, struct:s=k)=()</strong> action (<a href="lib_class.html">lib_class</a>)<br></p><p>
Edit the class 'class' (or the list of classes 'class'). 'edits' is executed as an anonymous function, which first reads the class into struct 'struct' (default 'k') and then writes that struct back. ('k' so that the same patch can be used for kits and classes.)</p></p><p><p>If 'edit_strrefs_in_place' is set to 1, any strrefs have their values updated, rather than being
replaced with new strrefs (use this with caution).</p></p><p><p>(Arguably this is just an internal function: you can put unkitted classes into kit_edit and it just calls class_edit.)
</p>
<p><strong>class_read(class:s)=(struct:a)</strong> dimorphic (<a href="lib_class.html">lib_class</a>)<br></p><p>
Read a class into a struct. (A wrapper for vtable_read, with a bit of extra stuff to handle editing clabs.)
</p>
<p><strong>class_write(edit_strrefs_in_place:b, class:s, struct:s)=()</strong> dimorphic (<a href="lib_class.html">lib_class</a>)<br></p><p>
Write the contents of a struct into class 'class'. This includes setting the clab file and the race tables (which are controlled by the 'any_race' and 'human'/'dwarf' (etc) struct variables.
If 'edit_strrefs_in_place' is set to 1, any strrefs have their values updated, rather than being
replaced with new strrefs (use this with caution).</p></p><p><p>Note that (unlike for lib_struct functions) 'struct' needs to be an array, not just a set of values. (So intermediate functions need to return the whole array.)
</p>
<p><strong>clear_out_haterace()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>CLONE_EFFECT(check_globals:i=1, check_headers:i=1, header:i="-1", header_type:i="-1", multi_match:i=999, verbose:i, silent:i, match_opcode:i="-1", match_target:i="-1", match_power:i="-1", match_parameter1:i="-1", match_parameter2:i="-1", match_timing:i="-1", match_resist_dispel:i="-1", match_duration:i="-1", match_duration_high:i="-1", match_probability1:i="-1", match_probability2:i="-1", match_dicenumber:i="-1", match_dicesize:i="-1", match_savingthrow:i="-1", match_savebonus:i="-11", match_special:i="-1", match_save_vs_spell:i="-1", match_save_vs_breath:i="-1", match_save_vs_poison:i="-1", match_save_vs_wand:i="-1", match_save_vs_polymorph:i="-1", match_ignore_primary:i="-1", match_ignore_secondary:i="-1", match_bypass_mirror_image:i="-1", match_ignore_difficulty:i="-1", match_drain_hp_to_caster:i="-1", match_transfer_hp_to_target:i="-1", match_fist_damage_only:i="-1", match_drain_to_max_hp:i="-1", match_suppress_feedback:i="-1", match_save_for_half:i="-1", match_made_save:i="-1", match_does_not_wake:i="-1", opcode:i="-1", target:i="-1", power:i="-1", parameter1:i="-11", parameter2:i="-11", timing:i="-1", resist_dispel:i="-1", duration:i="-1", duration_high:i="-1", probability1:i="-1", probability2:i="-1", dicenumber:i="-1", dicesize:i="-1", savingthrow:i="-1", savebonus:i="-11", special:i="-1", save_vs_spell:i="-1", save_vs_breath:i="-1", save_vs_poison:i="-1", save_vs_wand:i="-1", save_vs_polymorph:i="-1", ignore_primary:i="-1", ignore_secondary:i="-1", bypass_mirror_image:i="-1", ignore_difficulty:i="-1", drain_hp_to_caster:i="-1", transfer_hp_to_target:i="-1", fist_damage_only:i="-1", drain_to_max_hp:i="-1", suppress_feedback:i="-1", save_for_half:i="-1", made_save:i="-1", does_not_wake:i="-1", match_resource:s="SAME", resource:s="SAME", insert:s="above", match_function:f, function:f)=()</strong> patch (<a href="alter_effect.html">alter_effect</a>)<br></p>
<p><strong>CLONE_SCRIPT_BLOCK(insert_above:b, only_once:b, recompile:b=1, script:s, patch:f, function:f, patch_original:f, function_original:f, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, swap_out:s, swap_out1:s, swap_out2:s, swap_out3:s, swap_out4:s, swap_out5:s, swap_in:s, swap_in1:s, swap_in2:s, swap_in3:s, swap_in4:s, swap_in5:s, original_swap_out:s, original_swap_out1:s, original_swap_out2:s, original_swap_out3:s, original_swap_out4:s, original_swap_out5:s, original_swap_in:s, original_swap_in1:s, original_swap_in2:s, original_swap_in3:s, original_swap_in4:s, original_swap_in5:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p>
<p><strong>collect_this_animation(animation:s, resref_orig:s, ids_file:s, deposit_base:s="MOD_FOLDER/anims")=()</strong> action (<a href="lib_anim.html">lib_anim</a>)<br></p>
<p><strong>color_finder_tool()=()</strong> action (<a href="ui_add_portraits.html">ui_add_portraits</a>)<br></p><p>
NOT FOR LIVE USE - alter the UI so that the CHARGEN color customization screen displays the numerical values of the chosen colors
</p>
<p><strong>copy_item_to_spell(abil_ind:i, item:s, spell:s)=()</strong> action (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Take ability 'abil_ind' (default=0) from item 'item'. Build a new spell, 'spell', that casts that ability as its only ability.
</p>
<p><strong>cre_add_items(replace:i, struct:s, arguments:s, default:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Add a list of items. Each can have, in parentheses, a list of comma-separated instructions, which can be either:
<ul>
<li>'unequipped', in which case the item isn't equipped even if it's a weapon. (By default, it is.)
<li>'undroppable',unstealable', 'identified', 'stolen', in which case the appropriate flag is set
<li>An integer, interpreted successively as the first, second, third charge number
<li>A slot. (If no slots are specified, we choose on the basis of the item type.)
</ul>
You can set 'default' and it will be added to the instructions for each item.</p></p><p><p>If 'replace' is set to 1 (default 0) then the item in the slot will be replaced; if not it will be bumped.</p><p></p>
<p><strong>cre_add_spells(known:b=1, memorized:b=1, struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Add a list of spells, by default to both the 'known' and 'memorized' lists (set 'known' or 'memorized' to 0 to override this). You can use the ids name or the resref, and you can omit 'wizard_' or 'cleric_' where that's unambiguous. Adding (n) after the spell
adds it n times (to the memorized list only). 
</p>
<p><strong>cre_copy(tv:i, allow_missing:i, debug:i=1, cre:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_cre.html">lib_cre</a>)<br></p>
<p><strong>cre_edit(tv:i, allow_missing:i, debug:i=1, edit_strrefs_in_place:i, cre:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_cre.html">lib_cre</a>)<br></p>
<p><strong>cre_enforce_saves(struct:s, arguments:[at_worst|at_best|within_tolerance])=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Set the creature's saving throws to their legal values. 'arguments' can be blank (the default), 'at_worst', 'at_best', and
'within_tolerance', where tolerance is set by the ini value 'save_tolerance' and saves are modified if the old and new versions
are close enough.</p><p>Requires data_saving_throws macro to have been run
</p>
<p><strong>cre_enforce_saves_notstruct(arguments:s)=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p>
<p><strong>cre_enforce_thac0(struct:s, arguments:[at_worst|at_best|within_tolerance])=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Set the creature's thac0 to its legal value. 'arguments' can be blank (the default), 'at_worst', 'at_best', and
'within_tolerance', where tolerance is set by the ini value 'save_tolerance' and thac0 is modified if the old and new versions
are close enough.</p><p>Requires data_thac0 macro to have been run
</p>
<p><strong>cre_enforce_thac0_notstruct(arguments:s="exact")=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p>
<p><strong>cre_insert_script(struct:s, arguments:s, script:s, loc:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Given the usual array of combat scripts (override/class/race/general/default), and a script 'script' (synonym: 'arguments'), insert a new one in position 'loc'. 
Insert position can be 'high', 'low', 'after x' (defaults to 'high' if x isn't present), or 'before x' (defaults to 'low' if x isn't present).
If there isn't space, merge the two lowest scripts to make space.
</p>
<p><strong>cre_make(debug:i=1, cre:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_cre.html">lib_cre</a>)<br></p>
<p><strong>cre_min_stats(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Supply a space-separated list of 6 integers (the first can be a strength score like 18/76). Set the creatures STR/DEX/CON/INT/WIS/CHA to those integers, if lower.</p>
</p>
<p><strong>cre_quickset_known_spells(max_level:i=9, arguments:s, type:[wizard|priest|innate])=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
Given an array 'arguments' in the form resref=>level, and 'type' either 'wizard', 'priest', or 'innate', add the spells to the creature's
known spells (removing any previous version if appropriate). The spells are added in place using WEIDU's built-in ADD_KNOWN_SPELL function (i.e. this is not a struct function). 
Use this for bulk spell adding when speed matters: it's much faster than the struct system.</p></p><p><p>If max_level is set, add spells only up to this level.
</p>
<p><strong>cre_quickset_memorized_spells(arguments:s, type:[wizard|priest|innate])=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
Given a 2d array 'arguments' in the form (level,resref)=>number_memorized, and 'type' either 'wizard', 'priest', or 'innate', add the spells to the creature's
memorized spells. The spells are added in place using WEIDU's built-in ADD_MEMORIZED_SPELL function (i.e. this is not a struct function). Use this for bulk spell
adding when speed matters: it's much faster than the struct system.
</p>
<p><strong>cre_read_kit()=(value:s)</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
NOT a struct function.
Find the kit ID of the current kit. We don't look it up directly because that means parsing 
kitlist and it might be more efficient (depending on context) to do it directly.</p><p></p>
<p><strong>cre_read_original_class()=(value:s)</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
NOT a struct function.
Returns (as lower-case ascii) a creature's original class, or 'none' if they
don't have one.</p><p></p>
<p><strong>cre_remove_items(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Input a list of resrefs. Remove any items matching the list from item slots. (The items are then deleted when the struct is written back into the cre file.)
If the argument is 'all', everything is deleted.
</p>
<p><strong>cre_remove_spells(known:b=1, memorized:b=1, struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Delete a list of spells, by default from both the known and memorized lists (you can override this by setting  'known' or 'memorized' to 0). You can use the ids name or the resref, and you can omit 'wizard_' or 'cleric_' where that's unambiguous. Using 'all'
removes all spells.
</p>
<p><strong>cre_set_joinable_priest_spells()=()</strong> action (<a href="lib_cre.html">lib_cre</a>)<br></p><p>Assign the correct known spells to all party-joinable characters who can cast (non-spontaneous) priest spells. Requires data_joinable_dvs to have been run</p>
<p><strong>cre_set_kit(kitnum:i="-1", kit:s)=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
NOT a struct function.
Given a kit (a kitids entry 'kit' or an integer 'kitnum'), sets the
current creature's kit to that</p><p></p>
<p><strong>cre_set_known_priest_spells()=()</strong> patch (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
On the current creature, set the appropriate priest spells as known, based on class, level and alignment.
(This is fairly hardcoded as it'll tend to be applied in bulk.)</p></p><p><p>Requires the data_priest_spells and data_spells_by_level functions/macros to have been run
</p>
<p><strong>cre_set_proficiencies(struct:s, arguments:s, default:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Input a k=>v list. Each k is a proficiency; each v is its value. Set each of them.
</p>
<p><strong>cre_strip_scripts(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Input a list of scripts. Remove any script on the list from the creature. If 'all' is inputted, remove all scripts.
</p>
<p><strong>cre_swap_items(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Input a list of resref1=>resref2 pairs. Swap each resref1 for resref2 in the creature item list.
</p>
<p><strong>cre_swap_scripts(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_cre.html">lib_cre</a>)<br></p><p>
(This is a struct function.)</p></p><p><p>Input a k=>v list of pairs of scripts. Swap any k script for a v script.
</p>
<p><strong>data_joinable_dvs</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Returns the array 'sfo_joinable_dvs', in k=>_ form, containing the lowercased dvs of all joinable creatures
</p>
<p><strong>data_lines(data:s, path:s, file:s)=(lines:a)</strong> action (<a href="lib_tools.html">lib_tools</a>)<br><strong>data_lines(default_to_current_file:i=1, data:s, path:s, file:s)=(lines:a)</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
Given either 'data' (a string) or a path to a file, return either the string or the file separated into an array of lines, separated by line-breaks.
If 'data' and 'file' are both blank, use the contents of the current file (if in patch context) as input (override this by setting the default_to_current_file INT_VAR to 0)
</p>
<p><strong>data_priest_spells</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Return arrays "sfo_druid_spells" and "sfo_cleric_[alignment]_spells_n", containing the learnable cleric and druid spells of in resref=>level form.
[alignment] is each of the nine alignments as presented in align.ids, lowercased. Arrays are ordered from highest to lowest level and from highest-numbered
to lowest-numbered spell (this facilitates correctly (or at least intuitively) ordering the learned-spell lists if we use cre_quickset_known_spells).
</p>
<p><strong>data_priest_spells_by_type()=(druid_spells:a, cleric_spells:a)</strong> dimorphic (<a href="lib_data.html">lib_data</a>)<br></p>
<p><strong>data_proficiencies()=(weapprof:a, profs:a, profsmax:a)</strong> dimorphic (<a href="lib_data.html">lib_data</a>)<br></p><p>
Returns the (uppercase-rows/cols) arrays 'weapprof','profs', and 'profsmax', containing the contents of weapprof.2da and prof.2da respectively.
For weapprof, columns are indexed by the proficiency ID.
Adds SORCERER entries automatically to weapprof, cloning MAGE.</p><p>If copies of these files exist in weidu_external/data/dw_shared, use those instead (these are generated by ToF's externalized proficiency system.)
</p>
<p><strong>data_saving_throws</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Read in saving throws for all classes and store in a 3da struct, in the form 
sfo_saves_%class%_%level%_=n, up to level 50 (padding out if necessary)</p><p>Here type is 'death','wands','polymorph','breath', or 'spells', and class is lowercased.
</p>
<p><strong>data_scroll_resrefs</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Reads in every divine and arcane
spell, and stores them like this:</p><p>WIZARD_FIREBALL_SCROLL=scrl1g
$sfo_arcane_scrolls("WIZARD_FIREBALL")=scrl1g
CLERIC_FREE_ACTION_SCROLL=scrl58
$sfo_divine_scrolls("CLERIC_FREE_ACTION")=scrl58</p><p></p>
<p><strong>data_spell_resrefs</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Read in every entry in spell.ids and set a variable with that name whose
value is the spell resref, and store the data in the sfo_spell_resrefs array.
Also store the spell type</p><p>e.g. WIZARD_FIREBALL = SPWI304
     $sfo_spell_resrefs("WIZARD_FIREBALL") = SPWI304
	 WIZARD_FIREBALL_LEVEL = wizard
	 $sfo_spell_types("WIZARD_FIREBALL") = wizard</p><p>Also, for wizard/priest spells, store the spell level in the format</p><p>WIZARD_FIREBALL_LEVEL=3</p><p></p><p>If extended spell namespace is in use, add the spells from dw_ext_spell.ids too.</p><p>Also check for spells in the DWWP, DWPW, DWPI, DWWI namespace (as per ToF naming
conventions) , e.g.</p><p>CLERIC_FIREBALL=DWWP304
CLERIC_FIREBALL_LEVEL=3
INNATE_WIZARD_FIREBALL=DWWI304</p><p></p>
<p><strong>data_spells_by_level</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Read in spell slots for all classes and store in a struct 'sfo_spell_level', in the form</p><p>sfo_spell_level_%class%_%level%_%spell_level%"=n (# spells known at level)
sfo_spell_level_sl_to_cl_%class%_%level%=n (minimum level at which caster gets spells of this level)
sfo_spell_level_cl_to_sl_%class%_%level%=n (maximum level of spells known at caster level)
sfo_spell_level_max_%class%=n (max level of spells known)</p><p></p>
<p><strong>data_thac0</strong> action_macro (<a href="lib_data.html">lib_data</a>)<br></p><p>
Read in thac0 for all classes and store in a 2da, in the form 
$sfo_thac0("class" "level")=n up to level 50, padding out if necessary
</p>
<p><strong>data_vanilla_high_spells()=(vanilla_high_spells:a)</strong> dimorphic (<a href="lib_data.html">lib_data</a>)<br></p><p>
This just loads a hardcoded (uppercased, resref=>discard) list of hidden spells in the 50-99 namespace. It allows for the Spell Revisions mod.
</p>
<p><strong>define_favored_enemy_effect(id:i=1, hit:i=4, damage:i=4, name:i, desc:i, spell:s, race:s, class:s, general:s, label:s)=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>define_spell_list(determine_empty_levels:b, empty_level_max:i=9, silent:b, spells:s, key:s, list_name:s, spell_array:s)=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Given a space-separated list of spells 'spells', and/or an array spell=>_ or spell=>spell_level of spells, and a string 'key',
construct a spell list 'key' comprising those spells. If you use the spell=>spell_level format, it saves looking up the levels of the spells).</p></p><p><p>Spells can be given either as resrefs or as IDS entries (if the latter, they need to have been loaded into memory using data_spell_resrefs).
If a spell is missing, whine unless silent=1.</p></p><p><p>If determine_empty_levels=1, also record which levels are empty in the lua output. (empty_level_max is the highest level at which this is done - default is 9.)</p></p><p><p>Spell system is automatically set up if it isn't already.
</p>
<p><strong>DELETE_EFFECT(check_globals:i=1, check_headers:i=1, header:i="-1", header_type:i="-1", multi_match:i=999, verbose:i, match_opcode:i="-1", match_target:i="-1", match_power:i="-1", match_parameter1:i="-1", match_parameter2:i="-1", match_timing:i="-1", match_resist_dispel:i="-1", match_duration:i="-1", match_duration_high:i="-1", match_probability1:i="-1", match_probability2:i="-1", match_dicenumber:i="-1", match_dicesize:i="-1", match_savingthrow:i="-1", match_savebonus:i="-11", match_special:i="-1", match_save_vs_spell:i="-1", match_save_vs_breath:i="-1", match_save_vs_poison:i="-1", match_save_vs_wand:i="-1", match_save_vs_polymorph:i="-1", match_ignore_primary:i="-1", match_ignore_secondary:i="-1", match_bypass_mirror_image:i="-1", match_ignore_difficulty:i="-1", match_drain_hp_to_caster:i="-1", match_transfer_hp_to_target:i="-1", match_fist_damage_only:i="-1", match_drain_to_max_hp:i="-1", match_suppress_feedback:i="-1", match_save_for_half:i="-1", match_made_save:i="-1", match_does_not_wake:i="-1", match_resource:s="SAME", match_function:s)=()</strong> patch (<a href="alter_effect.html">alter_effect</a>)<br></p>
<p><strong>despecialize(string:s)=(string:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Take a string, and return it with any WEIDU regexp special characters escaped out.
</p>
<p><strong>detect_chargen_status()=()</strong> action (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>detectable_spells(fix_khelben:i=1, skip_legacy:i)=()</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>disable_subrace(subrace:s)=()</strong> action (<a href="ui_add_subraces.html">ui_add_subraces</a>)<br></p><p>
Disable the listed subrace (assumed to be installed) from the list of subraces offered to the player
in character generation.</p><p></p>
<p><strong>disjunctive_substitution(telemetry:b, script:s, dialog:s, match:s, replace:s, exclude_array_script:s="NO_ARRAY", exclude_array_dialog:s="NO_ARRAY")=()</strong> action (<a href="disjunctive_substitution.html">disjunctive_substitution</a>)<br></p><p>
For each bcs in the space-separated list 'script', and each dlg in the space-separated list 'dialog', swap 'match' for 'replace', keeping to the rules of Boolean algebra.</p>
<p>The syntax for 'replace' is either "OR()line1|line2|..." or "line1|line2|...".</p>
<p>If 'script'='all', process all scripts except those listed  in 'exclude_array_script'; likewise for dialogs.</p>
<p>Set telemetry=1 to get some debugging information.</p><p></p>
<p><strong>disjunctive_substitution_bcs_helper()=()</strong> patch (<a href="disjunctive_substitution.html">disjunctive_substitution</a>)<br></p>
<p><strong>divide_round_up(numerator:i, denominator:i)=(value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Divide two numbers, rounding up
any remainder
</p>
<p><strong>dlg_copy(tv:i, allow_missing:i, debug:i=1, dlg:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_dlg.html">lib_dlg</a>)<br></p>
<p><strong>dlg_edit(tv:i, allow_missing:i, debug:i=1, edit_strrefs_in_place:i, dlg:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_dlg.html">lib_dlg</a>)<br></p>
<p><strong>dlg_make(debug:i=1, dlg:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_dlg.html">lib_dlg</a>)<br></p>
<p><strong>ds_add_entry(min:i, id:s, file:s)=(stat_ind:s)</strong> action (<a href="ds.html">ds</a>)<br><strong>ds_add_entry(min:i, id:s, file:s)=(stat_ind:s)</strong> patch (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_detectable_weapon_enchantment()=()</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_fix_khelben()=()</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_load_ids(ids:s)=(ids_map:a)</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_make_detectable(match_opcode:i="142", match_parameter2:i="-1", stat_value:i=1, complain:i=1, duration:i="-1", id:s, resource:s, match_resource:s="SAME")=(ds_ids_map_stats:a, ds_ids_map_splstate:a)</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_process_table(complain:i, default_opcode:i=142, table:s, default_stat:s)=(ds_ids_map_stats:a, ds_ids_map_splstate:a)</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_resolve_stat(id:s)=(stat_ind:s, stat_param:s, stat_opcode:s, stat_type:s, ds_ids_map_stats:a, ds_ids_map_splstate:a)</strong> patch (<a href="ds.html">ds</a>)<br><strong>ds_resolve_stat(id:s)=(stat_ind:s, stat_param:s, stat_opcode:s, stat_type:s, ds_ids_map_stats:a, ds_ids_map_splstate:a)</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_return_first_entry(list:s)=(entry:s, list:s)</strong> patch (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_set_vars()=(is_tobex:s, enhanced_edition:s)</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_sort_ids(ids:s)=()</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>ds_stat_entries()=()</strong> action (<a href="ds.html">ds</a>)<br></p>
<p><strong>dual_class_kits()=()</strong> action (<a href="ui_dual_class_kits.html">ui_dual_class_kits</a>)<br></p><p>
Do setup work, ready to install specific dual-class kits.</p><p></p>
<p><strong>dual_on_done()=()</strong> patch (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>eff_copy(tv:i, allow_missing:i, debug:i=1, eff:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_eff.html">lib_eff</a>)<br></p>
<p><strong>eff_edit(tv:i, allow_missing:i, debug:i=1, edit_strrefs_in_place:i, eff:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_eff.html">lib_eff</a>)<br></p>
<p><strong>eff_make(debug:i=1, eff:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_eff.html">lib_eff</a>)<br></p>
<p><strong>eff_make_casting_effect(target:i=2, type:i=1, default:, cast, instantly, at, caster, level, level:i, if, set,, we, assume, type:i=2, effect:s, spell:s)=()</strong> action (<a href="lib_eff.html">lib_eff</a>)<br></p><p>Make an effect that casts a spell.</p>
<p><strong>eliminate_logic_redundancies(line:s)=(output:s)</strong> patch (<a href="disjunctive_substitution.html">disjunctive_substitution</a>)<br></p>
<p><strong>ensure_hex(pad_length:i, in:s)=(out:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Forces the string 'in' into hex form and passes it as 'out'. If pad_length is set to a non-zero value, ensure the hex is (at least) that long.
</p>
<p><strong>eval(var:s, arguments:s)=(var:s, value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a string, return its value if it's a variable, or the string itself if not.
Also permits 'argument'->'value' interface.
</p>
<p><strong>exclude_subrace(kit:s, subrace:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This forces 'kit' (a rowname entry from kitlist.2da) to prohibit characters of subrace 'subrace' (an ID from the sfo-lua-generated table 'dw_subrace_ids.2da' in dw_shared).
</p>
<p><strong>ext(uppercase:b)=(ext:s, version:s)</strong> patch (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>Returns the extension of the currently-being-patched file, if we can tell.
(we can tell for 2da, are, chr, cre, dlg, gam, itm, pro, spl, sto, vef, vvc, wed, and wmp)
Also return its version</p><p>By default we return lowercase; if you want it in uppercase, set uppercase=1.
</p>
<p><strong>extend(inline:i, ssl:i, tv:i, allow_missing:i, script:s, files:s, file:s, location:s, locbase:s, path:s, top:s, bottom:s, variables:s)=()</strong> action (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Extend the script(s) 'script' (legacy synonyms: file, files) with 'top' at the top and/or 'bottom' at the bottom. top and bottom location
is specified in the usual SFO way. If inline=1, 'top' and 'bottom' are assumed inlined at .../stratagems-inline</p><p>If ssl=1, assume 'top' and 'bottom' are ssl scripts, and pass 'variables' to the SSL parser.
If tv=1, prepend  to each script.
If allow_missing=1, skip silently any missing script (default is to WARN).
</p>
<p><strong>extend_area_script(inline:i, ssl:i, area:s, location:s, locbase:s, path:s, top:s, bottom:s, variables:s)=()</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Extend the area script of area 'area' with 'top' at the top and/or 'bottom' at the bottom. If the script doesn't exist, we create one, using standard conventions.
'area' can be a list of areas, in which case each one is extended.
</p>
<p><strong>extended_add_spell(force_extended:i, replace:i, id:s, file:s, path:s, location:s, locbase:s, exclude_alignment:s, exclude_kit:s, include_class:s)=(resref:s)</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p><p></p><p></p>
<p><strong>extended_add_spell_helper(force_extended:i, level:i, type_num:i, type:s, id:s)=(resref:s, lua_line_needed:s)</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p>
<p><strong>extended_spell_test()=()</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p><p>
This just copies 10 spells of each level into the 51-55 and extended namespaces, for testing. 
It also makes the Doom copy (SPPR1A3) good-only
</p>
<p><strong>externalize_haterace()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>externalize_prof_function_patch()=()</strong> patch (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>externalize_prof_patch()=()</strong> patch (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>externalize_profsmax()=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>externalize_weapprof()=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>find_elemental_spells()=(earth:a, air:a, fire:a, water:a, earth_shared:a, air_shared:a, fire_shared:a, water_shared:a)</strong> action (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>find_next_unused_lua(clone:i=1, try_next:i, root:s)=(lua_short:s)</strong> dimorphic (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>find_parenthesis_range(index:i, left:s="{", right:s="}")=(start:s, end:s)</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
given an index in a file, a left string, and a right string, extract the
index number of the first left string after that index and the matching right string
</p>
<p><strong>FJ_SPL_ITM_REINDEX()=()</strong> patch (<a href="ds.html">ds</a>)<br></p>
<p><strong>funlib_combine_libraries(library:s, path:s="MOD_FOLDER/sfo", data_path:s="MOD_FOLDER/sfo/data")=()</strong> action (<a href="lib_funlib.html">lib_funlib</a>)<br></p><p>Given 'library' and 'path' (defaults to the sfo library path), look for a template file, '<library>.tpt'. If you find it, copy it
to '<library>.tpc' (also at 'path'), replacing any instances of include-library{lib_whatever</p>
<p><strong>funlib_document_component(component_loc:s, extra_path:s)=()</strong> dimorphic (<a href="lib_funlib.html">lib_funlib</a>)<br></p><p>Particular application of funlib_document_libraries that documents all tpa/tph files in a directory, setting extra_path to the sfo library directory. </p>
<p><strong>funlib_document_libraries(library_path:s="MOD_FOLDER/sfo", library_array:a, extra_path:s, extra_array:s, style_path:s="../../doc/files", resource_path:s="MOD_FOLDER/sfo", template_path:s="MOD_FOLDER/sfo/resource/doc_template.html", doc_path:s="MOD_FOLDER/sfo/doc", ignore:s="MOD_FOLDER/sfo/data/weidu_functions.2da")=()</strong> dimorphic (<a href="lib_funlib.html">lib_funlib</a>)<br></p><p>Given either  an array of libraries in the form file=>path, or a path to a directory of libraries (assumed to be all and only the tph/tpa files)
generate HTML documentation for each library. MOD_FOLDER/sfo/resource/doc_template.html points to the HTML template into which we substitute the data. ../../doc/files points to the location of the css files and
similar. doc_path is where you want them to go. Functions listed in the 'ignore' 2da (by default, the weidu built-in functions) are ignored. If 'extra_array' or 'extra_path' are set, the 
libraries contained in the array or on the path are included for dependencies but not documented.</p>
<p><strong>get_hidespl_data()=(is_hidden:a)</strong> action (<a href="rebuild_spell_hotkeys.html">rebuild_spell_hotkeys</a>)<br></p>
<p><strong>get_hotkey_spells_by_root(display_output:i, root:s)=(hotkey_spells_array:a)</strong> action (<a href="rebuild_spell_hotkeys.html">rebuild_spell_hotkeys</a>)<br></p>
<p><strong>get_next_free_slot(current_slot:i)=(next_slot:s)</strong> action (<a href="rebuild_spell_hotkeys.html">rebuild_spell_hotkeys</a>)<br></p>
<p><strong>get_spell_array(list:s, root:s)=(this_array:a)</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Given 'root' either SPPR or SPWI, and 'list' a list of spell-list keys,
return an array of all spells with that root, in the format resref=>[01],
with the value being 1 iff the spell is in one of the lists.</p><p>If list is 'cleric' or 'druid', instead parse the spell directly and check its
usability fla</p><p></p>
<p><strong>get_sphere_data(path:s="sphere", list:s="sphere_list.2da", tra:s, tra_path:s)=(sphere_ids:a, sphere_name:a, sphere_defaults:a)</strong> action (<a href="ui_spell_system_spheres.html">ui_spell_system_spheres</a>)<br></p>
<p><strong>get_trigger_array()=(rest_of_block:s, trigger_array:a)</strong> patch (<a href="disjunctive_substitution.html">disjunctive_substitution</a>)<br></p>
<p><strong>GET_UNIQUE_FILE_NAME(extension:s, base:s)=(filename:s)</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br><strong>GET_UNIQUE_FILE_NAME(extension:s, base:s)=(filename:s)</strong> action (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
A temporary fix for the WEIDU version, until Wisp fixes it.</p><p>(deprecated as of WEIDU v248, which fixes the bug.)
</p>
<p><strong>get_virtual_parent_classes()=(virtual_parent_classes:a)</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p>
<p><strong>get_weapprof_path()=(weapprof_path:s)</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>globalize_array_load(silent:b, array:s)=(success:s, array:a)</strong> dimorphic (<a href="lib_globalize.html">lib_globalize</a>)<br></p><p>
The associative array 'array', which should previously have been saved, is loaded and returned as 'array'.
'success' is returned as 1 if the array was previously saved or 0 otherwise. If success=0, we print a warning,
unless silent=1.
</p>
<p><strong>globalize_array_save(append:i, array:s)=()</strong> dimorphic (<a href="lib_globalize.html">lib_globalize</a>)<br></p><p>
The associative array 'array' is saved, to be accessed later. If append=1, we append to an existing saved array.
</p>
<p><strong>handle_unusable(arguments:s)=(value:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Take as input a string, assumed to be an item description. If on EE, remove the 'not usable by:' bit.
</p>
<p><strong>hide_ability_button_for_kit(kit:s, buttons:s)=()</strong> action (<a href="ui_hide_ability_button.html">ui_hide_ability_button</a>)<br></p>
<p><strong>hide_ability_button_setup()=()</strong> action (<a href="ui_hide_ability_button.html">ui_hide_ability_button</a>)<br></p>
<p><strong>hide_displayed_ability_setup()=()</strong> action (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>hide_hla(resref:s)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>hide_hla_patch()=()</strong> patch (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>hide_hla_setup()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>hide_proficiency(id:i)=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>hide_this_displayed_ability(string:s)=()</strong> action (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>ids_resolve(min:i="0", max:i="-1", ids:s, idsfile:s)=(value:s)</strong> dimorphic (<a href="lib_ids.html">lib_ids</a>)<br></p><p>
Given an ids file and an ids symbol, return its int value, adding it if necessary. min and max are the minimum and maximum values to try.
</p>
<p><strong>ids_sort(idsfile:s)=()</strong> action (<a href="lib_ids.html">lib_ids</a>)<br></p><p>
Given an ids file, sort it numerically by index, preserving duplicates
</p>
<p><strong>immunity_effect(permanent:i=1, arguments:s, struct:s)=(struct:a)</strong> dimorphic (<a href="lib_immunity.html">lib_immunity</a>)<br></p><p>
(This is a struct function).</p></p><p><p>Patches the spell/item/creature to offer immunity to a list of effects. If run in permanent mode (the default) it adds the effect outright
with timing=9 (2 for items). On a spell, this is added to all abilities; on an item or cre, to the base item/cre.
If run in non-permanent mode, everything is applied as a clone of the controlling immune-to-this opcode (if any).</p></p><p><p>The list of effects is: charm, stun, fear, hold, sleep, poison, diseased, energy_drain, blinded, insects
</p>
<p><strong>immunity_effects_load</strong> action_macro (<a href="lib_immunity.html">lib_immunity</a>)<br></p><p>
Defines the arrays for the immunity_effect function</p>
<p><strong>immunity_find_strings()=(immunity_string_array:a)</strong> action (<a href="lib_immunity.html">lib_immunity</a>)<br></p><p>
This function gets all the immunity strings - loading them from a premade file if it exists, creating that file
otherwise. The file is created with COPY + and so persists even when the component is uninstalled.</p><p>The 'create file' version only works in English. It shouldn't be run in distributed code.
Make sure it's run ahead of time (on each of BG2, SoD, IWD) to make the files.</p><p>Currently EE-only, though wouldn't be difficult to adapt.
</p>
<p><strong>immunity_spell(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_immunity.html">lib_immunity</a>)<br></p><p>
Given a list of spell resrefs, grants (for an item or creature) while-equipped or permanent immunity.
On a spell, adds permanent (not just until-death) immunity to target=2 as an ability effect.
</p>
<p><strong>include(inline:b, literal:b, file:s, files:s, location:s, locbase:s, path:s)=()</strong> dimorphic (<a href="lib_include.html">lib_include</a>)<br></p>
<p><strong>indirect_load</strong> action_macro (<a href="lib_indirect.html">lib_indirect</a>)<br></p><p>
Load the various variables in resource_id, checking for duplicates and prebuilding any listed duplicates
</p>
<p><strong>info_button_move()=()</strong> patch (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>ini_check(silent:i, ini:s, arguments:s, section:s)=(value:s)</strong> dimorphic (<a href="lib_ini.html">lib_ini</a>)<br></p><p>
Return a value from the mod's ini (which needs to have previously been read in, as a flat ini, into SFO_reserved_ini_hash).
If 'section' is set, instead return a section-dependent value from the ini (it needs to have previously been read into SFO_reserved_ini_hash_2d).
If the ini doesn't contain that value, whine unless silent=1. ini and arguments are synonyms.
</p>
<p><strong>ini_global_add(default:i, add_to_ini:i, type:s, id:s, global:s)=()</strong> dimorphic (<a href="ui_set_ini_globals.html">ui_set_ini_globals</a>)<br></p>
<p><strong>ini_global_add_function(function:s)=()</strong> dimorphic (<a href="ui_set_ini_globals.html">ui_set_ini_globals</a>)<br></p>
<p><strong>ini_global_setup()=()</strong> action (<a href="ui_set_ini_globals.html">ui_set_ini_globals</a>)<br></p>
<p><strong>ini_load</strong> action_macro (<a href="lib_ini.html">lib_ini</a>)<br></p>
<p><strong>ini_read(backwards:b, flat:b, case:[upper|lower], section:s)=(array:a, section_array:a)</strong> patch (<a href="lib_ini.html">lib_ini</a>)<br><strong>ini_read(backwards:b, flat:b, file:s, section:s, path:s, location:s, locbase:s, case:[upper|lower])=(array:a, section_array:a)</strong> action (<a href="lib_ini.html">lib_ini</a>)<br></p><p>
Read in a file, or in patch context this file, in the 'ini' format. By default, store it in a 2d array (section,key)-> value. If 'flat' is set, instead store it as key=>value, ignoring sections. 
If 'backwards' is set, swap key and value. if 'case' is set, force the key and value into upper or lower case.
Also return a k=>_ array 'section_array' of section keys. If "section" is set, return only entries in the 'section' section (this automatically sets flat=1).</p><p>In action context, if path,location, and locbase are all blank, assume an in-game ini file.</p><p>Ini entries wrapped in "" will have them stripped.
</p>
<p><strong>ini_to_2da(ini:s, location:s, locbase:s, path:s, 2da_path:s, 2da:s, defaults:s, main_default:s="*", first_column:s, force_columns:s)=()</strong> action (<a href="lib_ini.html">lib_ini</a>)<br></p>
<p><strong>ini_write(array:s)=()</strong> patch (<a href="lib_ini.html">lib_ini</a>)<br><strong>ini_write(file:s, path:s, location:s, locbase:s, array:s)=()</strong> action (<a href="lib_ini.html">lib_ini</a>)<br></p>
<p><strong>insert_script(script_array:s, script:s, arguments:s, loc:s)=(script_array:a)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given a numbered-from-0 array of scripts 'script_array', and a new  script 'script' (synonym: 'arguments'), insert the new script in position 'loc'. 
Insert position can be 'high', 'low', 'after x' (defaults to 'high' if
x isn't present), or 'before x' (defaults to 'low' if x isn't present).
If there isn't space, merge the two lowest scripts to make space.
</p>
<p><strong>install(overwrite:b=1, inline:b, arguments:s, files:s, file:s, location:s, locbase:s, path:s, postfix:s, ext:s)=()</strong> action (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
'arguments' (synonym: 'files'; synonym:'file') is a list of files (including extensions) located at the location given by path/location/locbase. Each is copied over to the override;
if any are BAF/D, they are COMPILE EVALUATE_BUFFERred; if they are SSL, they are compiled to BCS; if they are v1 CREs, we run FJ_CRE_EFF_V2 to force V2 effects. 
If none of 'location', 'locbase', and 'path' are set, set location=resource. 
If overwrite=0, don't overwrite already-present files (does not affect scripts).</p><p>If 'ext' (legacy synonym: 'postfix') is set, automatically add that file extension (so LAF install STR_VAR files="script1 script2" ext=baf ... END installs script1.baf and script2.baf).</p><p>If the argument is 'all', apply to every file at the path. 
If both 'ext' and 'all' are set, apply to every file at the path with that file extension.
</p>
<p><strong>install_extended_spell_functions()=()</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p><p>
Add the LUA functions and menu edits to enable extended spells. (We're going to chance doing this just by REPLACE_TEXTUALLY.)
</p>
<p><strong>install_script(inline:i, script:s, location:s, locbase:s, path:s)=()</strong> action (<a href="lib_indirect.html">lib_indirect</a>)<br></p>
<p><strong>invert_string(block_size:i, string:s)=(string:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Break 'string' into 'block_size'xN substrings,
and invert the order of those substrings. </p>
<p><strong>iter_2da()=(array:a)</strong> patch (<a href="lib_iter.html">lib_iter</a>)<br></p><p>
Return an array of the game resources contained in the current 2da file, assumed to be of type old-monster-summoning (prototype MONSUM01), new-monster-summoning (prototype MSUMMO1), or spell-selection (prototype SPCL621)</p><p></p>
<p><strong>iter_resource(start:s, ignore:s, spell_use_function:s, icon_function:s)=(array:a)</strong> action (<a href="lib_iter.html">lib_iter</a>)<br></p><p>
Take as input the filename of a file. Return an array of filenames of resources used by that file, constructed recursively. Ignore any filenames for which the action function 'ignore', if set, returns true.</p>
<p>
We don't currently recurse through or collect the following:
<ul>
<li>Wish spell resources
<li>Familiars
<li>Tilesets
<li>The worldmap
<li>Creature animations
</ul>
</p>
<p>If 'spell_use_function' is set, apply it as a patch function to every spell resource referred to in an opcode. (We don't actually iterate through all of these
since they're not actually a resource used by the spell.) The function should take as inputs 'source' (the resref of the resource being patched), 'source_ext' (the ext of the resource being patched),
'resref' (the resref of the resource being removed/protected from, 'ext' (the ext of that resource - in this setup, basically always spl, though we do log item uses from 318 etc).</p><p></p>
<p><strong>iter_vef()=(array:a)</strong> patch (<a href="lib_iter.html">lib_iter</a>)<br></p><p>Return an array of the game resources contained in the current VEF file.</p>
<p><strong>itm_copy(tv:i, allow_missing:i, debug:i=1, itm:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_itm.html">lib_itm</a>)<br></p>
<p><strong>itm_edit(tv:i, allow_missing:i, debug:i=1, edit_strrefs_in_place:i, itm:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_itm.html">lib_itm</a>)<br></p>
<p><strong>itm_make(debug:i=1, itm:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_itm.html">lib_itm</a>)<br></p>
<p><strong>iwd_hla_menu()=()</strong> action (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>kit_add_clab_mc(kit_ids_entry:i, parent_class:s, primary_class:s, commands:s)=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Adds a list of powers to a multiclass kit. Supply: the entry of the kit in kit.ids ('kit_ids_entry'), the kit's parent 
class (parent_class), the class to which the powers are to be added ('primary_class'), and the list of powers to add ('commands').
'commands' is a comma-separated list each of whose elements should be of the form 'GA(arg)' or 'AP(arg)', where 'arg' is
the usual form of a lib_kit power command, i.e. 'resref first_level', 'resref first_level interval', or 'resref first_level interval last_level'.
</p>
<p><strong>kit_apply_powers(arguments:s, struct:s, class:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_baseline_lua()=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Make sure every kit is using a unique LUA entry. (Idempotent.)
</p>
<p><strong>kit_clab_initialize()=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
   Wild Mage squats on the
   core CLABs mages; give them unique entries.
    Also make sure every clab actually exists
</p>
<p><strong>kit_clab_mc_initialize()=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_copy(debug:b=1, kit:s, edits:s, struct:s=k)=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Given kit="old=>new", copy kit 'old' onto kit 'new'. 'old' can be a class instead of a kit, and can be a rowname entry from kitlist or a row label from clastext. 
This assumes 'new' is a new kit, and doesn't officially support overwriting, i.e. when kit 'new' already exists. (It might work fine but no guarantees.)</p></p><p><p>'edits' is executed as an anonymous function, which first reads old kit into struct 'struct' (default 'k') and then writes that struct onto the new kit.</p><p></p>
<p><strong>kit_copy_from(struct:s, arguments:s, source:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Struct function. 'arguments' is a space-separated list of kit-defining 2das. 'source' is another kit, identified via rowname. The values used by
that kit are copied over.
</p>
<p><strong>kit_edit(edit_strrefs_in_place:b, debug:b, clab_only:i, kit:s, edits:s, struct:s="k")=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Edit the kit (or class) 'kit'. (You can also specify a string of kits, and each will be edited, but be careful using this function for bulk minor editing of kits, 
as it may be faster to edit the relevant 2da directly.) 'kit' should be a rowname entry from kitlist.2da (or a class from class.ids), but
we can cope with it being a row entry from clastext.2da instead (e.g. we can cope with ARCHER or ASSASSIN rather than
FERALAN or ASSASIN).</p></p><p><p>'edits' is executed as an anonymous function, which first reads the kit into struct 'struct' (default value 'k') and then writes that struct back.</p></p><p><p>If 'edit_strrefs_in_place' is set to 1, any strrefs have their values updated, rather than being
replaced with new strrefs (use this with caution).
</p>
<p><strong>kit_edit_all(edit_strrefs_in_place:b, skip_trueclass:b, clab_only:b, parent_class:s, edits:s, filter:s, struct:s=k)=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Apply 'edits' as an edit to all kits with parent class 'parent_class', using the same syntax as 'kit_edit'. If 'skip_trueclass' is set to 0 (the default) also
include the parent class itself. If 'filter' is set, apply 'filter' as an SFO function to each (uppercased) kit label, and apply the edit only if the return value is 1. 
(You can use the anonymous function construct.)
</p>
<p><strong>kit_edit_clab(power_array:s, delete_powers:s, clab:s)=()</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_find_class_clab_prefix(class:s)=(prefix:s, clab:s)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Given a class, return the CLAB prefix for that class, and also the full unkitted CLAB file for that
class.
</p>
<p><strong>kit_find_next_ids(to_start:ix4029)=(idsnum:s)</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Find an unused ids entry in kit.ids, and return it in hex format.
</p>
<p><strong>kit_find_next_unused_lua(clone:i=1, try_next:i, root:s)=(lua_short:s)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Given 'root', find the first unused lua of the form 'LU[root][0-9]', starting from try_next (by default, 0). If clone=1 (default) copy the default
version over to the new one. The returned string, 'lua_short', does not include the 'lu'.
</p>
<p><strong>kit_find_unused_clab(try_next:i=1, parent_class:s, file_ext:s)=(clab:s)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Find an unused clab for the current kit.
</p>
<p><strong>kit_get_id(kit:s)=(kit_id:s, found:s)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Find the kit_id of a kit. (The left-hand column of kitlist.2da.) Returns a new entry if not found. Also returns 'found' as 1 if found, 0 if not
</p>
<p><strong>kit_grant_apply_mc_powers(arguments:s, struct:s, class:s, prefix:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_grant_powers(arguments:s, struct:s, class:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_label_original_classes()=()</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_match_usability(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Struct function. 'arguments' is a kit; the current kit's 'unusable' flag is set to match it
</p>
<p><strong>kit_read(clab_only:i, kit:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Read the contents of a kit (or the kit part of a class, if 'kit' is a class) into a struct. (This is basically a wrapper for vtable_read, with a bit of extra functionality to support clab editing.)
</p>
<p><strong>kit_remove_powers(arguments:s, struct:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p>
<p><strong>kit_resolve_spell_applicator(number:i=1, spell:s="null")=(applicator:s)</strong> action (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Checks a master table (dw_mc_applicators.txt, in data_loc_shared) to see if we have a spell which grants 'spell' 'number' times. If we do, return its resref. If we don't, build it and then return its resref.</p><p></p>
<p><strong>kit_set_alignment(struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Struct function. 'arguments' is a space-separated list of alignments in format 'cg', 'nn', etc. Those and only those alignments are permitted.
</p>
<p><strong>kit_set_race_tables(force:b, struct:s, kit:s)=()</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Given a kit-defining struct, set the race tables to reflect any changes in availability.
If force=1, set them whether or not the struct metavariables are set (use this for new/copied
kits).
</p>
<p><strong>kit_set_table(present:b=1, kit_id:i, table:s)=()</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Given a k_x_y table (which might not exist), a kit id, and 'present' (a Boolean),
add or subtract the kit to/from the table, creating it if necessary
</p>
<p><strong>kit_write(is_dummy:b, clab_only:i, edit_strrefs_in_place:b, kit:s, struct:s)=()</strong> dimorphic (<a href="lib_kit.html">lib_kit</a>)<br></p><p>
Write the contents of a struct into (new or existing) kit 'kit'. This includes setting the clab file and the race tables (which are controlled by the 'any_race' and 'human'/'dwarf' (etc) struct variables).
If 'edit_strrefs_in_place' is set to 1, any strrefs have their values updated, rather than being
replaced with new strrefs (use this with caution). ('is_dummy' just creates a dummy kit; this is used internally).
</p>
<p><strong>level_at_xp(xp:i, num_classes:i=1, class:s)=(level:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Returns the level of a character with the given amount of XP. num_classes should
be 1 for single-class PCs, 2 for double-class, 3 for triple-class. Class should be class.ids entry.
</p>
<p><strong>levelling_on_done()=()</strong> patch (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>lightweight_hla_adder(min_level:i=1, max_level:i=99, num_allowed:i=99, apply:i=1, resref:s, lu_file:s)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>log_this(repeat:b=1, new:b, file:s, input:s, arguments:s, path:s="weidu_external/data/MOD_FOLDER", location:s, locbase:s)=()</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Dump the string 'input' (synonym:'arguments') into the text file 'file' (by default placed in the weidu_external/data/MOD_FOLDER directory, but you can override), creating it if necessary.</p><p>If repeat=0, only do this if it's not already there.
If new=1, wipe any existing contents
</p>
<p><strong>make_discard_hla()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>make_elemental_spell_lists(adjust_description:i=1, tra:s=sfo_lua, tra_path:s="DEFAULT")=(earth_names:s, air_names:s, fire_names:s, water_names:s, all_names:s)</strong> action (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>make_extended_spell_line(add_to_clab:i, resref:s, include_class:s, exclude_kit:s, exclude_alignment:s)=(line:s, no_align_restrictions:s, lua_array:s, class_bar:a, kit_bar:a, align_bar:a)</strong> patch (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p>
<p><strong>make_force_spell_lists()=()</strong> action (<a href="ui_spell_system_elemental.html">ui_spell_system_elemental</a>)<br></p>
<p><strong>make_label(label:s)=()</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Set a marker file, which can be checked by check_label. </p></p><p><p>Do not use make_label or check_label in your base tp2 to decide whether to install a component, as they are invisible to Project Infinity and the like.
</p>
<p><strong>math_transitive_closure(relation:s)=(relation:a)</strong> dimorphic (<a href="lib_math.html">lib_math</a>)<br></p><p>
Given a 2 place relation defined by a 2D array s.t. array(k,v)=1 iff Rkv, construct its
transitive closure.
</p>
<p><strong>math_traverse_directories(directory:s)=(array:a)</strong> action (<a href="lib_math.html">lib_math</a>)<br></p><p>
Given a directory, recursively return itself and its subdirectories and their subdirectories, etc. as an array in k=>_ form
</p>
<p><strong>math_traverse_graph(max_iterations:i=1000, silent:b, telemetry:b, start:s, relates_to:f, parameter:s)=(visited_nodes:a)</strong> dimorphic (<a href="lib_math.html">lib_math</a>)<br></p><p>
Given:
- a string 'start'
- an action function 'relates_to' that maps strings ('arguments') to arrays of strings 'array', and takes an
  optional argument 'parameter'</p><p>return an array 'visited_nodes' of all strings connected to the original string by the transitive closure
of the 'relates_to' relation.</p><p>Gives up after 'max_iterations' iterations. Set silent to 1 to be told when it's finished, and telemetry to 1
to get a bit more information.
</p>
<p><strong>merge_scripts(top:s, bottom:s, script:s)=(script:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
If both 'top' and 'bottom' exist, merge them into a new script, and give it a guaranteed-unique name unless a name
is specified. In any case, return the name.
If one doesn't exist, return the name of the other.
</p>
<p><strong>mos_install_v2(lowest_mos_index:i, mos_name:s, mos_loc:s, pvrz_loc:s)=()</strong> action (<a href="lib_mos.html">lib_mos</a>)<br></p>
<p><strong>NAME_NUM_OF_SPELL_RES(silent:i, spell_res:s)=(spell_name:s, spell_num:s, success:s)</strong> dimorphic (<a href="resolve_spell.html">resolve_spell</a>)<br></p>
<p><strong>new_file(no_log:i, arguments:s, file:s, location:s, locbase:s, path:s)=()</strong> dimorphic (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
Create a new file 'file' at locations given by location/locbase/path (use only 'path' if you want to run self-contained), containing only the string 'arguments' with no spacing or line breaks
</p>
<p><strong>no_int_max_spells()=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p>
<p><strong>opcode_extract(opcode:i="-1", header:i="-1", saves:b, probs:b, include_primary:b, sectype:i, file:s, eff:s)=(subspell:s)</strong> action (<a href="lib_opcode.html">lib_opcode</a>)<br></p><p>
	Given 'file', which should be an item or spell, and 'opcode', we extract the any associated effects from file and cast them as a subspell. If header is set to a nonnegative number, we do this only for that header (header is required for item files). Returns the resref of the subspell.</p>
	<p>By default, the saving throws/MR checks and probabilities are checked when the subspell is called. Set saves=1 and probs=1 to keep those checks with the individual effects in the subspell.</p>
	<p>Also by default, the opcode itself is not extracted. Set include_primary=1 to extract it.</p>
	<p>If you set sectype to a positive number, the subspell receives that sectype. (Otherwise it has sectype 0).</p>
<p><strong>opcode_load_data</strong> action_macro (<a href="lib_opcode.html">lib_opcode</a>)<br></p><p>
	Load the library data used by lib_opcode functions. The default assumption is that the data is in MOD_FOLDER/sfo/data, but you can override by setting sfo_opcode_data_path to the (full) path to the data. Returns sfo_opcode_data_loaded=1.</p><p></p>
<p><strong>opcode_secondary_effects(primary_opcode:i="-1", fx_off:i, include_all_cosmetics:b, include_primary:b, parent_resource:s="lib_opcode")=(value:s, opcode:s)</strong> patch (<a href="lib_opcode.html">lib_opcode</a>)<br></p><p>
	Given the offset of an fx block, and a primary opcode, returns 1 if the opcode of the block is associated with the primary opcode (that is: it is an appropriate icon or other cosmetic 
	effect, or else is a reliably-associated secondary effect). If include_primary is set to 1 (default=0) return the primary opcode itself here. If include_all_cosmetics is set to 1 (default=0), 
	returns true for any cosmetic effect (except icons and strrefs, which always get checked).</p>
	<p>For convenience, we also return the opcode itself (as 'opcode').</p>
	<p>parent_resource should be set to the file in which the block is assumed to be (defaults to SOURCE_RES)</p><p></p>
<p><strong>override_chargen_kit_name(override:i, use_tra:b=1, kit:s, class:s, lua:s="m_dw_vcd")=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This function overrides the name displayed on the character-generation selection screen (but not on the character sheet) for a specific kit, which is specified both by 'kit' (a rowname entry from kitlist.2da) and 'class' (an entry in class.ids).</p></p><p><p>The integer 'override' specifies the new name. By default it's an entry drawn from the current tra file. If use_tra is set to 0, it's instead a strref.</p>
<p>'lua' lists where the override instruction is stored. (Don't change this off the default unless you know what you're doing and have a very good reason.)</p>
</p>
<p><strong>override_class_kit_menu(virtual:b, title_tra:i="-1", class:s, title:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This changes the title of a kit-selection menu in character generation. 'Class' should be an entry from class.ids, or the ID of a virtual class (in the latter case, you need to set virtual=1). You can set the title either directly as a string ('title') or indirectly as the tra number of a line in the current tra file ('title_tra').
</p>
<p><strong>override_class_kit_menu_setup()=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p>
<p><strong>override_hla_description(strref:i, resref:s)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>override_hla_name(strref:i, resref:s)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>override_hla_name_description_setup()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>override_kit_desc_data(old_1_strref:i, new_1_strref:i, old_2_strref:i, new_2_strref:i, old_3_strref:i, new_3_strref:i, kit:s, swap:s, old_1:s, new_1:s, old_2:s, new_2:s, old_3:s, new_3:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This function overrides the displayed class names on a character's character sheet. Its main use is for multiclass kits, so that the names of the kit components show up instead of the class components.
The 'kit' variable (which should be a kitlist 2da rowname) specifies the kit for which the override should be applied.</p></p><p><p>You can specify the override in several ways. The simplest (which is usually sufficient) is to set 'swap' to a list of class=>kit swaps, e.g. swap="fighter=>kensai thief=>assasin". Here 'class' should be a class.ids entry, and 'kit' should be a 
kitlist.2da rowname. You can also directly specify strings to be swapped out and in, either by strref (old_[123]_strref is swapped for new_[123]_strref) or directly by string (old_[123] is swapped for new_[123]).
</p>
<p><strong>override_name_patch()=()</strong> patch (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>parse_spell_lists(allow_learn:s, block_learn:s, allow_priest:s, block_priest:s, type:s="priest")=(spell_array:a)</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Given the 'allow_learn', 'block_learn', 'allow_priest', 'block_priest' values for some (actual or fictional)
kit, and its type (either 'priest' or 'mage') return an array of all usable spells, in the format resref=>1</p><p></p>
<p><strong>patch_button()=()</strong> patch (<a href="ui_hide_ability_button.html">ui_hide_ability_button</a>)<br></p>
<p><strong>point_in_bounds(x:i, xmin:i, xmax:i, y:i, ymin:i, ymax:i)=(in_bounds:s, x_in_bounds:s, y_in_bounds:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Determine whether (x,y) are inside the rectangle with bottom left point (xmin,ymin) and top right point (xmax,ymax)
</p>
<p><strong>prepare_lua()=(occupied_slots:a)</strong> action (<a href="rebuild_spell_hotkeys.html">rebuild_spell_hotkeys</a>)<br></p>
<p><strong>pro_copy(allow_missing:i, debug:i=1, pro:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s, missile_entry:s)=(value:s)</strong> action (<a href="lib_pro.html">lib_pro</a>)<br></p><p>General copier for pro files. Each pro file copied over will be added to projectl.ids if not already present. The function returns the ids number of the last pro to be added. 'missile' is the entry in missile.ids (defaults to the projectile name); only really works when adding only one missile at a time.</p>
<p><strong>pro_edit(allow_missing:i, debug:i=1, pro:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_pro.html">lib_pro</a>)<br></p><p>General editor for pro files, in the normal lib_struct format.</p>
<p><strong>pro_make(debug:i=1, pro:s, version:s, path:s, location:s, locbase:s, edits:s)=(value:s)</strong> action (<a href="lib_pro.html">lib_pro</a>)<br></p><p>General maker for pro files. Each pro file made will be added to projectl.ids if not already present. The function returns the ids number of the last pro to be added.</p>
<p><strong>process_extended_spells()=()</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p><p>
Get the extended-namespace spells into lua and into auto-grant spells.
</p>
<p><strong>process_favored_enemy_ini(file:s, location:s, locbase:s, path:s)=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>process_scroll_usability_now()=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p>
<p><strong>prof_adjust(reexternalize:b=1, kit:s, patch:s, arguments:s)=()</strong> action (<a href="lib_prof.html">lib_prof</a>)<br></p><p>
Apply the SFO standard function 'patch' to all proficiencies of a certain type belonging to the kit 'kit' (can be a space-separated list). Possible arguments are (i) a space-separated list of standard prof names; (ii), 'melee', 'ranged', or 'all'. In each case prof_lookup is used to try to preserve compatibility, and each proficiency will be patched only once even if multiple BG2-style proficiencies point at the same proficiency. You can use the anonymous function construct.
</p>
<p><strong>prof_build_lookup(overwrite:b)=(prof_lookup_array:a, prof_lookup_rows:a, profs_used_array:a, profs_used_rows:a, unused_profs:a)</strong> action (<a href="lib_prof.html">lib_prof</a>)<br></p><p>
Construct
<ol>
<li>a 2da lookup table (prof_lookup.2da) mapping vanilla BG2 proficiencies to actual proficiencies, using prototype weapons as a source. (e.g. we check BOW03, and map 'LONGBOW' to whatever proficiency is assigned to it). The table rows are indexed by old proficiency names,
and has these columns: 'ID', 'NAME' (the weapprof row name for the new proficiency added), 'STRREF' (the name of the proficiency, taken from weapprof) 'WEAPON_STRREF' (the name of the actual prototype weapon in the BG2 proficiency - this is 'scimitar' for 
SCIMITARWAKISASHININJATO), 'TYPE' (either MELEE, MISSILE, or STYLE). Styles are automatically included.</li>
<li>a 2da lookup table (profs_used.2da) listing the actual proficiencies in use. (A proficiency is in use if either (i) it is the proficiency of any of the prototype weapons, or (ii) in the case of styles, unkitted fighters have at least one pip in it.) 
The table rows are indexed by weapprof row names and have these columns: 'ID', 'STRREF' (the name of the proficiency, taken from weapprof) and 'TYPE' (either MELEE, MISSILE, or STYLE).</li>
<li>a text table (profs_unused.txt) listing the unused profs in the format 'NAME ID'.</li>
</ol>
All these are stored in data_loc and are generated if present already only if the INT_VAR overwrite is set to 1. In any case, each is then read into memory, into the 2D arrays 'prof_lookup_array' and 'profs_used_array' and the k=>v array 'unused_profs', respectively.
The rows of the two 2das are also returned as the arrays 'prof_lookup_rows' and 'profs_used_rows'.
</p>
<p><strong>prof_copy(only_if_nonzero:b, reexternalize:b=1, copy_to:s, copy_from:s)=()</strong> action (<a href="lib_prof.html">lib_prof</a>)<br></p><p>
Copy the proficiencies from kit 'copy_from' to kit 'copy_to'. If 'only_if_nonzero' is set to 1, proficiencies set to 0 in kit copy_to remain at zero. Only weapon proficiencies, not weapon styles, are done.</p>
<p>If the proficiencies have been externalized (i.e. if weapprof.2da is present in data_loc_shared) then copy it over to override first. If reexternalize=1, reexternalize afterwards.
</p>
<p><strong>read_whatever(length:i, offset:i)=(value:s)</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
Given an offset in the current file, and given a length that is 1,2,or 4, read the appropriate-length integer from that offset.
</p>
<p><strong>rebuild_spell_hotkeys()=()</strong> action (<a href="rebuild_spell_hotkeys.html">rebuild_spell_hotkeys</a>)<br></p>
<p><strong>rechoose_ranger_favored_enemy(levels:s)=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>regexp_warning(file:s, parent:s="<unknown>")=()</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Special case of 'warning' used specifically as a soft-fail for regexps.
</p>
<p><strong>remove_erase_bg()=()</strong> patch (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p>
<p><strong>remove_erase_iwd()=()</strong> patch (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p>
<p><strong>remove_joinable_spells(remove_known:i=1, remove_memorized:i=1)=()</strong> action (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Deletes the 'known' and 'memorized' spell lists (SPPR/SPWI namespace only) from all party-joinable NPCs
</p>
<p><strong>require_gender(kit:s, gender:[male|female])=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This forces 'kit' (a rowname entry from kitlist.2da) to require the character to be male or to be female, according to what 'gender' is set to.
</p>
<p><strong>RES_NUM_OF_SPELL_NAME(silent:i, spell_name:s)=(spell_res:s, spell_num:s, success:s)</strong> dimorphic (<a href="resolve_spell.html">resolve_spell</a>)<br></p>
<p><strong>resolve_dv(creature:s, default:s)=(dv:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given a creature's file resref, returns the scriptname (death variable) of the creature. If it has none, assign it one.
By default, the assigned scriptname is its resref; you can override this by setting 'default'.
</p>
<p><strong>resolve_sectype(strref:i="-1", sectype:s, arguments:s, string:s)=(sectype_value:s, value:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given a sectype 'sectype' (synonym: 'arguments') and associated string (STR_VAR 'string') or tlk entry (INT_VAR 'strref'), 
check if the sectype is already present. If it is, set its string to the specified string. If it isn't, add it, 
with that string. Either way, return its value as 'sectype_value' (synonym: 'value').</p><p>If both the strref and string are specified, default to the string (and log a warning). If string is "" (the default), use strref=-1 rather 
than an actual blank string.</p><p></p>
<p><strong>resolve_splprot_entry(stat:i, val:i, value:i, relation_number:i, relation:s, description:s)=(value:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Given 'stat', 'val' (legacy synonym: 'value'), and either 'relation_number' or 'relation', return an appropriate entry in splprot.2da, adding
it if necessary. (see IESDP opcode documentation for opcode 324).</p></p><p><p>'Relation' can be:
<ul>
<li>'equals'/'equal' (resolves to 1)
<li>'less'/'less_than' (resolves to 2)
<li>'greater'/'greater_than' (resolves to 3)
<li>'less_than_equal'/'less_than_equals'/'less_equal' (resolves to 0)
<li>'greater_equal'/'greater_equals' (resolves to 4)
<li>'not_equal' (resolves to 5)
</ul></p><p><p>'description', if set, is added to the bare number of a new entry, following the 2.6 EE style. (Existing entries do not gain descriptions.)
</p>
<p><strong>resolve_statdesc(check_first:i="-1", strref:i="-1", string:s, bam:s, bam_name:s, path:s, location:s, locbase:s)=(stat_num:s)</strong> dimorphic (<a href="lib_ietool.html">lib_ietool</a>)<br></p><p>
Adds a new line to statdesc.2da. You need to specify:
<ul>
<li>the strref of a string, 'strref' (or you can specify the string
directly, 'string', and it will be added to dialog.tlk)</li>
<li>the name ('bam') of the bam file to be used for the line. (It can be an in-game file, or
one to be copied over from your mod directory - SFO will see if it exists, and try to copy
it if it doesn't.)</li>
<li>the location of the bam file, if it is in your mod directory, specified SFO-style via 'location','locbase','path'.</li>
<li>the actual name to be used for the bam file, 'bam_name'. If you leave it blank, 'bam' will be used instead (always
do this if you are using an in-game file). If you set it to 'auto', a unique name will be auto-generated.</li>
</ul>
If you set the INT_VAR 'check_first', SFO will first check that line number to see if it exists. If it does, its line will
be returned and no new line will be added; however, the description will be set if it is currently blank.</p>
<p>If you set the bam to "****", no bam will be used.
</p>
<p><strong>return_first_entry(list:s, separator:s=" ")=(entry:s, list:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a list of strings (separated by spaces, either bare or in "" or ~~ quotes), return the first entry, and the rest of the list. If 'separator' is specified,
use it instead of space to separate strings. (It should be a single character.) If you use ' ' as a separator, newlines and tabs are replaced by spaces in processing the string
</p>
<p><strong>return_first_pair(list:s, arrow:s=":s=>", separator:s=" ")=(list:s, key:s, value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a string in the form 'key=>value list', return the first key, the first value, and the rest of the string. if 'arrow' is specified, its value is used in place of 
'=>' to separate key-value pairs. 'key' and 'value' can be bare strings or can be wrapped in "" or ~~.
</p>
<p><strong>run(marker:b=1, literal:b, file:s, files:s, location:s, locbase:s, path:s, version:s, tra:s)=()</strong> dimorphic (<a href="lib_include.html">lib_include</a>)<br></p><p>
'file' (synonym: 'files') is a list of tpa files (leave off the suffix), located at the location specified by 'location', 'locbase', and 'path'. (If none are set, assume location is component_loc.) Each is loaded, and then each file's name is run
as an action function, with the STR_VAR argument 'version' fed to it, and with the tra file 'tra' (english and local-language versions) loaded. (So each tpa should conform to the SFO
convention of containing an action function of its own name.Unless literal=1, SFO syntactic sugar is applied.</p><p>When used outside an extant 'run' instruction (in the intended setup, this should be from your tp2 as the only instruction in the component,
though I can't enforce that), it sets 'component_loc' to 'location', defaults to using 'location' as the name of the tra file, and sets a marker file with 
name '%marker_prefix%resolve_spell.tph'. 'marker_prefix' defaults to 'sfo_marker_prefix', which in normal usage should have been set in your 'always' file. If INT_VAR marker is set to 0, this marker is not placed.
</p>
<p><strong>script_alter_block(only_once:b, recompile:b=1, script:s, patch:f, function:f, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, swap_out:s, swap_out1:s, swap_out2:s, swap_out3:s, swap_out4:s, swap_out5:s, swap_in:s, swap_in1:s, swap_in2:s, swap_in3:s, swap_in4:s, swap_in5:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p><p>
Up to 6 regexps ('swap_out', and 'swap_out1'-'swap_out5') are specified. Each is matched against any matched block via REPLACE_TEXTUALLY, and on a match, is swapped for (respectively) 'swap_in' or 'swap_in1'-'swap_in5'. 
</p>
<p><strong>script_array_to_block(array:s)=(block:s)</strong> patch (<a href="alter_script.html">alter_script</a>)<br></p><p>
Given 'array'', which should be of the form created by script_block_to_array, return the BAF block as 'block'.
</p>
<p><strong>script_block_to_array(block:s)=(length:s, array:a)</strong> patch (<a href="alter_script.html">alter_script</a>)<br></p><p>
Given 'block', which should be a single BAF block, return an array 'array' whose keys are successive integers (from 0) and whose values are the successive lines of the block.
Also return 'length', the number of lines in the block.
</p>
<p><strong>script_clone_block(insert_above:b, only_once:b, recompile:b=1, script:s, patch:f, function:f, patch_original:f, function_original:f, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, swap_out:s, swap_out1:s, swap_out2:s, swap_out3:s, swap_out4:s, swap_out5:s, swap_in:s, swap_in1:s, swap_in2:s, swap_in3:s, swap_in4:s, swap_in5:s, original_swap_out:s, original_swap_out1:s, original_swap_out2:s, original_swap_out3:s, original_swap_out4:s, original_swap_out5:s, original_swap_in:s, original_swap_in1:s, original_swap_in2:s, original_swap_in3:s, original_swap_in4:s, original_swap_in5:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p><p>
Any matched block is copied directly below (or, if insert_above=1, directly above) the matched block. Up to 6 regexps ('swap_out', and 'swap_out1'-'swap_out5') are specified. Each is matched against the (decompiled) copied block via REPLACE_TEXTUALLY, and on a match, is swapped for (respectively) 'swap_in' or 'swap_in1'-'swap_in5'. The same happens to the original block, using 'original_swap_out'/'original_swap_out[1-5]' and 'original_swap_in'/'original_swap_in[1-5]'.
</p>
<p><strong>script_custom_hotkeys()=()</strong> patch (<a href="lib_script.html">lib_script</a>)<br></p><p>
On the current file (assumed to be a BAF file) swap any hotkey commands with user-set hotkey remaps,
as set in the ini. 
</p>
<p><strong>script_disjunctive_delete(arguments:s)=()</strong> patch (<a href="alter_script.html">alter_script</a>)<br></p>
<p><strong>script_insert_block(insert_above:b, only_once:b, recompile:b=1, script:s, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, insert:s, location:s, locbase:s, path:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p><p>
'insert' should be either a complete path to a BAF file, or the filename of a BAF file with location given in sfo fashion by 'location'/'locbase'/'path'. That file is inserted after (or, if insert_above=1, before) any matched block.
</p>
<p><strong>script_install(silent:i, arguments:s, script:s, scripts:s, location:s, locbase:s, path:s)=()</strong> action (<a href="lib_script.html">lib_script</a>)<br></p><p>
Given a list 'arguments' (syonyms: 'script', 'scripts') of script names (without .baf suffix), located at the location given by location/locbase/path,
compile them into the override, first applying script_ee_to_vanilla if we're on a non-EE game. If a script is
missing, whine unless silent=1.</p>
<p>If instead input is a list of k=>v pairs, compile k.baf to v.bcs (we don't check variables in this case).</p></p><p><p>
If the script name is a set variable, compile it to the value of that variable, e.g. if script_for_wyrms is set
to dw#wyrm1, compile script_for_wyrms.baf to dw#wyrm1.bcs.
</p>
<p><strong>script_replace_block(only_once:b, recompile:b=1, script:s, match_function:f, match:s, match1:s, match2:s, match3:s, match4:s, match5:s, insert:s, location:s, locbase:s, path:s)=()</strong> action (<a href="alter_script.html">alter_script</a>)<br></p><p>
'insert' should be either a complete path to a BAF file, or the filename of a BAF file with location given in sfo fashion by 'location'/'locbase'/'path'. That file is substituted in to replace any matched block.
</p>
<p><strong>scroll_spec_bonus_setup()=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Build the various resources needed for the externalized bonus-spell setup.
</p>
<p><strong>set_basic_hla_progression(min:i, step:i)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>set_dual_class_kit_components_for_proficiencies(kit:s, components:s)=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>set_kit_display_priority(priority:i, kit:s)=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
This assigns an integer 'priority' to the kit 'kit' (specified by a kitlist.2da rowname). This determines the order in which the kits are displayed at character selection: kits are displayed in increasing order of order priority, with kits that have no order priority 
displayed last and kits displayed in alphabetical order within each priority.
</p>
<p><strong>set_signalling_stat(stat:i)=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>set_signalling_stat_helper(stat:i)=()</strong> patch (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>set_specialist_spells(number_required:i=1, list_spells:b=1, update_description:b, learn_more_line:s, memorize_more_line:s, old_line:s, new_line_1:s, new_line_2:s, string_school:s, string_school2:s, kit:s, spell_list:s, tra:s="sfo_lua", tra_path:s)=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Given a kit 'kit' (a rowname entry in kitlist.2da), an optional integer 'number_required' (default=1) and a space-separated list of spell-list keys 'spell_list',
require that kit to learn at least number_required spells from that list.</p></p><p><p>The optional 'learn_more_line' and 'memorize_more_line' are displayed to players in character generation if they don't learn/memorize an appropriate number of speciality spells. (If not set, the component autogenerates a default warning.)</p>
<p>The variables 'tra' and 'tra_path' specify where some standard strings are drawn from (the default assumption is that they're from sfo/lua/lang//sfo_lua.tra").</p></p><p>
<p>If update_description is set to 1, the function will attempt to update the kit description. (This only works with kits in a relatively standard format.)
The various other variables control how this works:
<ul>
<li>'old_line' is by default 'May cast one additional spell per level.', but it can be any 'advantage' or 'disadvantage' line from the kit description. It is deleted from the kit description if present.
<li>'school_string' is by default 'from the LISTNAME school', where LISTNAME is the name-string of the specialist list, or the last such list if there is more than one.
<li>'new_line_1' is by default 'May cast one additional spell per level. This additional spell must be SCHOOL_PLACEHOLDER'; SCHOOL_PLACEHOLDER is swapped for 'string_school'. It is added to the top of the 'Advantages' list
if number_required=1.
<li>'new_line_2' is by default 'May cast one additional spell per level. At least NUMBER_PLACEHOLDER memorized spells of each level must be SCHOOL_PLACEHOLDER'; SCHOOL_PLACEHOLDER is swapped for 'string_school' and NUMBER_PLACEHOLDER is swapped for the value of 'number_required'. It is added to the top of the 'Advantages' list if number_required>1.
<li>
<li>list_spells, if set, includes a list of all spells from the preferred list. In this case, 'string_school2' (default value: the name-string of the specialist list, or the last such list if there is more than one) is substituted into the string 'The full list of SCHOOL_PLACEHOLDER_2 spells is:'.</li>
</ul>
</p>
<p><strong>set_spell_learn_modifiers(kit:s, modifiers:s)=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Set the externalized modifications to the chance of learning a spell. Specify 'kit' (a rowname from kitlist) and 'modifiers' (the actual LUA list of modifiers).
'modifiers' should be a comma-separated list with elements of form 'list=integer', where 'list' is either a spell list or 'default' (applies to all spell lists not called out.)
</p>
<p><strong>set_spell_list(chargen_choose_spells:b, update_scroll_usability:b=1, update_scrolls_later:b, silent:b, import_parent_blocks:b=1, class:s, kit:s, kit_clastext:s, block_learn:s="no_change", allow_learn:s="no_change", block_priest:s="no_change", allow_priest:s="no_change")=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Set the spell lists available to, or blocked for, a given class or kit (either set class to a class.ids entry, or kit to a 
kitlist.2da rowname). Each of block_learn, allow_learn, block_priest, or allow_priest can be a space-separated or comma-separated
list of spell-list keys, or 'no_change' (the default) in which case whatever it's currently set to will be unchanged.</p></p><p><p>If chargen_choose_spells=1, the lua also sets dwChargenChooseSpells to 1 for that class or kit. That causes the UI to try to
learn spells from the character's specialist list, if any. [This is an odd place to put this, on reflection.]</p></p><p><p>If update_scroll_usability=1, we also go through all scrolls and mark them up as usable/unusable for that class/kit.</p></p><p><p>If the spell system is not already set up, we set it up.
</p>
<p><strong>set_up_externalized_proficiencies()=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>sfo_batch_set</strong> action_macro (<a href="lib_sfo.html">lib_sfo</a>)<br></p>
<p><strong>sfo_batch_update()=()</strong> action (<a href="lib_sfo.html">lib_sfo</a>)<br></p>
<p><strong>sfo_crossplatform</strong> action_macro (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Load appropriate values of the various variables for different versions of BG.
</p>
<p><strong>sfo_fix()=()</strong> action (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
A few basic fixes:
<ul>
<li>make sure dir.ids is present and working
<li>add some possibly-missing entries to gtimes.ids and spell.ids
<li>remove + from missile.ids
<li>on BGEE, add some spell.ids entries missing that are present on SoD
</ul>
</p>
<p><strong>sfo_load(library:s)=()</strong> action (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Given a list of space-separated sfo library functions, load those functions and (recursively) any libraries they depend on.
</p>
<p><strong>sfo_path(path:s, location:s, locbase:s, file:s)=(file_path:s, path:s)</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Given some or all of 'file', 'path', 'location' and 'locbase', return a full filespec file_path (e.g. MOD_FOLDER/lib/lib_soundset.tph) and the path bit (e.g. "MOD_FOLDER/lib).</p>
<p>
Determined as follows:
<ul>
<li>if 'path' is set, just use it.
<li>if not, and 'location' is set:
	<ul>
	<li>if 'locbase is set, use 'MOD_FOLDER/locbase/location'
	<li>if not, and the 'component_loc' variable is set, use 'MOD_FOLDER/component_loc/location'
	<li>otherwise, use 'MOD_FOLDER/location'
	</ul>
<li>if not, and 'locbase' is set, use 'MOD_FOLDER/locbase'
<li>otherwise, just use ""
</ul>	
</p>
<p><strong>sfo_setup</strong> action_macro (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Set up the SFO directories and variables.</p><p></p>
<p><strong>shared_color_changes()=()</strong> action (<a href="ui_shared_code.html">ui_shared_code</a>)<br></p>
<p><strong>skip_hla_menu()=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>skip_hla_patch()=()</strong> patch (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>sod_hla_menu()=()</strong> action (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>sort_haterace()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>spell_system_extension_setup()=()</strong> action (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p>
<p><strong>spellstyle_apply_style(arguments:s, style_file:s)=()</strong> patch (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p>As a patch function, apply a style to a spell. 'arguments' is the style, 'style_file' contains the style data.</p>
<p><strong>spellstyle_collect_styles(prototypes:s=".../stratagems-inline/spell_style_prototypes.txt", output_loc:s, output:s)=()</strong> action (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p>Get the actual styles from a list of prototypes (probably not run in live-distributed code). The
default for prototypes is inline in this library.</p>
<p><strong>spellstyle_get_style_data()=(vvc:s, wav:s, glow:s)</strong> patch (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p>Get the style data (if any) for the current spell, as defined by its 'vvc' (an actual
vvc played by opcode 215, or a lighting type from opcode 141), its wav (played by opcode 174),
and its glow (played by opcode 50 or 61).
</p>
<p><strong>spellstyle_identify_style(style_file:s)=(style:s)</strong> patch (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p> Identify a style for the current spell, using 'style_file' as the list of styles</p>
<p><strong>spellstyle_load_styles(file:s)=(style_vvc:a, style_wav:a, style_glow:a)</strong> dimorphic (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p>
 Load in the data in a style list
 </p>
<p><strong>spellstyle_update_style(old_style:s, new_style:s)=()</strong> patch (<a href="lib_spellstyle.html">lib_spellstyle</a>)<br></p><p>Update the currently-being-patched spell's style, and log it as updated.</p><p></p>
<p><strong>spl_basic_ability_localcopy()=()</strong> patch (<a href="ui_extra_spells.html">ui_extra_spells</a>)<br></p>
<p><strong>spl_cd_scroll_name(spell_resref:s)=(scroll_resref:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Given a (wizard or priest) spell resref, assign it Cam's standard scroll name, i.e. CDIDxyz for SPPRxyz, CDIAxyz for SPWIxyz
</p>
<p><strong>spl_copy(tv:b, allow_missing:b, debug:b=1, is_ids:b="-1", standard_icons:b=1, create_scroll:b=1, overwrite:b, overwrite_on_mismatch:b, force_extended:b, spl:s, path:s, location:s, locbase:s, source_path:s, source_location:s, source_locbase:s, icon_base_name:s, icon_path:s, icon_location:s, icon_locbase:s, edits:f, type:s)=(value:s, scroll:s, spell_resref:s, scroll_resref:s)</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
General copier for spl files.</p>
<p>'spl' is a list of k=>v pairs. Each spell k.spl is copied to v.spl. source_path/source_location/source_locbase and 
path/location/locbase respectively define the locations of k.spl and v.spl, with an empty path interpreted as the override
in both cases. (If k is missing, we whine unless allow_missing=1.) The function 'edits' is applied to each file during copy. You can use the anonymous function construct; if you
do, the spl will be read into the struct 'm' beforehand and written back afterward.</p>
<p>Alternately, spl can be a list of strings k..., in which case k.spl is copied to k.spl as above.</p>
<p>If the dest file is an ids entry (determined heuristically unless is_ids is set) then we add it to spell.ids, use it as a resref, 
add icons in the standard format (unless standard_icons=0) and (unless create_scroll=0) build a scroll. In this case, we use icon_path, icon_location, icon_locbase (if set)
to determine where the spell icons are, and copy them over if they're in the format <icon_base_name>[ABC].bam. (If icon_base_name is unset, we use the ids name.)</p>
<p>By default, if the dest file is an IDS entry we put the spell in the SPWI, SPPR or SPIN namespace based on the type in the copied spell. You can override this by setting 'type' to 'wizard','priest','innate' or 'class'.
(But this only determines where the spell ends up; it doesn't change its internal type.</p>
<p>If tv=1, we prepend "_" onto each k and v on BGTUTU installs. </p>
<p>If debug=1, we try to debug the anonymous function to detect any nonexistent field writes.</p>
<p>Returns the resref of the last spell created (value; synonym:spell_resref), and its scroll (scroll; synonym:scroll_resref) if any. (Only really useful if you're copying to an ids, and only if you're only doing it once.)
</p>
<p><strong>spl_deabbreviate(spell:s)=(resref:s, type:s, level:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Take either a spell resref, or a spell ids name, or an abbreviated spell ids name (without the WIZARD_/CLERIC_ prefix). Return the spell resref, the level, and the type (innate/priest/wizard)
</p>
<p><strong>spl_edit(tv:i, allow_missing:b, debug:b=1, edit_strrefs_in_place:b, spl:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
General editor for spl files. spl is a list of resrefs, each with location defined by path/location/locbase, or
in override/a game file if all are blank. Each is copied, and edits is applied as a patch function. You can use the 
anonymous function construct; if you do, the spl will be read into the struct 'm' beforehand and written back afterward.</p>
<p>If tv=1, we prepend "_" onto each k and v on BGTUTU installs. </p>
<p>If debug=1, we try to debug the anonymous function to detect any nonexistent field writes.
</p>
<p><strong>spl_enforce_school(preloaded:b, sounds_colors:b=1, struct:s, arguments:s)=(struct:a)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Forces a spell to fit the rules for the specified school, or the current school if none is specified, adjusting casting colors, casting sounds, and for wizard spells, barred schools. 
Barred schools are read in from data_loc_shared/mageschools.tpa, or use the BG2/IWD defaults if it doesn't exist.</p><p>If preloaded=1, assume that the array 'unusable_array' already contains the unusuable spell types (good for batch application).
If sounds_colors=0, don't do the sounds and colors.</p><p>Note that this also works on items (i.e., scrolls), though the sounds/colors bit is skipped.
</p>
<p><strong>spl_generate_smtable(2da:s, contents:s, hit_animation:s, area_hit_animation:s)=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Streamlined generator for smtable 2das - assumes animations are constant (as is true in all vanilla entries)
</p>
<p><strong>spl_hide_spells(scrolls_only:i, spells:s, spell_array:s)=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Given a list of spells (as IDS), removes those spells entirely from the game: the spells themselves hidden in HIDESPL; all copies of the scrolls
are removed from stores, creatures, areas and 2da rndtres/rndscrol; the scroll itself is replaced by a minor gem. The actual spells are still present.</p>
<p>You can also specify the spells as a k=>blank array. If you set the INT_VAR scrolls_only to 1, the scrolls are removed but the spells are still available
to select at chargen and at sorcerer/shaman levelup, and are still given to priests.
</p>
<p><strong>spl_make(debug:b=1, is_ids:b="-1", standard_icons:b=1, create_scroll:b=1, force_extended:b, overwrite:b, overwrite_on_mismatch:b, spl:s, edits:f, location:s, locbase:s, path:s, icon_location:s, icon_locbase:s, icon_path:s, icon_base_name:s)=(value:s, scroll:s, spell_resref:s, scroll_resref:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
General maker for spl files.</p>
<p>We create a new spell 'spl'.spl, location specified by path/location/locbase, or 'override' if all are blank.
The function 'edits' is applied to the file after creation. You can use the anonymous function construct; if you
do, the spl will be read into the struct 'm' beforehand and written back afterward.</p>
<p>If spl is an ids entry (determined heuristically unless is_ids is set) then we add it to spell.ids, use it as a resref, 
add icons in the standard format (unless standard_icons=1) and (unless create_scroll=0) build a scroll.</p>
<p>If debug=1, we try to debug the anonymous function to detect any nonexistent field writes.</p>
<p>If force_extended=1, we add the spell to the extended namespace even if there's space in standard namespace.</p>
<p>If overwrite=1, we install the spell if it's already present, overwriting any previous copy (or giving that previous copy a new
placeholder IDS if it's at the wrong level/of the wrong type). If overwrite=0 and overwrite_on_mismatch=1, we overwrite only if there's a 
level or type mismatch. If overwrite_always=0 and overwrite_on_mismatch=0, we never overwrite. 
<p>Returns the resref of the spell, and its scroll if any.</p>
<p><strong>spl_make_all_scrolls(name_function:s="spl_cd_scroll_name", price_table:s="MOD_FOLDER/sfo/data/scroll_prices.2da")=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Construct a scroll for any SPPR/SPWI spell that doesn't have one and should (i.e. exclude spells unavailable to the player, as well as the Wild Mage spells)
</p>
<p><strong>spl_make_aura(spell:s, payload:s, effect:s)=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>Make an aura power. 'spell', when applied, permanently causes the caster to cast 'payload' 1/sec. The intermediate effect
has its name autogenerated unless set explicitly.</p>
<p><strong>spl_make_hla_class_ability(force_innate:b=1, resref:s, id:s)=(new_resref:s)</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Copy a spell (assumed to be a wizard/priest spell, though we don't enforce this) to the SPCL namespace.
and optionally make it innate. (Set force_innate=0 if you don't want to.)
You need to specify the resref. Optionally you can specify the id; if not we'll infer it or make it up. Strip it from any
clone (i.e., in simulacr/projimag) in the process. The new spell will have id HLA_[old_id]
</p>
<p><strong>spl_make_innate_repeating_spell(new_is_ids:i=1, cooldown:i, overwrite:i, allow_missing:i, patch_description:i=1, override_description:i, delete_casting:i, desc_strref_cd:i=100404, the, string, to, be, appended, to, the, description,, with, 99999, replaced, by, the, actual, repeat, time., Default, value, is, from, SCS, shared.tra, desc_strref_atwill:i=100405, this, string, says, 'use, at, will', and, gets, appended, instead, if, cooldown:i, arguments:s)=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Make a spell (from a template) that you get back after a certain period
</p>
<p><strong>spl_make_scroll(price:i="-1", spell_resref:s, scroll_resref:s, icon:s="%spell_resref%A", name_function:s="spl_cd_scroll_name", price_table:s="MOD_FOLDER/sfo/data/scroll_prices.2da")=(scroll_resref:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Given a (wizard or priest) spell, generate a scroll for that spell, using CamDawg's naming conventions by default
</p>
<p><strong>spl_make_summoning_2da(filename:s, monsters:s, anim_hit:s="msumm1h", anim_area:s="msumm1x")=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Given a list of monsters, a filename of a 2da (omitting '2da'), and an optional choice of anim_hit and anim_area animations
(defaulting to 'msumm1h' and 'msumm1x'), make a standard-format summoning 2da
</p>
<p><strong>spl_remap_level_9_wizard_spells()=()</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>Move the spells in the SPWI926-SPWI949 range into the SPWI0xyz range.</p>
<p><strong>spl_resolve_ids(level:i, force_extended:b, replace_on_mismatch:b, ids:s, type:[wizard|priest|innate|class|1|2|3|4|5])=(resref:s, mismatch:s, already_present:s, lua_line_needed:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Given an ids entry (WIZARD_THIS_SPELL, etc) find its id resref (or dw_ext_spell resref), if necessary adding it to spell.ids. Need to supply the spell type and the level.</p></p><p><p>On EE, if full, or if force_extended=1, add it to the extended namespace instead.</p></p><p><p>If it's already present, return already_present=1. Check if its level and type match the requested level and type. If not, return 'mismatch=1' (otherwise, return 0). If 'replace_on_mismatch' is set to 1,
instead replace the old id with a placeholder and add the new id in the correct place (and return mismatch=0, already_present=0).
</p>
<p><strong>spl_resolve_smtables_entry(name:s, 2da:s)=(value:s)</strong> action (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Return the number corresponding to a given named smtable.2da entry (we search for [0-9]+_name), adding it
if necessary (for the latter, need to supply a 2da name too.)
</p>
<p><strong>spl_resref_to_type_level(resref:s)=(type:s, level:s)</strong> dimorphic (<a href="lib_spl.html">lib_spl</a>)<br></p><p>
Take a spell resref of a spell in spell.ids. Return its type (priest/innate/class/wizard) and level (assuming it fits standard conventions, and using 1 for innate and class).
</p>
<p><strong>splconv(spell:s, new_type:s, tra_path:s="MOD_FOLDER/sfo/lua/lang", tra:s="sfo_lua", new_resref:s)=(new_resref:s, splconv_array:a)</strong> dimorphic (<a href="lib_splconv.html">lib_splconv</a>)<br></p><p>
Input a wizard/priest spell 'spell' in the SPWI/SPPR range (either a resref, or an ids name (from normal or extended namespace), or an abbreviated ids name) and a spell type 'new_type' (innate/priest/wizard).
Convert the spell, unless old and new types match. Return the resref of the new spell. Delete any headers where min_level>50, to remove scroll-making code & the like.</p></p><p><p>If 'tra_path' and 'tra' are set ('tra' does not include the .tra extension) then the function attempts to load strings @100-@105 from it and then to update the description
to include new casting time, remove reference to spheres, and add a note saying that this is an innate version of a spell normally available to wizards (or whatever). See
lua/lang/english/sfo_lua.tra in the sfo-lua template for the format.</p><p><p>'splconv_array' is a 2D array reporting all spells/items that reference SPPR/SPWI spells (other than themselves) via 206/318/321/324. We output it to avoid
having to regenerate it each time.
</p>
<p><strong>splconv_array_load()=(splconv_array:a)</strong> dimorphic (<a href="lib_splconv.html">lib_splconv</a>)<br></p>
<p><strong>splconv_clone_or_cast(resref:s, new_resref:s)=()</strong> patch (<a href="lib_splconv.html">lib_splconv</a>)<br></p>
<p><strong>splconv_get_name(new_type:s, type:s, resref:s, spell:s)=(new_resref:s)</strong> dimorphic (<a href="lib_splconv.html">lib_splconv</a>)<br></p>
<p><strong>splconv_update_desc(new_ct:i, tra:s, tra_path:s, old_type:s, new_type:s, old_desc:s)=(new_desc:s)</strong> patch (<a href="lib_splconv.html">lib_splconv</a>)<br></p>
<p><strong>ssl_core(inline:b, silent:b, script:s, variables:s, booleans:s, location:s, locbase:s, path:s)=(value:s)</strong> action (<a href="lib_ssl.html">lib_ssl</a>)<br></p><p>
Take 'script'.ssl, located at locbase|location|path (or located at .../stratagems-inline if inline=1), and compile it to a baf file of the same name, living in workspace/ssl_out.
If it's missing, whine unless silent=1. Return 1 if file exists to compile, 0 otherwise.
SSL input: variables are the concatenation of the external string 'sslvariables' and the function argument 'variables'; booleans are given by the eponymous function argument;
libraries are the concatenation of the external string 'ssllibrary' and 'weidu_external/data/MOD_FOLDER\autolib'.
</p>
<p><strong>ssl_to_baf(inline:b, silent:b, evaluate_variables:b=1, script:s, arguments:s, scripts:s, variables:s, booleans:s, location:s, locbase:s, path:s)=()</strong> action (<a href="lib_ssl.html">lib_ssl</a>)<br></p><p>
Take a list of ssl files 'script' (synonyms: 'arguments', 'scripts'), each located at locbase|location|path (or located at .../stratagems-inline if inline=1), 
and compile them to baf (leaving them at [workspace]/ssl_out), processing SSL line_if commands and carrying out EE-to-oBG2 swaps and custom-hotkey swaps as appropriate. 
If any are missing, whine unless silent=1. Evaluate variables unless evaluate_variables=0.</p></p><p><p>If input is instead in the form "k=>v list", compile each k.ssl to v.baf.</p></p><p><p>SSL input: variables are the concatenation of the external string 'sslvariables' and the function argument 'variables'; booleans are given by the eponymous function argument;
libraries are the concatenation of the external string 'ssllibrary' and 'weidu_external/data/MOD_FOLDER\autolib'.
</p>
<p><strong>ssl_to_bcs(inline:b, silent:b, script:s, arguments:s, scripts:s, variables:s, booleans:s, location:s, locbase:s, path:s)=()</strong> action (<a href="lib_ssl.html">lib_ssl</a>)<br></p><p>
Take a list of ssl files 'script' (synonyms: 'arguments', 'scripts'), each located at locbase|location|path (or located at .../stratagems-inline if inline=1), and compile them all the way to bcs, processing
SSL line_if commands and carrying out EE-to-oBG2 swaps and custom-hotkey swaps as appropriate. If any are missing, whine unless silent=1.</p>
<p>If input is instead in the form "k=>v list", compile each k.ssl to v.bcs.</p></p><p><p>SSL input: variables are the concatenation of the external string 'sslvariables' and the function argument 'variables'; booleans are given by the eponymous function argument;
libraries are the concatenation of the external string 'ssllibrary' and 'weidu_external/data/MOD_FOLDER\autolib'.
</p>
<p><strong>sto_copy(tv:i, allow_missing:i, debug:i=1, sto:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_sto.html">lib_sto</a>)<br></p>
<p><strong>sto_edit(tv:i, allow_missing:i, debug:i=1, edit_strrefs_in_place:i, sto:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_sto.html">lib_sto</a>)<br></p>
<p><strong>sto_make(debug:i=1, sto:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_sto.html">lib_sto</a>)<br></p>
<p><strong>strdoc_document_all_strtypes(path:s="MOD_FOLDER/sfo/structures", style_path:s="../../../doc/files", template_path:s="MOD_FOLDER/sfo/resource/strdoc_template.html", doc_path:s="MOD_FOLDER/sfo/doc")=()</strong> action (<a href="lib_strdoc.html">lib_strdoc</a>)<br></p>
<p><strong>strdoc_document_strtype(strtype:s, path:s="MOD_FOLDER/sfo/structures", style_path:s="../../../doc/files", template_path:s="MOD_FOLDER/sfo/resource/strdoc_template.html", doc_path:s="MOD_FOLDER/sfo/doc/struct")=()</strong> action (<a href="lib_strdoc.html">lib_strdoc</a>)<br></p>
<p><strong>strdoc_format_array_as_table(array:s)=(data:s)</strong> patch (<a href="lib_strdoc.html">lib_strdoc</a>)<br></p>
<p><strong>strdoc_format_header_data(filter1:f, filter2:f, filter3:f, filter1_title:s, filter2_title:s, filter3_title:s, title:s, description:s)=(data:s, data_alphabetical:s)</strong> patch (<a href="lib_strdoc.html">lib_strdoc</a>)<br></p>
<p><strong>strdoc_get_data(filter1:s, filter2:s, filter3:s)=(main_keys:a, meta_keys:a, special1_keys:a, special2_keys:a, special3_keys:a)</strong> patch (<a href="lib_strdoc.html">lib_strdoc</a>)<br></p>
<p><strong>strref_2da(function:s)=()</strong> patch (<a href="lib_strref.html">lib_strref</a>)<br></p><p>
Acting on the current file, assumed to be a 2da file, apply 'function' to each of the strrefs in it.</p>
<p>
Note that detection of which numbers in a 2da file are strrefs is of necessity a bit
heuristic. We assume that 
<ul>
<li>no integer lower than 160 is a strref (the actual values from 1-100 in BG2 are
dialog strings not referenced in 2das)
<li>no integer larger than 299999 is a strref (this is way bigger than any actual dlg)
<li>no integer in the following 2das is a strref:
   banttimg clearair extanim extspeed happy pplane raisdead randcolr repmodst splashs2 splashsc startare startbp startpos strmod strmodex xpbonus xpcap xplevel xplist
<li>no integer <10000 in the following is a strref:
end15fps endmve1 endmve2 endmve3 intro intro15f melissan xnewarea
<li>no integer in columns 0-2 of clastext is a strref
<li>nothing in hex notation is a strref
<li>all other integers are strrefs
</ul>
</p>
<p><strong>strref_apply(function:f)=()</strong> patch (<a href="lib_strref.html">lib_strref</a>)<br></p><p>
Apply the (SFO standard patch) function 'function' to every strref in the current file, replacing it with the output. Currently doesn't do wmp files.
</p>
<p><strong>strref_script(function:s)=()</strong> patch (<a href="lib_strref.html">lib_strref</a>)<br></p><p>
Acting on the current file, assumed to be a decompiled script, apply 'function' to each of the strrefs in it
</p>
<p><strong>struct_add(insert_point:i="-1", number:i=1, auto_open:b=1, auto_close:b=1, equip:b=1, replace:b, debug:b=1, struct:s, type:s, patch:f, match_parent:f, vertices:s, slots:s)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Adds 'number' new entries to the list of extended headers of type 'type', and then applies 'patch' to them. Entries are 
inserted before header 'insert_point', or after the last header if there is no such header (this is the default). 
'struct' is the struct in which the data is stored and is passed back at the end of the function. </p><p>If 'type' is of form 'parent_child' (e.g. 'ab_fx'), instead add entries of type 'child' as children of type 'parent'
in the same fashion, whenever the parent returns true to 'match_parent'.</p><p>You can use the anonymous function construct with 'patch', and 'match_parent'. By default (i.e. unless altered
by 'auto_open' and 'auto_close'), the anonymous function starts by opening the header into the struct 's', and finishes
by writing it back. Also by default, the parent (if any) is opened into the struct 'p'.</p><p>We can't enforce it, but to be meaningful the in and out 'struct' need to be the same (since we only write the changes).</p><p>If appropriate (e.g. for adding known spells to CRE files) the header array is sorted before reinsertion.
</p>
<p><strong>struct_alter(auto_open:b=1, auto_close:b=1, debug:b=1, equip:b, replace:b, struct:a, type:s, match:f, patch:f, match_parent:f, vertices:s, slots:s)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Applies a patch function 'patch' to every extended header of type 'type' that returns true (1) to function 'match',
or to every such header if no function is specified. 'struct' is the struct in which the data is stored and is passed
back at the end of the function. </p><p>If 'type' is of form 'parent_child' (e.g. 'ab_fx'), instead apply 'patch' to every child header of type 'child' whose
parent is type 'parent', and where the child returns true to 'match' and the parent returns true to 'match_parent'.</p><p>You can use the anonymous function construct with 'patch', 'match', and 'match_parent'. By default (i.e. unless altered
by 'auto_open' and 'auto_close'), the anonymous function starts by opening the header into the struct 's', and finishes
by writing it back. Also by default, the parent (if any) is opened into the struct 'p'.</p><p>We can't enforce it, but to be meaningful the in and out 'struct' need to be the same (since we only write the changes).</p><p></p>
<p><strong>struct_apply_regexp(auto_open:i, write:i=1, report_back:i=1, ext:s, regexp:s=".*", function:s, type:s, strtype:s)=(array:a)</strong> action (<a href="lib_struct.html">lib_struct</a>)<br></p><p>Quickly apply the function 'function' to every header of the specified type where the
file matches 'regexp'. Return an array of all entries where the fn returns 'value' for 
at least one entry. (Note that this does not use the struct system: the file is edited directly, not opened into a data structure.</p>
<p><strong>struct_clone(number:i=1, multi_match:i=9999, clone_above:i, auto_open:b=1, auto_close:b=1, open_on_match:b, open_parent:b, debug:b=1, struct:s, type:s, match:f, patch:f, match_parent:f, vertices:s)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Adds 'number' copies of any extended header of type 'type' which return true to the function 'match', and 
then applies 'patch' to them. 'struct' is the struct in which the data is stored and is passed back at the end of the function. </p><p>If 'type' is of form 'parent_child' (e.g. 'ab_fx'), instead clone entries of type 'child' as children of type 'parent'
in the same fashion, under the additional requirement that the parent returns true to 'match_parent'.</p><p>You can use the anonymous function construct with 'patch', 'match', and 'match_parent'. By default (i.e. unless altered
by 'auto_open' and 'auto_close'), the anonymous function starts by opening the header into the struct 's', and finishes
by writing it back. Also by default, the parent (if any) is opened into the struct 'p'.</p><p>We can't enforce it, but to be meaningful the in and out 'struct' need to be the same (since we only write the changes).</p><p></p>
<p><strong>struct_copy(allow_missing:i, tv:i, debug:i=1, file:s, ext:s, edits:s, path:s, location:s, locbase:s, source_path:s, source_location:s, source_locbase:s)=()</strong> action (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
'file' is a string of k=>v pairs (or string of single entries, treated as k=. Copy each k to v (or k.default_ext to v.default_ext if it
is set). k and v are located at SFO-standard locations defined by, respectively, (source_path/source_location/source_locbase)
and (path/location/locbase), with 'override' as the default in each case.</p><p>Apply 'edits' as an anonymous patch function in the process, opening k into struct m in the process and
writing it at the end.)
</p>
<p><strong>struct_delete(auto_open:b=1, debug:b=1, struct:s, type:s, match:f, match_parent:f)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Delete any extended headers of type 'type' which return true to the function 'match'. 'struct' is the 
struct in which the data is stored and is passed back at the end of the function. (If 'match' is left blank, it always returns true.)</p><p>If 'type' is of form 'parent_child' (e.g. 'ab_fx'), instead delete entries of type 'child' as children of type 'parent'
in the same fashion, under the additional requirement that the parent returns true to 'match_parent'.</p><p>You can use the anonymous function construct with 'match' and 'match_parent'. By default (i.e. unless altered
by 'auto_open' and 'auto_close'), the anonymous function starts by opening the header into the struct 's'. 
Also by default, the parent (if any) is opened into the struct 'p'.</p><p>We can't enforce it, but to be meaningful the in and out 'struct' need to be the same (since we only write the changes).</p><p></p>
<p><strong>struct_display_lookups(struct:s)=()</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Display the lookup table for the extended-header types. (For debugging.)
</p>
<p><strong>struct_echo(struct:s, strtype:s)=()</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Display the contents of the 'header' part of an IE struct. (For debugging.)
</p>
<p><strong>struct_edit(allow_missing:b, tv:b, debug:b, edit_strrefs_in_place:b, open_extended:b="-1", file:s, ext:s, edits:s, path:s, location:s, locbase:s)=()</strong> action (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
'object' is a list of strings s, interpreted as files. Locate each file at path|location|locbase, defaulting to
in-game if all are empty. COPY or COPY_EXISTING COPY_EXISTING each s (or s.default_ext if it
is set) over itself. Apply 'edits' as an anonymous patch function in the process, opening s into struct m in the process and
writing it at the end.</p><p></p>
<p><strong>struct_expand_slots(slots:s)=(slots:s)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p>
<p><strong>struct_extract(array:a, struct:a)=(array:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>Given an array of keys, for each key which also keys the struct, set the corresponding
array value to the struct value.</p>
<p><strong>struct_get(arguments:s)=(value:s)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Returns the contents of a field. (Use for quick lightweight edits where it's not worth reading in the struct.)</p><p></p>
<p><strong>struct_get_offset_array2(offset:i, type:s)=(array:a)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Returns the secondary offset array at offset 'offset' for parent-child type type of the currently-being-patched strtype</p><p></p>
<p><strong>struct_get_offset_array(type:s)=(array:a)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Returns the offset array for type type of the currently-being-patched strtype</p><p></p>
<p><strong>struct_initialize</strong> action_macro (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
This reads in all the defining data for the various game files that lib_struct can patch. It's a macro because
there are lots of them and they're dispersed over lots of arrays; it's not convenient to bundle them up.</p><p>Here's what we do:
</p>
<p>
<ol>
<li>Read in the various lookups from str_lookup.ini and str_versions.ini, both forwards (for read) and backwards (for write).
<li>For each file type:
<ol>
<li>Read in its main header definitions (see struct_read_main_definitions)
<li>Read in the contents of the 2da file that gives the offsets and the like for its various extended components
<li>For each one of those, read in the header for it
<li>Read in the parent/child data (see struct_parent_child_definitions)
</ol>
<li>Read in the default file versions for each filetype and each game
</ol>
</p>
<p><strong>struct_inject(array_in:a, struct:s)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p><p>Put each k1...k_n=>v pair in array_in into the struct.</p>
<p><strong>struct_iter(struct:s, type:s)=(blockcount:s, length:s, iter_array:a)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
For given subtype 'type', return an array k=>v, where k is the index of a 'type' element
and v is its lookup in the struct; also return 'length', the number of 'type' elements, 
and 'blockcount', then length of the data block in the struct for that element.</p><p>(The struct version of GET_OFFSET_ARRAY)</p><p></p>
<p><strong>struct_iter_child(parent_index:i, struct:s, pc_id:s)=(blockcount:s, length:s, iter_array:a)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
For given For given parent_child type 'pc_id' and for given parent index 'parent_index',
return an array k=>v, where k is the index of a 'type' element
and v is its lookup in the struct; also return 'length', the number of 'type' elements, 
and 'blockcount', then length of the data block in the struct for that element.</p><p>(The struct version of GET_OFFSET_ARRAY2)</p><p></p>
<p><strong>struct_make(debug:i=1, file:s, ext:s, edits:s, version:s, path:s, location:s, locbase:s)=()</strong> action (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Make a new object of type ext. Open it into a struct m, apply the contents of 'edits' as an anonymous function,
and then write m back in again. If 'version' is unset, make the current game version.</p><p>
</p>
<p><strong>struct_new(strtype:s, ext:s)=(struct:a)</strong> dimorphic (<a href="lib_struct.html">lib_struct</a>)<br></p>
<p><strong>struct_read(open_header:b=1, open_extended:b=1, strtype:s, file:s, path:s)=(struct:a)</strong> action (<a href="lib_struct.html">lib_struct</a>)<br><strong>struct_read(open_header:b=1, open_extended:b=1, strtype:s)=(struct:a)</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
From 'path/file', or from existing game file 'file' if path is unspecified, or in patch context the currently-open file, 
read in its contents according to its structure definition, into the structure 'struct'.The file type is specified by 
'strtype'; note that we might well be editing an extended header in an INNER_PATCH, not the main file.</p><p>If strtype isn't specified, we assume we're patching a base file and we try to infer it from the file itself.</p><p>If open_header=0, we don't break up the header, we just read it in as one big string. (It takes maybe 5-10ms to process,
so this is unlikely to be necessary - if you're doing bulk patching, struct is too slow anyway.)</p><p>If open_extended=0, just read in the header, don't bother with the extended contents.</p><p></p>
<p><strong>struct_read_macro</strong> patch_macro (<a href="lib_struct.html">lib_struct</a>)<br></p>
<p><strong>struct_test(fraction:i=20)=()</strong> action (<a href="lib_struct.html">lib_struct</a>)<br></p><p>Process a fraction of all are/cre/itm/spl/sto files through struct_read/struct_write and see which ones change. The fraction is one in (INT_VAR fraction). </p>
<p><strong>struct_write(write_header:b=1, write_extended:b=1, telemetry:b, overwrite:b, edit_strrefs_in_place:b, strtype:s, struct:s, file:s, path:s)=()</strong> action (<a href="lib_struct.html">lib_struct</a>)<br><strong>struct_write(write_header:b=1, write_extended:b=1, edit_strrefs_in_place:b, telemetry:b, overwrite:b, struct:s, strtype:s)=()</strong> patch (<a href="lib_struct.html">lib_struct</a>)<br></p><p>
Given a structure 'struct', write it to 'path/file', or to existing game file 'file' if path is unspecified, or to the currently-open file in patch context.
The file type is specified by 'strtype'; note that we might well be editing an extended header
in an INNER_PATCH, not the main file. If strype isn't specified, we assume we're patching a base file and we read it in from the struct itself.</p><p>if write_header=0, leave the header alone; similarly for write_extended.
</p>
<p><strong>sugar_apply(patch_only:i)=()</strong> patch (<a href="lib_sugar.html">lib_sugar</a>)<br></p><p>
Apply SFO's syntactic sugar to the current file. If 'patch_only' is set to 1, don't bother with the action parts.
</p>
<p><strong>sugar_semicolons()=()</strong> patch (<a href="lib_sugar.html">lib_sugar</a>)<br></p><p>
Replace double semicolons with line breaks. </p><p></p>
<p><strong>sugar_test()=()</strong> action (<a href="lib_sugar.html">lib_sugar</a>)<br></p><p>
Copy over the inline file 'sugartest.tp2' (at the end of this library) and apply syntactic sugar to it, then INCLUDE it to check it's well-formed.
</p>
<p><strong>systemcall_patch()=()</strong> patch (<a href="ui_system_call.html">ui_system_call</a>)<br></p>
<p><strong>tolower(arguments:s)=(value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a string, return it in lower case. (This is for use in functional programming - WEIDU's TO_LOWER suffices for first-order code.)
</p>
<p><strong>tolower_safe(arguments:s)=(value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Convert the (assumed mixed-case) string to lowercase, skipping any accented characters
</p>
<p><strong>toupper(arguments:s)=(value:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a string, return it in upper case.
</p>
<p><strong>trim_string(require_both:i, character:s=" ", string:s)=(string:s)</strong> dimorphic (<a href="lib_fn.html">lib_fn</a>)<br></p><p>
Given a single string, and a character (space by default) remove any occurrences of the character from the beginning and end of the string.
If require_both=1, only strip if the character appears at beginning and end (and only strip one).
</p>
<p><strong>ui_activate_ability_select()=()</strong> patch (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>UI_add_function(function:s, location:s, locbase:s, path:s)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Adds the contents of the file 'function' (optionally located at the SFO location given by location/locbase/path) immediately before the first function definition in the current file.
(Use to add functions to UI.menu - but 99% of the time it's better to define them in your own custom lua file.)
</p>
<p><strong>ui_add_missing_on_opens()=()</strong> action (<a href="ui_on_open.html">ui_on_open</a>)<br></p>
<p><strong>ui_add_portraits(force_cd:i, portrait_path:s, portrait_table:s, disable:s, enable:s)=()</strong> action (<a href="ui_add_portraits.html">ui_add_portraits</a>)<br></p><p>Add some new portraits into the system, or modify existing ones (EE only)</p></p><p><p>The portraits should be listed in a 2DA table of form
<table>
<tr><td></td>  			<td>skin</td>	<td>hair</td>	<td>major</td>	<td>minor</td>	<td>race</td>	<td>sex</td>		<td>class</td>		<td>disabled</td></tr>
<td>EXAMPLE</td>	   <td>INT</td>		<td>INT</td>	<td>INT</td>	<td>INT</td>	<td>human</td>	<td>f</td>			<td>fighter</td>	<td>no</td></tr>
</table>
 (any of these columns can be missing, in which case defaults are assumed.) The function generates
a master table of this form which lives in the 'shared' subdirectory of weidu_external (specifically,
at weidu_external/data/shared/dw_portraits.2da)</p>
<p>
<ul>
<li>'skin', 'hair', 'major' and 'minor' are the colors - as used by the UI - that should be assigned by default if the portrait is selected. (You can edit these 
<li>'race' can be any of human, halfelf, elf, dwarf, halfling, gnome, halforc, special (the default).</li>
<li>'class' can be fighter, wizard, cleric, thief, bard, barbarian, special (the default).</li>
<li>'sex' can be f, m, fm (the default).</li>
<li>'disabled' can be yes or no (the default).</li>
</ul>
</p>
<p>The bmps themselves should be named as follows:
<ul>
<li>EXAMPLEhires.bmp (for large high-resolution portraits) - copied to the L slot</li>
<li>EXAMPLE330.bmp - also copied to the L slot</li>
<li>EXAMPLEL.bmp - copied direct to the L slot</li>
<li>EXAMPLE269.bmp - copied to the M slot</li>
<li>EXAMPLEM.bmp - copied to the M slot</li>
</ul>
<p>
<p>The function takes these variables:
<ul>
<li>portrait_table: the full path to a new table, of the above form, to be added
<li>portrait_path: the path to the directory containing any new portrait BMPs listed in the table (or, if no table is given, containing any 
<li>portrait BMPs just to be copied over directly - mostly applies to the core IWD/BG/BG2 portraits)
<li>disable: a list, separated by spaces, of portrait base names to disable from the system
<li>enable: a list, separated by spaces, of portrait base names to enable in the systems
</ul>
<p>On a non-EE install we default to CamDawg's cd_portrait_copy (which is assumed as a dependency); you can force this even on EE by setting INT_VAR force_cd=1.
</p>
<p><strong>UI_add_string(tra_entry:i, string_id:s, string:s)=()</strong> action (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Add a string to the lua string file appropriate for the current game language (e.g., L_EN_US.lua if you're playing in English). 'string_id' is the lua string ID for the string; you can specify the string either via the INT_VAR tra_entry (an entry in your current .tra file) or directly as the STR_VAR 'string'.)
</p>
<p><strong>UI_add_string_array(array:a)=()</strong> dimorphic (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Given a k=>v array 'array' with entries like MY_TEXT_STRING=>1234, go through each 
entry, and for each, get the string with tra ref 1234 in the current tra file and
set TEXT_STRING equal to it in the current EE language file (e.g., l_en_us.lua).</p><p>Exits with a warning if not on EE.</p><p></p>
<p><strong>UI_alter_function(function:s, patch:f)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Find the lua function 'function' in the current file. Extract it, apply the patch function 'patch' to it (you can use the anonymous function construct) and put it back.</p></p><p><p>Note that the heuristic used to find the function is fairly crude: it assumes that the function finishes at the first 'end' that starts a new line. (This matches most, but not quite all,
functions in ui.menu.)
</p>
<p><strong>UI_alter_object(silent:i, object:s, object_type:s, object_name_field:s="name", patch:f)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>Apply the patch function 'patch' to the matched ui object in the current file, and substitute the result back in. You can use the anonymous function construct.</p>
<p><strong>UI_analyze_object(object:s, object_type:s, object_name_field:s="name", patch:f)=(patch_output:a)</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>Apply the patch function 'patch' to the matched ui object in the current file. 'patch' should return an array called 'patch_output, which is in turn returned
by UI_analyze object return 'patch_output' The actual result of the patch is discarded (i.e., the file being patched isn't changed), so the purpose of
this is to extract information from ui.menu. You can use the anonymous function construct.</p>
<p><strong>ui_copy_spell_lists(from:s, to:s)=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Read in the spell lists associated with a given kit, and copy it to a different kit
</p>
<p><strong>ui_deolvynize()=(value:s)</strong> action (<a href="ui_deolvynize.html">ui_deolvynize</a>)<br></p><p>
This attempts to reverse the effect of OlvynChuru's ClassSpellTool function on menu.ui and to move all spells added by ClassSpellTools to the SFO-lua system. It's not been extensively tested in the wild.</p>
<p>Idempotent (you can run it as many times as you like).</p><p></p>
<p><strong>ui_detect_class_kit(version:s)=()</strong> action (<a href="ui_detect_class_kit.html">ui_detect_class_kit</a>)<br></p><p>
Set up all the resources to detect the class and kit (etc). Note that unlike other SFO-lua libraries, this one just reinstalls itself every time you build it (since new classes and kits may have been added).
'Version', if set to 1, is used for debugging.
</p>
<p><strong>ui_externalize_hlas(min:i, step:i)=()</strong> action (<a href="ui_externalize_hlas.html">ui_externalize_hlas</a>)<br></p>
<p><strong>UI_get_coordinates()=(patch_output:a)</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Look through the current file for the coordinates of an object (specified by four integers separated by spaces) and/or a bam file (specified by 'BAM [whatever]'). Return them in an array with keys bam, xloc, yloc, width, height.
(Use in conjuction with UI_analyze_object).
</p>
<p><strong>ui_info_button_wrap()=()</strong> patch (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>ui_info_replace_sod()=()</strong> patch (<a href="ui_hla_menus.html">ui_hla_menus</a>)<br></p>
<p><strong>ui_inn_label()=()</strong> action (<a href="ui_inn_label.html">ui_inn_label</a>)<br></p>
<p><strong>UI_insert_into_object(object:s, object_type:s, object_name_field:s="name", insert:s, insert_data:s, path:s, location:s, locbase:s)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>Insert the contents of the file 'insert' (optionally located at the location picked out by path/location/locbase in usual SFO fashion) at the end of the matched ui object in the current file. Alternately, insert the string 'insert_data' in this way.</p>
<p><strong>UI_install_function(inline:b, lua_file:s, new_function:s, new_function_path:s, location:s, locbase:s, path:s, search_string:s)=()</strong> action (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Add the contents of the file at 'new_function' (legacy synonym: new_function_path), optionally located at the location specified SFO-style by location/locbase/path (or inline if inline=1), to the end of the in-game lua file 'lua_file', creating it if necessary. If 'search_string' is set, only add the function if that string is not present in the lua already.</p>
</p>
<p><strong>ui_on_open_patch()=()</strong> patch (<a href="ui_on_open.html">ui_on_open</a>)<br></p>
<p><strong>ui_on_open_setup()=()</strong> action (<a href="ui_on_open.html">ui_on_open</a>)<br></p>
<p><strong>ui_ranger_favored_enemy_setup()=()</strong> action (<a href="ui_ranger_favored_enemy.html">ui_ranger_favored_enemy</a>)<br></p>
<p><strong>ui_read_all_spell_lists()=(block_learn:a, block_priest:a, allow_learn:a, allow_priest:a, list_names:a, kit_names:a)</strong> dimorphic (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Read in all the spell lists, and store them in arrays block_learn, block_priest, allow_learn, allow_priest, in this format:
$allow_priest(OHTEMPUS combat)=1. Also return a k=>_ array of all list names, and a k=> array of all kit names.
</p>
<p><strong>ui_read_spell_lists(literal:b, kit:s)=(learn:s, priest:s, block_learn:s, block_priest:s)</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Read in the spell lists associated with a given kit. If literal=1, leave in the commas and quote marks; otherwise remove them.
</p>
<p><strong>UI_remove_function(function:s)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Find the lua function 'function' in the current file. Remove it.</p></p><p><p>Note that the heuristic used to find the function is fairly crude: it assumes that the function finishes at the first 'end' that starts a new line. (This matches most, but not quite all,
functions in ui.menu.)
</p>
<p><strong>UI_replace_function(inline:b, function:s, new_function:s, new_function_path:s, location:s, locbase:s, path:s)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>
Find the lua function 'function' in the current file. Replace it with the contents of the file at 'new_function' (legacy synonym: new_function_path), optionally located at the location specified SFO-style by location/locbase/path (or inline if inline=1.</p></p><p><p>Note that the heuristic used to find the function is fairly crude: it assumes that the function finishes at the first 'end' that starts a new line. (This matches most, but not quite all,
functions in ui.menu.)
</p>
<p><strong>UI_replace_object(object:s, object_type:s, object_name_field:s="name", replace:s, path:s, location:s, locbase:s)=()</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>Replace the matched ui object in the current file with the contents of the file 'replace' (optionally located at the location picked out by path/location/locbase in usual SFO fashion).</p>
<p><strong>UI_return_object(object:s, object_type:s, object_name_field:s="name", patch:f)=(object_data:s)</strong> patch (<a href="lib_ui.html">lib_ui</a>)<br></p><p>Apply the patch function 'patch' to the matched ui object in the current file, and then return that object, as the value of a string variable.</p>
<p><strong>ui_spell_system_schools(force_rebuild:b, tra:s=sfo_lua, tra_path:s="DEFAULT")=()</strong> action (<a href="ui_spell_system_schools.html">ui_spell_system_schools</a>)<br></p>
<p><strong>ui_spell_system_setup()=()</strong> action (<a href="ui_spell_system.html">ui_spell_system</a>)<br></p><p>
Set up the externalized spell system. (Idempotent.)
</p>
<p><strong>ui_spell_system_spheres(path:s="sphere", list:s="sphere_list.2da", tra:s="sphere", tra_path:s="MOD_FOLDER/lang", base_tra:s=sfo_lua, base_tra_path:s="DEFAULT", 3p_folder:s=dw_tof3p)=()</strong> action (<a href="ui_spell_system_spheres.html">ui_spell_system_spheres</a>)<br></p>
<p><strong>ui_stress_test()=()</strong> action (<a href="ui_stress_test.html">ui_stress_test</a>)<br></p>
<p><strong>ui_system_call_setup()=()</strong> action (<a href="ui_system_call.html">ui_system_call</a>)<br></p>
<p><strong>virtual_class_setup()=()</strong> action (<a href="ui_virtual_class.html">ui_virtual_class</a>)<br></p><p>
Set up the various lua files and menu edits for virtual classes
</p>
<p><strong>vtable_debug(function:s, vtable:s, struct:s)=()</strong> dimorphic (<a href="lib_vtable.html">lib_vtable</a>)<br></p><p>Checks an expression (assumed to be an anon function) for apparent references to
nonexistent keys.</p>
<p><strong>vtable_generate_aliases(vtable:s)=()</strong> action (<a href="lib_vtable.html">lib_vtable</a>)<br></p>
<p><strong>vtable_initialize</strong> action_macro (<a href="lib_vtable.html">lib_vtable</a>)<br></p>
<p><strong>vtable_read(silent:b, row:s, vtable:s)=(struct:a)</strong> dimorphic (<a href="lib_vtable.html">lib_vtable</a>)<br></p><p>
Read a virtual-table row into an array.</p><p>This is hardcoded for speed - even using 2daq functions slows things down a bit, and that matters for bulk editing of kits.
</p>
<p><strong>vtable_write(edit_strrefs_in_place:i, vtable:s, row:s, struct:s)=()</strong> dimorphic (<a href="lib_vtable.html">lib_vtable</a>)<br></p>
<p><strong>vvc_copy(allow_missing:i, debug:i=1, vvc:s, source_path:s, source_location:s, source_locbase:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_vvc.html">lib_vvc</a>)<br></p>
<p><strong>vvc_edit(allow_missing:i, debug:i=1, vvc:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_vvc.html">lib_vvc</a>)<br></p>
<p><strong>vvc_make(debug:i=1, vvc:s, version:s, path:s, location:s, locbase:s, edits:s)=()</strong> action (<a href="lib_vvc.html">lib_vvc</a>)<br></p>
<p><strong>warning(repeat:i, warning:s, arguments:s)=()</strong> dimorphic (<a href="lib_sfo.html">lib_sfo</a>)<br></p><p>
Dump the string 'warning' (synonym: 'arguments') into data_loc/sfo_warnings.txt, prepended with the component number and mod name.
If repeat=0, only do this if it's not already there.
</p>
<p><strong>wed_add_door(name:s, tiles:s)=()</strong> patch (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Add a door to the current wed file. Supply the name (to match the are file)
and a string of k=>v pairs identifying the tile maps when the door is closed
</p>
<p><strong>wed_build(width:i, height:i, tis:s, wed:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Build a new, blank WED file of the specified height and width.
</p>
<p><strong>wed_crop_area(x:i, xlen:i, y:i, ylen:i, area_old:s, area_new:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Copy an area, cropping it to the desired
size (in tiles). </p></p><p><p>After doing it, you might want to rebuild
the TIS in NI, as it's quite inefficiently
stored in this algorithm</p></p><p><p>*Mostly* polygons need to be ordered with the
lowest point first (as per IESDP). But this is
NOT always correct and I can't work out the true
algorithm. </p></p><p><p>EE only
</p>
<p><strong>wed_delete_polygons(area:s, polygons:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Delete wall polygons by number.
</p>
<p><strong>wed_duplicate_area(area_old:s, area_new:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Make an identical but differently-named copy of an area
</p>
<p><strong>wed_flip_area(area:s, file_loc:s, script_array:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Flip an area along its vertical axis</p><p>You need to supply (in 'file_loc') 
a properly-named TIS file and associated
PVRZ files, plus (for legacy use) a legacy
TIS file with a 'v' name suffix, plus
the height,search and light maps</p><p>DO NOT do the inversion in Paint, as it apparently
scrambles transparency layers. Photoshop works.</p><p>You can also pass the program an array
of scripts (in the form $[script_array]("[script]")="")
whose coordinates need to be
inverted.</p><p>We are probably assuming ARE v1.0 in some places.
</p>
<p><strong>wed_get_polygons(xmin:i, xmax:i, ymin:i, ymax:i, wed:s, output_file:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Extract all the polygons in a specified region of a wed file.</p><p></p>
<p><strong>wed_remap_search_map_colors(map:s, reference:s, map_out:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Take a 4-bit spat out by Photoshop and remap
it to the standard 4-bit SR palette.  (Use L^2 distance
in color space if no exact match)</p><p>(I have tried to add 8bit=>4bit to this, but it's erratic
 and not a priority to fix)
 </p>
<p><strong>wed_swap_searchmap_code(old:i, new:i, map:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br><strong>wed_swap_searchmap_code(old:i, new:i)=()</strong> patch (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
??map IWD to BG2 searchmap??
NB not dimorphic</p><p></p>
<p><strong>wed_transcribe_polygons(delta_x:i, delta_y:i, st, retch_numerator:i=1, st, retch_denominator:i=1, st, retch_base_x:i, st, retch_base_y:i, from_area:s, to_area:s, polygons:s)=()</strong> action (<a href="lib_wed.html">lib_wed</a>)<br></p><p>
Transcribe the wall polygons with the associated
numbers from one wed file to another, optionally adjusting
their vertices and bounding boxes by delta and stretching
around a base point.</p><p>Polygons must be listed sequentially.
</p>
<p><strong>wipe_weapprof()=()</strong> action (<a href="ui_externalize_proficiencies.html">ui_externalize_proficiencies</a>)<br></p>
<p><strong>write_whatever(length:i, write:i, offset:i)=()</strong> patch (<a href="lib_tools.html">lib_tools</a>)<br></p><p>
Given an offset in the current file, a length that is 1,2,or 4, and an integer, write the integer to an appropriate-length slot at that offset.
</p>








</div>



</div>
</div>
</body>