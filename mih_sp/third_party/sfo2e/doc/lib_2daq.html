<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>lib_2daq function library</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../../doc/files/g3readme_cam_022916_dwedit.css" type="text/css" />
<link href="../../doc/files/g3icon.ico" rel="icon" type="image/bmp" />
</head>
<body>
<div id="container">
<div class="ribbon_bubble">
    <div class="ribbon_rectangle">
<h1>lib_2daq function library</h1>
</div>
    <div class="ribbon_triangle-l"></div>
    <div class="ribbon_triangle-r"></div>

<div class="section">
<p><strong>Dependencies:</strong> </p>
</div>

<div class="ribbon_rectangle_h2"><h2>Description</h2> </div>
    <div class="ribbon_triangle_h2-l"></div>
    <div class="ribbon_triangle_h2-r"></div>

<div class="section">
<p>Functions in lib_2daq act on in-game 2da files in-place, rather than the read/write paradigm used in lib_2da. They're optimized for speed insofar as I can manage it (the 'q' stands for 'quick').</p>
</div>

<div class="ribbon_rectangle_h2"><h2>Functions</h2> </div>
    <div class="ribbon_triangle_h2-l"></div>
    <div class="ribbon_triangle_h2-r"></div>

<div class="section">
<p><strong>2daq_copy_column(data_read:b, column:s, column_new:s="%column%")=(value:s)</strong> patch<br></p><p>
Copies a column in the current 2da file to the right-hand side of the table, with new column name 'column_new'. Returns 1 if copy is successful. Stoically silent if it isn't.</p><p></p>
<p><strong>2daq_copy_row(rowname_column:i, data_read:b, row:s, row_new:s="%row%")=(value:s)</strong> patch<br></p><p>
Copies a row in the current 2da file to the bottom of the table, with new row name 'row_new'. Returns 1 if copy is successful. Stoically silent if it isn't.</p><p>If 'rowname_column' is set, the row id is looked up in that column, and column 0 is assumed to be numbered sequentially.
(This is the convention for kitlist.2da.)</p><p></p>
<p><strong>2daq_extract(rowname_column:i, data_read:i, row:s, column:s, case:[m=mixedixed|upper|lower])=(value:s, rownum:s, array:a)</strong> patch<br><strong>2daq_extract(rowname_column:i, data_read:b, resref:s, row:s, column:s, case:s)=(value:s, array:a)</strong> action<br></p><p>
Given a column header and/or a row header, and a 2da file resref, (or, in patch context, the current 2da file), extract the column or row as k=>v array using the row or column headers, as appropriate, as keys.</p><p>If both row and column are set, instead return the element (if any) at (row,column) as 'value', as well as its row as 'rownum'.
</p>
<p><strong>2daq_has_column(data_read:b, column:s)=(value:s)</strong> patch<br></p><p>
Return 1 iff the current 2da file has 'column' as a column id. 
</p>
<p><strong>2daq_has_row(rowname_column:i, data_read:b, row:s)=(value:s)</strong> patch<br></p><p>
Return 1 iff the current 2da file has 'row' as a row id. (Check rowname_column).
</p>
<p><strong>2daq_inject(reflect:b, rowname_column:i, data_read:b, array:a)=()</strong> patch<br><strong>2daq_inject(reflect:b, rowname_column:i, data_read:b, array:a, resref:s)=()</strong> action<br></p><p>
Given a 2D struct 'array' and a 2da file resref, (or, in patch context, the current 2da file) insert the elements of the struct into the 2da. (i.e. if the struct contains "array_x_y" and x and y are row and column entries in the 2da, insert the value of array_x_y at (x,y).</p><p>If reflect=1, swap rows and columns. If rowname_column is nonzero, look up the row names in that column.
</p>
<p><strong>2daq_insert_column(column:s, insert_loc:[l="last"ast|before_last])=()</strong> patch<br></p><p>
Adds a new column, with header 'column', as the last column, or the second-to-last column if insert_loc is 'before_last'. All entries are filled with the 2da default value. </p>
<p><strong>2daq_insert_row(rowname_column:i, row:s)=()</strong> patch<br></p><p>
Adds a new row, with header 'row', as the last row. All entries are filled with the 2da default value. If rowname_column>0, we put the header in this column, and assume column 0 should be numbered sequentially from 0.
</p>








</div>



</div>
</div>
</body>