DEFINE_ACTION_FUNCTION dual_class_kits BEGIN

	// install specific functions and UI edit, if not already there
	
	ACTION_IF !FILE_EXISTS_IN_GAME "m_dw_duf.lua" BEGIN
		COPY ".../stratagems-inline/dual_class_functions.lua" "override/m_dw_duf.lua"
		COPY_EXISTING "ui.menu" override
			REPLACE_TEXTUALLY EXACT_MATCH 
				"characterScreen:OnDualClassButtonClick()" 
				"dwOriginalClass,dwOriginalKit=dwFindClassKit(2);characterScreen:OnDualClassButtonClick()"
		BUT_ONLY
	END

	// collect all the information about kits

	LAF collect_dual_class_kit_data END
	
END


DEFINE_ACTION_FUNCTION collect_dual_class_kit_data BEGIN

	LAF check_label STR_VAR label=dw#multiclass_specialists_permitted RET dualclass_specialist=value END

	// set up dedicated lua for the autogenerated override_chargen_kit entries
	
	COPY ".../stratagems-inline/blank" "override/m_dw_vce.lua"

	//get baseclass names
	
	ACTION_IF is_iwd BEGIN
		ACTION_GET_STRREF 814 fighter_string
		ACTION_GET_STRREF 817 mage_string	
	END ELSE BEGIN
		ACTION_GET_STRREF 10174 fighter_string
		ACTION_GET_STRREF 3139 mage_string
	END 
	ACTION_GET_STRREF 1079 cleric_string
	ACTION_GET_STRREF 1080 druid_string
	ACTION_GET_STRREF 1077 ranger_string
	ACTION_GET_STRREF 1082 thief_string


	COPY_EXISTING "clastext.2da" override
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW kitlist_data colcount
		FOR (row=0;row<kitlist_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER kitlist_data row 0 kit
			READ_2DA_ENTRY_FORMER kitlist_data row 1 class
			READ_2DA_ENTRY_FORMER kitlist_data row 5 name
			READ_2DA_ENTRY_FORMER kitlist_data row 4 desc
			TO_UPPER kit
			PATCH_MATCH "%kit%" WITH
			FIGHTER MAGE CLERIC DRUID THIEF RANGER BEGIN
				SET $kitID("%kit%")=0
				SET $name("%kit%")=name
				SET $desc("%kit%")=desc
				SPRINT $allow("%kit%") "{[1]={newclass=%class%, oldkit=0}}"
			END
			DEFAULT
			END
		END
	

	COPY_EXISTING "kitlist.2da" override
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW kitlist_data colcount
		FOR (row=1;row<kitlist_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER kitlist_data row 1 kit
			READ_2DA_ENTRY_FORMER kitlist_data row 0 kitID
			READ_2DA_ENTRY_FORMER kitlist_data row 3 name
			READ_2DA_ENTRY_FORMER kitlist_data row 4 desc
			READ_2DA_ENTRY_FORMER kitlist_data row 8 parent
			TO_UPPER kit
			PATCH_MATCH "%parent%" WITH 1 2 3 4 11 12 7 8 9 10 13 14 15 16 17 18 BEGIN // classes that can be part of a multiclass combo
			  SET $kitID("%kit%")=kitID
			  SET $name("%kit%")=name
			  SET $desc("%kit%")=desc
			  SPRINT $allow("%kit%") "{[1]={oldkit=%kitID%}}"
			  PATCH_IF dualclass_specialist BEGIN
				PATCH_MATCH "%kit%" WITH
				abjurer conjurer transmuter invoker diviner enchanter illusionist necromancer wildmage BEGIN
					SPRINT $allow("%kit%") "{[1]={oldkit=%kitID%},[2]={oldkit=0, newclass=1}}"
				END
				DEFAULT
				END
			  END
			END
			DEFAULT
			END
			// do name overrides
			INNER_ACTION BEGIN
			ACTION_GET_STRREF name name_string
			//mage/X
			ACTION_MATCH "%parent%" WITH
			2 3 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%mage_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=MAGE END		
			END
			4 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%mage_string%/%name_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=MAGE END					
			END
			DEFAULT
			END		
			// fighter/X
			ACTION_MATCH "%parent%" WITH
			1 3 4 11 BEGIN // 
				OUTER_SET override=RESOLVE_STR_REF ("%fighter_string%/%name_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=FIGHTER END
			END
			DEFAULT
			END
			// cleric/X
			ACTION_MATCH "%parent%" WITH
			2 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%cleric_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=CLERIC END
			END
			1 4 12 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%cleric_string%/%name_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=CLERIC END
		
			END
			DEFAULT
			END
			//thief/X
			ACTION_MATCH "%parent%" WITH
			1 2 3 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%thief_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=THIEF END			
			END
			DEFAULT
			END
			//X/druid
			ACTION_MATCH "%parent%" WITH
			2 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%druid_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=DRUID END

			END
			DEFAULT
			END
			// X/ranger
			ACTION_MATCH "%parent%" WITH
			3 BEGIN
				OUTER_SET override=RESOLVE_STR_REF ("%name_string%/%ranger_string%")
				LAF override_chargen_kit_name INT_VAR override use_tra=0 STR_VAR lua=m_dw_vce kit class=RANGER END

			END
			DEFAULT
			END
			END // end of INNER_ACTION

		END
	BUT_ONLY
	
	COPY_EXISTING "alignmnt.2da" override
		COUNT_2DA_COLS colcount
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY 0 (col - 1) (colcount - 1) col_header
			SPRINT $header("%col%") "%col_header%"
		END
		READ_2DA_ENTRIES_NOW alignmnt_data colcount
		FOR (row=0;row<alignmnt_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER alignmnt_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				SPRINT align_data ""
				FOR (col=1;col<=9;++col) BEGIN
					READ_2DA_ENTRY_FORMER alignmnt_data row col val
					PATCH_IF val=0 BEGIN
						SPRINT align $header("%col%")
						SPRINT align_data "%align_data%%align%=true, "
					END
				END
				SPRINT $align_data("%kit%") "%align_data%"
			END
		
		END
	BUT_ONLY
	
	COPY_EXISTING "clsrcreq.2da" override
		COUNT_2DA_COLS colcount
		FOR (col=1;col<colcount;++col) BEGIN
			READ_2DA_ENTRY 0 (col - 1) (colcount - 1) col_header
			SET $header("%col%") =IDS_OF_SYMBOL (race "%col_header%")
		END
		READ_2DA_ENTRIES_NOW clsrcreq_data colcount
		FOR (row=0;row<clsrcreq_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER clsrcreq_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				SPRINT race_data ""
				FOR (col=1;col<colcount;++col) BEGIN
					READ_2DA_ENTRY_FORMER clsrcreq_data row col val
					PATCH_IF val=0 BEGIN
						SPRINT race $header("%col%")
						SPRINT race_data "%race_data%[%race%]=true, "
					END
				END
				SPRINT $race_data("%kit%") "%race_data%"
			END
		
		END
	BUT_ONLY
	
	COPY_EXISTING "abclasrq.2da" override
		COUNT_2DA_COLS colcount
		READ_2DA_ENTRIES_NOW abil_data colcount
		FOR (row=0;row<abil_data;++row) BEGIN
			READ_2DA_ENTRY_FORMER abil_data row 0 kit
			TO_UPPER kit
			PATCH_IF VARIABLE_IS_SET $kitID("%kit%") BEGIN
				READ_2DA_ENTRY_FORMER abil_data row 1 str
				READ_2DA_ENTRY_FORMER abil_data row 2 dex
				READ_2DA_ENTRY_FORMER abil_data row 3 con
				READ_2DA_ENTRY_FORMER abil_data row 4 int
				READ_2DA_ENTRY_FORMER abil_data row 5 wis
				READ_2DA_ENTRY_FORMER abil_data row 6 cha
			END
			SPRINT data_here ""
			PATCH_FOR_EACH abil IN str dex con int wis cha BEGIN
				val=EVAL "%%abil%%"
				PATCH_IF val>0 BEGIN
					SPRINT data_here "%data_here%%abil%=%val%, "
				END
			END
			SPRINT $abil_data("%kit%") "%data_here%"
		END
	BUT_ONLY
	
	
	<<<<<<<< .../stratagems-inline/m_dw_dud.lua
	dwKitData={}
	>>>>>>>>
	
	COPY ".../stratagems-inline/m_dw_dud.lua" override
	
	OUTER_SPRINT data ""
	ACTION_PHP_EACH kitID AS kit=>id BEGIN
		OUTER_SPRINT data_here "dwKitData['%kit%']={ id=%id%, "
		ACTION_FOR_EACH entry IN name desc allow BEGIN
			OUTER_SPRINT val $"%entry%"("%kit%")
			OUTER_SPRINT data_here "%data_here% %entry%=%val%, "
		END
		OUTER_SPRINT align_data $align_data("%kit%")
		OUTER_SPRINT data_here "%data_here% forbid_alignment={%align_data%}, "
		OUTER_SPRINT race_data $race_data("%kit%")
		OUTER_SPRINT data_here "%data_here% forbid_race={%race_data%}, "
		OUTER_SPRINT abil_data $abil_data("%kit%")
		OUTER_SPRINT data_here "%data_here% ability_min={%abil_data%}, "
		OUTER_SPRINT data_here "%data_here%}"
		OUTER_SPRINT data "%data%%data_here%%WNL%"
	END
	APPEND "m_dw_dud.lua" "%data%" KEEP_CRLF
	


END

DEFINE_ACTION_FUNCTION add_dual_class_kit_option
	STR_VAR kit="" oldclass="" oldkit="" newclass=""
BEGIN
	// remove ' from entries
	ACTION_FOR_EACH variable IN kit oldkit oldclass newclass BEGIN
		OUTER_SPRINT old EVAL "%%variable%%"
		OUTER_PATCH_SAVE new "%old%" BEGIN
			REPLACE_TEXTUALLY "'.*" ""
		END
		OUTER_SPRINT "%variable%" "%new%"
	END
	// sanity check
	
	ACTION_IF !RESOURCE_CONTAINS "kitlist.2da" "%kit%" BEGIN
		LAF warning STR_VAR warning="Tried to enable dual-class option for kit %kit% but it doesn't exist" END
	END ELSE BEGIN
	// setup
	ACTION_IF !FILE_EXISTS_IN_GAME "m_dw_due.lua" BEGIN
		COPY ".../stratagems-inline/blank" "override/m_dw_due.lua"
	END
	OUTER_SPRINT data ""
	// get relevant parameters
	// old class
	ACTION_IF "%oldclass%" STRING_COMPARE "" BEGIN
		OUTER_SET number = IDS_OF_SYMBOL (class "%oldclass%")
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%oldclass=%number%, "
		END
	END
	ACTION_IF "%newclass%" STRING_COMPARE "" BEGIN
		OUTER_SET number = IDS_OF_SYMBOL (class "%newclass%")
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%newclass=%number%, "
		END
	END
	ACTION_IF "%oldkit%" STRING_COMPARE "" BEGIN
		OUTER_SET number="-1"
		ACTION_IF "%oldkit%" STRING_EQUAL_CASE trueclass BEGIN
			OUTER_SET number=0
		END ELSE BEGIN
		  COPY_EXISTING "kitlist.2da" "%workspace%"
			COUNT_2DA_COLS colcount
			READ_2DA_ENTRIES_NOW kitlist_data colcount
			FOR (row=0;row<kitlist_data;++row) BEGIN
				READ_2DA_ENTRY_FORMER kitlist_data row 1 kit_here
				PATCH_IF "%kit_here%" STRING_EQUAL_CASE "%oldkit%" BEGIN
					READ_2DA_ENTRY_FORMER kitlist_data row 0 number
				END
			END
		  BUT_ONLY
		END
		ACTION_IF number>=0 BEGIN
			OUTER_SPRINT data "%data%oldkit=%number%, "
		END ELSE BEGIN
			LAF warning STR_VAR warning="Dual-class option for kit %kit% references non-existent kit %oldkit%" END
		END
	END
	// write data
	ACTION_IF "%data%" STRING_COMPARE_CASE "" BEGIN
		APPEND "m_dw_due.lua" "table.insert(dwKitData['%kit%'].allow,{%data%})%WNL%"
	END
	END



END

<<<<<<<< .../stratagems-inline/dual_class_functions.lua

function dwDualClassKitList()

	kitList={}
	for _,v in pairs (dwKitData) do
		if dwDualClassKitAllowed(v) then
				table.insert(kitList,v)
		end	
	end
	
	return kitList

end

function dwDualClassKitAllowed(kit)
	
	-- inherit dwOriginalClass, dwOriginalKit, dwChargenClassId from environment

	allowed=nil
	
	for _,v in pairs (kit.allow) do
		allowed_here=true
		if (v.oldkit) then
			if v.oldkit ~= dwOriginalKit then
				allowed_here=nil
			end
		end
		if (v.oldclass) then
			if v.oldclass ~= dwOriginalClass then
				allowed_here=nil
			end
		end
		if (v.newclass) then
			if v.newclass ~= dwChargenClassId then
				allowed_here=nil
			end
		end
		if allowed_here then 
			allowed=true
		end
	end
	
	-- now check alignment, stats, race
	
	if allowed then
		if kit.forbid_alignment[dwFindAlignment()] then
			allowed=nil
		end
		if kit.forbid_race[dwFindRace()] then
			allowed=nil
		end
		abil_list={[1]='str',[2]='dex'}
		for _,v in pairs (abil_list) do
			val=string.gsub(characters[currentID].attr[v].base, '/[0-9]+', '')
			abil=tonumber (val)
			if kit.ability_min[v] then
				if kit.ability_min[v]>abil then
					allowed=nil
				end
			end
		end
		
	end
	
	return allowed

end

>>>>>>>>